<template>
 <div class="min-h-screen bg-gray-50">
  
  <!-- Header -->
  <header class="bg-white border-b border-gray-200">
   <div class="max-w-7xl mx-auto px-4 py-4 flex items-center gap-4">
    <img 
     src="/bazingse-logo.png" 
     alt="BaZingSe Logo" 
     class="w-12 h-12 object-contain"
    />
    <div>
     <h1 class="text-2xl font-bold text-gray-800">
      BaZingSe
     </h1>
    </div>
   </div>
  </header>

  <!-- Main Content -->
  <main class="mx-auto px-4 py-8">
   <!-- Main Container -->
   <div class="max-w-7xl mx-auto">
    <!-- BaZi Chart Section -->
    <div class="w-full">
     
     <!-- Quick Test Presets -->
     <div class="bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-200 rounded-lg p-3 mb-4">
      <div class="flex items-center gap-2 mb-2">
       <span class="text-xs font-semibold text-gray-700">‚ö° Quick Test:</span>
      </div>
      <div class="flex flex-wrap gap-2">
       <button
        v-for="(preset, idx) in testPresets"
        :key="idx"
        @click="loadPreset(preset)"
        class="px-3 py-1.5 text-xs font-medium rounded-md border transition-all hover:scale-105"
        :class="preset.gender === 'female' 
         ? 'bg-pink-50 border-pink-300 text-pink-700 hover:bg-pink-100' 
         : 'bg-blue-50 border-blue-300 text-blue-700 hover:bg-blue-100'"
       >
        <span class="font-mono">{{ preset.date }}</span>
        <span class="mx-1">{{ preset.time }}</span>
        <span>{{ preset.gender === 'female' ? '‚ôÄ' : '‚ôÇ' }}</span>
       </button>
      </div>
     </div>
     
     <!-- BaZi Chart with Integrated Input -->
     <div class="bg-white shadow-md p-6">
    <!-- Chart Grid with Input Fields -->
    <div class="w-full">
     <!-- Controls Row: Gender + Time Travel aligned with columns -->
     <div class="flex gap-1 mb-2 overflow-x-auto">
      <!-- Spacer for Hour column -->
      <div class="w-28 flex-shrink-0"></div>
      
      <!-- Gender in Day column position -->
      <div class="w-28 flex-shrink-0">
       <div class="flex justify-center gap-3">
        <label class="cursor-pointer flex items-center gap-0.5">
         <input
          type="radio"
          v-model="gender"
          value="male"
          class="w-3 h-3 text-blue-600 focus:ring-blue-500"
          @change="handleInputChange"
         />
         <span class="text-sm">‚ôÇ</span>
        </label>
        <label class="cursor-pointer flex items-center gap-0.5">
         <input
          type="radio"
          v-model="gender"
          value="female"
          class="w-3 h-3 text-pink-600 focus:ring-pink-500"
          @change="handleInputChange"
         />
         <span class="text-sm">‚ôÄ</span>
        </label>
       </div>
      </div>
      
      <!-- Spacers for Month and Year columns -->
      <div class="w-28 flex-shrink-0"></div>
      <div class="w-28 flex-shrink-0"></div>
      
      <!-- Time Travel checkbox (always visible) -->
      <div class="w-28 flex-shrink-0">
       <div class="flex justify-center">
        <label class="cursor-pointer flex items-center gap-1">
         <input 
          type="checkbox" 
          v-model="showAnalysisPeriod" 
          class="w-3 h-3 text-indigo-600 focus:ring-indigo-500"
          @change="handleAnalysisModeToggle"
         />
         <span class="text-xs font-medium text-indigo-700">üîÆ</span>
        </label>
       </div>
      </div>
     </div>
     
     <!-- Column Headers: Each input aligned with pillar below (9 columns max) -->
     <div class="flex gap-1 mb-2 overflow-x-auto items-center">
      
      <!-- Column 1: Hour (Natal) -->
      <div class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-gray-700 mb-1 text-center">ÊôÇ Hour</label>
       <div class="relative">
        <input
         v-if="!unknownHour"
         v-model="birthTime"
         type="time"
         class="w-full pl-1 pr-6 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-center hour-input-no-icon"
         @change="handleInputChange"
        />
        <input
         v-else
         value="?"
         disabled
         class="w-full px-1 py-1.5 text-xs border border-gray-300 bg-gray-100 text-center text-gray-500"
        />
        <button
         @click="unknownHour = !unknownHour; handleUnknownHourChange()"
         :class="[
          'absolute right-0.5 top-1/2 -translate-y-1/2 px-1 py-0.5 text-[10px] border transition-colors',
          unknownHour 
           ? 'bg-blue-500 text-white border-blue-500'
           : 'bg-white text-gray-600 border-gray-300'
         ]"
         title="Toggle unknown hour"
        >
         ?
        </button>
       </div>
      </div>
      
      <!-- Column 2: Day (Natal) -->
      <div class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-gray-700 mb-1 text-center">Êó• Day</label>
       <input
        v-model="dayInput"
        type="number"
        min="1"
        max="31"
        placeholder="DD"
        class="w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-center"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 3: Month (Natal) -->
      <div class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-gray-700 mb-1 text-center">Êúà Month</label>
       <input
        v-model="monthInput"
        type="number"
        min="1"
        max="12"
        placeholder="MM"
        class="w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-center"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 4: Year (Natal) -->
      <div class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-gray-700 mb-1 text-center">Âπ¥ Year</label>
       <input
        v-model="yearInput"
        type="number"
        min="1900"
        max="2100"
        placeholder="YYYY"
        class="w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-center"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Left Partition Divider (before 10Y Luck) -->
      <div v-if="chartData?.analysis_info?.has_luck_pillar" 
         class="relative flex-shrink-0 mx-3 self-stretch" 
         style="width: 2px; min-height: 60px;">
       <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
      </div>
      
      <!-- Column 5: 10-Year Luck (Label) -->
      <div v-if="chartData?.analysis_info?.has_luck_pillar" class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-purple-700 mb-1 text-center">ÈÅã 10Y Luck</label>
       <div class="px-1 py-1.5 text-xs bg-purple-50 border border-purple-300 text-center">
        <div class="text-[10px] font-bold text-purple-700 leading-tight">
         {{ currentLuckPillar?.timing?.start_year || '?' }} - {{ currentLuckPillar?.timing?.end_year || '?' }}
        </div>
       </div>
      </div>
      
      <!-- Right Partition Divider (after 10Y Luck) -->
      <div v-if="chartData?.analysis_info?.has_luck_pillar" 
         class="relative flex-shrink-0 mx-3 self-stretch" 
         style="width: 2px; min-height: 60px;">
       <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
      </div>
      
      <!-- Column 6: Annual (Analysis Year) - Always show when time travel mode is ON -->
      <div v-if="showAnalysisPeriod" class="w-28 flex-shrink-0">
       <div class="flex items-center justify-center gap-1 mb-1">
        <input 
         type="checkbox" 
         v-model="includeAnnualLuck" 
         class="w-2.5 h-2.5 cursor-pointer"
         style="accent-color: #C9B037;"
         @change="handleInputChange"
         title="Include Annual Luck in calculations"
        />
        <label class="text-[10px] font-semibold text-center cursor-pointer" 
            :style="includeAnnualLuck ? 'color: #8B7355;' : 'color: #9CA3AF;'"
            @click="includeAnnualLuck = !includeAnnualLuck; handleInputChange()"
            title="Click to toggle Annual Luck inclusion">
         Âπ¥ÈÅã Annual
        </label>
       </div>
       <input
        v-model.number="analysisYear"
        type="number"
        min="1900"
        max="2100"
        placeholder="YYYY"
        :class="includeAnnualLuck 
         ? 'w-full px-1 py-1.5 text-xs border focus:outline-none text-center'
         : 'w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-gray-400 focus:ring-1 focus:ring-gray-400 text-center bg-gray-50 opacity-60'"
        :style="includeAnnualLuck ? 'background: #F5F1E8; border-color: #C9B037; color: #8B7355;' : ''"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 7: Monthly (Analysis Month) - Only show if Annual is enabled -->
      <div v-if="showAnalysisPeriod && analysisYear && includeAnnualLuck" class="w-28 flex-shrink-0">
       <div class="flex items-center justify-center gap-1 mb-1">
        <input 
         type="checkbox" 
         v-model="includeMonthlyLuck" 
         class="w-2.5 h-2.5 cursor-pointer"
         style="accent-color: #C9B037;"
         @change="handleInputChange"
         title="Include Monthly Luck in calculations"
        />
        <label class="text-[10px] font-semibold text-center cursor-pointer" 
            :style="includeMonthlyLuck ? 'color: #8B7355;' : 'color: #9CA3AF;'"
            @click="includeMonthlyLuck = !includeMonthlyLuck; handleInputChange()"
            title="Click to toggle Monthly Luck inclusion">
         ÊúàÈÅã Monthly
        </label>
       </div>
       <input
        v-model.number="analysisMonth"
        type="number"
        min="1"
        max="12"
        placeholder="MM"
        :class="includeMonthlyLuck 
         ? 'w-full px-1 py-1.5 text-xs border focus:outline-none text-center'
         : 'w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-gray-400 focus:ring-1 focus:ring-gray-400 text-center bg-gray-50 opacity-60'"
        :style="includeMonthlyLuck ? 'background: #F5F1E8; border-color: #C9B037; color: #8B7355;' : ''"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 8: Daily (Analysis Day) - Only show if Monthly is enabled -->
      <div v-if="showAnalysisPeriod && analysisMonth && includeMonthlyLuck" class="w-28 flex-shrink-0">
       <div class="flex items-center justify-center gap-1 mb-1">
        <input 
         type="checkbox" 
         v-model="includeDailyLuck" 
         class="w-2.5 h-2.5 cursor-pointer"
         style="accent-color: #C9B037;"
         @change="handleInputChange"
         title="Include Daily Luck in calculations"
        />
        <label class="text-[10px] font-semibold text-center cursor-pointer" 
            :style="includeDailyLuck ? 'color: #8B7355;' : 'color: #9CA3AF;'"
            @click="includeDailyLuck = !includeDailyLuck; handleInputChange()"
            title="Click to toggle Daily Luck inclusion">
         Êó•ÈÅã Daily
        </label>
       </div>
       <input
        v-model.number="analysisDay"
        type="number"
        min="1"
        max="31"
        placeholder="DD"
        :class="includeDailyLuck 
         ? 'w-full px-1 py-1.5 text-xs border focus:outline-none text-center'
         : 'w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-gray-400 focus:ring-1 focus:ring-gray-400 text-center bg-gray-50 opacity-60'"
        :style="includeDailyLuck ? 'background: #F5F1E8; border-color: #C9B037; color: #8B7355;' : ''"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 9: Hourly (Analysis Time) - Only show if Daily is enabled -->
      <div v-if="showAnalysisPeriod && analysisDay && includeDailyLuck" class="w-28 flex-shrink-0">
       <div class="flex items-center justify-center gap-1 mb-1">
        <input 
         type="checkbox" 
         v-model="includeHourlyLuck" 
         class="w-2.5 h-2.5 cursor-pointer"
         style="accent-color: #C9B037;"
         @change="handleInputChange"
         title="Include Hourly Luck in calculations"
        />
        <label class="text-[10px] font-semibold text-center cursor-pointer" 
            :style="includeHourlyLuck ? 'color: #8B7355;' : 'color: #9CA3AF;'"
            @click="includeHourlyLuck = !includeHourlyLuck; handleInputChange()"
            title="Click to toggle Hourly Luck inclusion">
         ÊôÇÈÅã Hourly
        </label>
       </div>
       <input
        v-model="analysisTime"
        type="time"
        placeholder="HH:MM"
        :class="includeHourlyLuck 
         ? 'w-full px-1 py-1.5 text-xs border focus:outline-none text-center'
         : 'w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-gray-400 focus:ring-1 focus:ring-gray-400 text-center bg-gray-50 opacity-60'"
        :style="includeHourlyLuck ? 'background: #F5F1E8; border-color: #C9B037; color: #8B7355;' : ''"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Talisman Section Toggle (Á¨¶ - always visible) -->
      <div class="w-28 flex-shrink-0">
       <div class="flex justify-center mb-1">
        <label class="cursor-pointer flex items-center gap-1">
         <input 
          type="checkbox" 
          v-model="showTalismans" 
          class="w-3 h-3 text-teal-600 focus:ring-teal-500"
          style="accent-color: #14B8A6;"
          @change="handleInputChange"
         />
         <span class="text-xs font-medium text-teal-700">Á¨¶</span>
        </label>
       </div>
      </div>
      
      <!-- Location Section Toggle (Âú∞ - always visible) -->
      <div class="w-28 flex-shrink-0">
       <div class="flex justify-center mb-1">
        <label class="cursor-pointer flex items-center gap-1">
         <input 
          type="checkbox" 
          v-model="showLocation" 
          class="w-3 h-3 focus:ring-blue-500"
          style="accent-color: #2563EB;"
          @change="handleInputChange"
         />
         <span class="text-xs font-medium text-gray-700">Âú∞</span>
        </label>
       </div>
       <!-- Radio buttons for overseas/birthplace (only show when checked) -->
       <div v-if="showLocation" class="flex justify-center gap-1">
        <label class="cursor-pointer flex items-center gap-0.5">
         <input
          type="radio"
          v-model="locationType"
          value="overseas"
          class="w-2.5 h-2.5"
          style="accent-color: #2563EB;"
          @change="handleInputChange"
         />
         <span class="text-[10px] text-blue-700">Êµ∑</span>
        </label>
        <label class="cursor-pointer flex items-center gap-0.5">
         <input
          type="radio"
          v-model="locationType"
          value="birthplace"
          class="w-2.5 h-2.5"
          style="accent-color: #D97706;"
          @change="handleInputChange"
         />
         <span class="text-[10px] text-amber-700">ÈÑâ</span>
        </label>
       </div>
      </div>
      
     </div>

     <!-- Loading Indicator -->
     <div v-if="isLoading" class="text-center py-4">
      <div class="inline-flex items-center gap-2">
       <svg class="animate-spin h-5 w-5 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
       </svg>
       <span class="text-sm text-gray-600">Calculating...</span>
      </div>
     </div>

     <!-- BaZi Chart Display -->
     <div v-if="natalAndLuckPillars && !isLoading" class="relative">
      <!-- Natal + Luck Pillars (Horizontal Layout) -->
      <div class="relative overflow-x-auto" :class="totalPillarCount > 4 ? 'max-w-full' : 'max-w-lg'">
       
       <!-- Heavenly Stems Row -->
       <div class="flex gap-1 items-center">
        <!-- Natal + Luck Pillars -->
        <template v-for="(pillar, index) in natalAndLuckPillars" :key="`stem-${index}`">
         <!-- Left Partition: Before 10-year luck pillar (position 4) -->
         <div v-if="index === 4 && natalAndLuckPillars.length > 4" 
            class="relative flex-shrink-0 mx-3 self-stretch"
            style="width: 2px;">
          <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
         </div>
         
         <!-- Pillar Content -->
        <div class="relative w-28 flex-shrink-0">
         <div 
          :id="`stem-${index}`"
          class="aspect-square p-3 transition-all duration-300 relative flex flex-col items-center justify-center"
          :class="[
           hoveredNode === `stem-${index}` ? 'shadow-lg scale-105' : 'border border-gray-300',
           getNodeHighlightClass(`stem-${index}`),
           highlightedNodes.includes(`stem-${index}`) ? 'z-50' : '',
           index === 1 ? 'border-2 border-blue-500' : '',
           pillar.is10YearLuck ? 'border-2 border-purple-500' : '',
           pillar.isAnnualLuck && !includeAnnualLuck ? 'opacity-40 grayscale' : '',
           pillar.isMonthlyLuck && !includeMonthlyLuck ? 'opacity-40 grayscale' : '',
           pillar.isDailyLuck && !includeDailyLuck ? 'opacity-40 grayscale' : '',
           pillar.isHourlyLuck && !includeHourlyLuck ? 'opacity-40 grayscale' : '',
           (pillar.isTalismanYear || pillar.isTalismanMonth || pillar.isTalismanDay || pillar.isTalismanHour) ? 'border-2 border-teal-500' : '',
           pillar.isUnknown ? 'bg-gray-100 border-dashed opacity-60' : ''
          ]"
          :style="pillar.isUnknown ? {} : (pillar.stem ? getNodeBgColor(pillar.stem.element, pillar.stem.color) : {})"
         >
          <!-- Negative Badges (top-left corner, stacked vertically) -->
          <div v-if="pillar.stemNegatives && pillar.stemNegatives.length > 0" 
             class="absolute top-1 left-1 gap-0.5 z-20"
             :class="pillar.stemNegatives.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-start'">
           <div v-for="(neg, idx) in pillar.stemNegatives" 
              :key="`stem-neg-${index}-${idx}`"
              class="flex items-center justify-center font-bold transition-transform cursor-help"
              :class="[
               getNegativeBadgeSizeClass(neg.strength),
               isBadgeHighlighted(neg) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getNegativeBadgeStyle(neg)"
              :title="getNegativeBadgeTooltip(neg)"
              @mouseenter="handleBadgeHover(neg)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getNegativeBadgeSymbol(neg) }}</span>
           </div>
          </div>
          
          <!-- Transformation Badges (top-right corner, stacked vertically) -->
          <div v-if="pillar.stemTransformations && pillar.stemTransformations.length > 0" 
             class="absolute top-1 right-1 gap-0.5"
             :class="pillar.stemTransformations.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-end'">
           <div v-for="(trans, idx) in pillar.stemTransformations" 
              :key="`stem-trans-${index}-${idx}`"
              class="flex items-center justify-center font-bold rounded-full shadow-md transition-transform cursor-help"
              :class="[
               getTransformationSizeClass(trans.strength),
               isBadgeHighlighted(trans) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getTransformationBadgeStyles(trans)"
              :title="getTransformationTooltip(trans)"
              @mouseenter="handleBadgeHover(trans)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getTransformBadgeDisplay(trans.badge) }}</span>
           </div>
          </div>
          
          <!-- Pinyin name at top -->
          <div v-if="!pillar.isUnknown && pillar.stemName" class="text-xs text-gray-700 mb-1">{{ pillar.stemName }}</div>
          <!-- Chinese character (always show original from base) -->
          <div v-if="pillar.stem" class="text-2xl font-bold text-black">
           {{ pillar.stem.chinese }}
          </div>
          <div v-else class="text-xl text-gray-400">-</div>
          <!-- Element type -->
          <div v-if="!pillar.isUnknown && pillar.stem" class="text-xs text-gray-700">
           <template v-if="showTransformed && pillar.stem.transformedElement">
            {{ pillar.stem.transformedElement.replace('Yang ', '').replace('Yin ', '') }}
           </template>
           <template v-else>
            {{ pillar.stem.element.replace('Yang ', '').replace('Yin ', '') }} {{ pillar.stem.element.includes('Yang') ? '+' : '-' }}
           </template>
          </div>
          <!-- Ten God or Day Master -->
          <div v-if="!pillar.isUnknown" class="text-xs mt-1 text-gray-900">
           {{ index === 1 ? 'Day master' : (pillar.tenGod || '') }}
          </div>
          
          <!-- Combination Badges (bottom-right corner) -->
          <div v-if="pillar.stemCombinations && pillar.stemCombinations.length > 0" 
             class="absolute bottom-1 right-1 gap-0.5 flex items-start content-start"
             :class="pillar.stemCombinations.length >= 3 ? 'flex-wrap-reverse flex-row justify-end' : 'flex-row items-end'"
             :style="pillar.stemCombinations.length >= 3 ? 'max-width: 40px;' : ''">
           <div v-for="(comb, idx) in pillar.stemCombinations" 
              :key="`stem-comb-${index}-${idx}`"
              class="flex items-center justify-center font-bold rounded-full transition-transform cursor-help"
              :class="[
               getCombinationBadgeSizeClass(comb.strength),
               isBadgeHighlighted(comb) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getCombinationBadgeStyle(comb)"
              :title="getCombinationTooltip(comb)"
              @mouseenter="handleBadgeHover(comb)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getTransformBadgeDisplay(comb.badge) }}</span>
           </div>
          </div>
          
          
          
          <!-- Horizontal WuXing Flow to Next Stem (only in post/transformed view) -->
          <div v-if="viewMode !== 'base' && !pillar.isUnknown && pillar.stem && natalAndLuckPillars[index + 1]?.stem && index < natalAndLuckPillars.length - 1 && !natalAndLuckPillars[index + 1].isUnknown && getWuXingRelation(pillar.stem.element, natalAndLuckPillars[index + 1].stem.element)"
             class="absolute -right-3 top-1/2 -translate-y-1/2 text-lg font-bold z-30"
             :class="getWuXingRelationClass(pillar.stem.element, natalAndLuckPillars[index + 1].stem.element)"
             :title="`${pillar.stem.element} to ${natalAndLuckPillars[index + 1].stem.element}`">
           {{ getWuXingRelation(pillar.stem.element, natalAndLuckPillars[index + 1].stem.element) }}
          </div>
         </div>
        </div>
        
         <!-- Right Partition: After 10-year luck pillar (position 4 only) -->
         <div v-if="index === 4 && natalAndLuckPillars.length > 4" 
            class="relative flex-shrink-0 mx-3 self-stretch"
            style="width: 2px;">
          <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
         </div>
        </template>
       </div>
       
       <!-- Vertical WuXing Flow Indicators - Always present to maintain consistent spacing -->
       <div class="flex gap-1 -mt-1.5 -mb-1.5 relative z-40 items-center">
        <template v-for="(pillar, index) in natalAndLuckPillars" :key="`flow-${index}`">
         <!-- Left Partition spacer: Before 10-year luck pillar -->
         <div v-if="index === 4 && natalAndLuckPillars.length > 4" 
            class="flex-shrink-0 mx-3" style="width: 2px;"></div>
         
        <div class="flex justify-center items-center h-5 w-28 flex-shrink-0">
         <div v-if="viewMode !== 'base' && !pillar.isUnknown && pillar.stem && pillar.branch && getVerticalWuXingRelation(pillar.stem.element, pillar.branch.element)"
            class="text-lg font-bold"
            :class="getVerticalWuXingClass(pillar.stem.element, pillar.branch.element)"
            :title="`${pillar.stem.element} to ${pillar.branch.element}`">
          {{ getVerticalWuXingRelation(pillar.stem.element, pillar.branch.element) }}
         </div>
        </div>
        
         <!-- Right Partition spacer: After 10-year luck pillar -->
         <div v-if="index === 4 && natalAndLuckPillars.length > 4" 
            class="flex-shrink-0 mx-3" style="width: 2px;"></div>
        </template>
       </div>
       
       <!-- Earthly Branches Row -->
       <div class="flex gap-1 overflow-visible items-stretch">
        <template v-for="(pillar, index) in natalAndLuckPillars" :key="`branch-${index}`">
         <!-- Left Partition: Before 10-year luck pillar -->
         <div v-if="index === 4 && natalAndLuckPillars.length > 4" 
            class="relative flex-shrink-0 mx-3 self-stretch"
            style="width: 2px;">
          <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
         </div>
         
         <!-- Pillar Content -->
        <div class="relative w-28 flex-shrink-0">
         <div 
          :id="`branch-${index}`"
          class="pb-0 pt-2 px-3 transition-all duration-300 relative flex flex-col items-center justify-start"
          :class="[
           hoveredNode === `branch-${index}` ? 'shadow-lg scale-105' : 'border border-gray-300',
           getNodeHighlightClass(`branch-${index}`),
           highlightedNodes.includes(`branch-${index}`) ? 'z-50' : '',
           index === 1 ? 'border-2 border-blue-500' : '',
           pillar.is10YearLuck ? 'border-2 border-purple-500' : '',
           pillar.isAnnualLuck && !includeAnnualLuck ? 'opacity-40 grayscale' : '',
           pillar.isMonthlyLuck && !includeMonthlyLuck ? 'opacity-40 grayscale' : '',
           pillar.isDailyLuck && !includeDailyLuck ? 'opacity-40 grayscale' : '',
           pillar.isHourlyLuck && !includeHourlyLuck ? 'opacity-40 grayscale' : '',
           (pillar.isTalismanYear || pillar.isTalismanMonth || pillar.isTalismanDay || pillar.isTalismanHour) ? 'border-2 border-teal-500' : '',
           pillar.isUnknown ? 'bg-gray-100 border-dashed opacity-60' : ''
          ]"
          :style="pillar.isUnknown ? { aspectRatio: '1/1.2' } : {
           ...(pillar.branch ? getNodeBgColor(pillar.branch.element, pillar.branch.color) : {}),
           aspectRatio: '1/1.2' // 20% taller than square
          }"
         >
          <!-- Negative Badges (top-left corner, stacked vertically) -->
          <div v-if="pillar.branchNegatives && pillar.branchNegatives.length > 0" 
             class="absolute top-1 left-1 gap-0.5 z-20"
             :class="pillar.branchNegatives.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-start'">
           <div v-for="(neg, idx) in pillar.branchNegatives" 
              :key="`branch-neg-${index}-${idx}`"
              class="flex items-center justify-center font-bold transition-transform cursor-help"
              :class="[
               getNegativeBadgeSizeClass(neg.strength),
               isBadgeHighlighted(neg) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getNegativeBadgeStyle(neg)"
              :title="getNegativeBadgeTooltip(neg)"
              @mouseenter="handleBadgeHover(neg)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getNegativeBadgeSymbol(neg) }}</span>
           </div>
          </div>
          
          <!-- Transformation Badges (top-right corner, stacked vertically) -->
          <div v-if="pillar.branchTransformations && pillar.branchTransformations.length > 0" 
             class="absolute top-1 right-1 gap-0.5 z-10"
             :class="pillar.branchTransformations.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-end'">
           <div v-for="(trans, idx) in pillar.branchTransformations" 
              :key="`branch-trans-${index}-${idx}`"
              class="flex items-center justify-center font-bold rounded-full shadow-md transition-transform cursor-help"
              :class="[
               getTransformationSizeClass(trans.strength),
               isBadgeHighlighted(trans) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getTransformationBadgeStyles(trans)"
              :title="getTransformationTooltip(trans)"
              @mouseenter="handleBadgeHover(trans)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getTransformBadgeDisplay(trans.badge) }}</span>
           </div>
          </div>
          
          <!-- Main content with proper spacing from bottom -->
          <div class="flex-1 flex flex-col items-center justify-center pb-10">
           <!-- Branch pinyin name (always show original) -->
           <div v-if="!pillar.isUnknown && pillar.branchName" class="text-xs text-gray-700 mb-1">
            {{ pillar.branchName }}
           </div>
           <!-- Chinese character (always show original from base) -->
           <div v-if="pillar.branch" class="text-2xl font-bold text-black">
            {{ pillar.branch.chinese }}
           </div>
           <div v-else class="text-xl text-gray-400">-</div>
           <!-- Animal name (only show if not a pure element transformation) -->
           <div v-if="!pillar.isUnknown && pillar.branch && !['Fire', 'Water', 'Metal', 'Wood', 'Earth'].includes(pillar.branch.animal)" class="text-xs text-gray-800">{{ pillar.branch.animal }}</div>
          </div>
          
          <!-- Combination Badges (bottom-right corner, above hidden stems) -->
          <div v-if="pillar.branchCombinations && pillar.branchCombinations.length > 0" 
             class="absolute bottom-11 right-1 gap-0.5 z-20 flex items-start content-start"
             :class="pillar.branchCombinations.length >= 3 ? 'flex-wrap-reverse flex-row justify-end' : 'flex-row items-end'"
             :style="pillar.branchCombinations.length >= 3 ? 'max-width: 40px;' : ''">
           <div v-for="(comb, idx) in pillar.branchCombinations" 
              :key="`branch-comb-${index}-${idx}`"
              class="flex items-center justify-center font-bold rounded-full transition-transform cursor-help"
              :class="[
               getCombinationBadgeSizeClass(comb.strength),
               isBadgeHighlighted(comb) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getCombinationBadgeStyle(comb)"
              :title="getCombinationTooltip(comb)"
              @mouseenter="handleBadgeHover(comb)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getTransformBadgeDisplay(comb.badge) }}</span>
           </div>
          </div>
          
          <!-- Hidden Heavenly Stems - Anchored to bottom -->
          <div v-if="pillar.hiddenStems || pillar.hiddenQi" class="absolute bottom-0 left-0 right-0 flex overflow-hidden h-10">
           <div 
            v-for="(qiData, stem) in getHiddenStemsWithWeights(pillar)" 
            :key="stem"
            class="flex flex-col items-center justify-start text-black overflow-hidden pt-1 pb-0.5 h-full"
            :style="{
             ...getNodeBgColor(getStemElement(stem), qiData.color),
             width: `${qiData.weight}%`
            }"
            :title="`${stem}: ${qiData.god ? qiData.god + ' - ' : ''}Score: ${qiData.score || 'N/A'} (${qiData.weight}%)`"
           >
            <!-- Vertical layout: pinyin, char, ten god -->
            <div class="text-[8px] text-gray-600 leading-tight">{{ stem }}</div>
            <div class="text-[10px] text-black leading-tight">{{ stemMappings[stem] || stem }}</div>
            <div class="text-[8px] text-gray-800 font-medium leading-tight">{{ qiData.god || '' }}</div>
           </div>
          </div>
          
          
          <!-- Horizontal WuXing Flow to Next Branch (only in post/transformed view) -->
          <div v-if="viewMode !== 'base' && !pillar.isUnknown && pillar.branch && natalAndLuckPillars[index + 1]?.branch && index < natalAndLuckPillars.length - 1 && !natalAndLuckPillars[index + 1].isUnknown && getWuXingRelation(pillar.branch.element, natalAndLuckPillars[index + 1].branch.element)"
             class="absolute -right-3 top-1/3 -translate-y-1/2 text-lg font-bold z-50"
             :class="getWuXingRelationClass(pillar.branch.element, natalAndLuckPillars[index + 1].branch.element)"
             :title="`${pillar.branch.element} to ${natalAndLuckPillars[index + 1].branch.element}`">
           {{ getWuXingRelation(pillar.branch.element, natalAndLuckPillars[index + 1].branch.element) }}
          </div>
         </div>
        </div>
        
         <!-- Right Partition: After 10-year luck pillar -->
         <div v-if="index === 4 && natalAndLuckPillars.length > 4" 
            class="relative flex-shrink-0 mx-3 self-stretch"
            style="width: 2px;">
          <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
         </div>
        </template>
       </div>
       
      </div>
      
      <!-- Talisman Input Section (Á¨¶) - Input controls as header -->
      <div v-if="showTalismans" class="relative overflow-x-auto max-w-lg mt-6 mb-4">
       <div class="flex items-center gap-2 mb-3">
        <span class="text-sm font-semibold text-teal-700">Á¨¶ Talisman Configuration</span>
        <span v-if="hasInvalidTalismanPairs" class="text-xs text-red-600 font-semibold">‚ö† Invalid Jia-Zi pairs detected</span>
       </div>
       
       <div class="flex gap-1">
        <!-- Talisman Hour -->
        <div class="w-28 flex-shrink-0">
         <div class="flex items-center justify-center gap-1 mb-1">
          <span class="text-[10px] font-semibold text-center text-teal-700">Á¨¶ÊôÇ<br/>Hour</span>
          <span v-if="!isValidJiaziPair(talismanHourHS, talismanHourEB)" class="text-red-600 text-xs" title="Invalid Jia-Zi pair">‚ö†Ô∏è</span>
         </div>
         <div class="flex flex-col gap-1">
          <select 
           v-model="talismanHourHS" 
           class="w-full px-1 py-1.5 text-[9px] rounded border-2 transition-all"
           :class="isValidJiaziPair(talismanHourHS, talismanHourEB) ? 'bg-teal-50 border-teal-400 text-teal-800' : 'bg-red-50 border-red-400 text-red-800'"
           @change="handleInputChange"
          >
           <option :value="null">-- HS --</option>
           <option v-for="stem in HEAVENLY_STEMS_LIST" :key="stem.id" :value="stem.id">{{ stem.display }}</option>
          </select>
          <select 
           v-model="talismanHourEB" 
           class="w-full px-1 py-1.5 text-[9px] rounded border-2 transition-all"
           :class="isValidJiaziPair(talismanHourHS, talismanHourEB) ? 'bg-teal-50 border-teal-400 text-teal-800' : 'bg-red-50 border-red-400 text-red-800'"
           @change="handleInputChange"
          >
           <option :value="null">-- EB --</option>
           <option v-for="branch in EARTHLY_BRANCHES_LIST" :key="branch.id" :value="branch.id">{{ branch.display }}</option>
          </select>
         </div>
        </div>
        
        <!-- Talisman Day -->
        <div class="w-28 flex-shrink-0">
         <div class="flex items-center justify-center gap-1 mb-1">
          <span class="text-[10px] font-semibold text-center text-teal-700">Á¨¶Êó•<br/>Day</span>
          <span v-if="!isValidJiaziPair(talismanDayHS, talismanDayEB)" class="text-red-600 text-xs" title="Invalid Jia-Zi pair">‚ö†Ô∏è</span>
         </div>
         <div class="flex flex-col gap-1">
          <select 
           v-model="talismanDayHS" 
           class="w-full px-1 py-1.5 text-[9px] rounded border-2 transition-all"
           :class="isValidJiaziPair(talismanDayHS, talismanDayEB) ? 'bg-teal-50 border-teal-400 text-teal-800' : 'bg-red-50 border-red-400 text-red-800'"
           @change="handleInputChange"
          >
           <option :value="null">-- HS --</option>
           <option v-for="stem in HEAVENLY_STEMS_LIST" :key="stem.id" :value="stem.id">{{ stem.display }}</option>
          </select>
          <select 
           v-model="talismanDayEB" 
           class="w-full px-1 py-1.5 text-[9px] rounded border-2 transition-all"
           :class="isValidJiaziPair(talismanDayHS, talismanDayEB) ? 'bg-teal-50 border-teal-400 text-teal-800' : 'bg-red-50 border-red-400 text-red-800'"
           @change="handleInputChange"
          >
           <option :value="null">-- EB --</option>
           <option v-for="branch in EARTHLY_BRANCHES_LIST" :key="branch.id" :value="branch.id">{{ branch.display }}</option>
          </select>
         </div>
        </div>
        
        <!-- Talisman Month -->
        <div class="w-28 flex-shrink-0">
         <div class="flex items-center justify-center gap-1 mb-1">
          <span class="text-[10px] font-semibold text-center text-teal-700">Á¨¶Êúà<br/>Month</span>
          <span v-if="!isValidJiaziPair(talismanMonthHS, talismanMonthEB)" class="text-red-600 text-xs" title="Invalid Jia-Zi pair">‚ö†Ô∏è</span>
         </div>
         <div class="flex flex-col gap-1">
          <select 
           v-model="talismanMonthHS" 
           class="w-full px-1 py-1.5 text-[9px] rounded border-2 transition-all"
           :class="isValidJiaziPair(talismanMonthHS, talismanMonthEB) ? 'bg-teal-50 border-teal-400 text-teal-800' : 'bg-red-50 border-red-400 text-red-800'"
           @change="handleInputChange"
          >
           <option :value="null">-- HS --</option>
           <option v-for="stem in HEAVENLY_STEMS_LIST" :key="stem.id" :value="stem.id">{{ stem.display }}</option>
          </select>
          <select 
           v-model="talismanMonthEB" 
           class="w-full px-1 py-1.5 text-[9px] rounded border-2 transition-all"
           :class="isValidJiaziPair(talismanMonthHS, talismanMonthEB) ? 'bg-teal-50 border-teal-400 text-teal-800' : 'bg-red-50 border-red-400 text-red-800'"
           @change="handleInputChange"
          >
           <option :value="null">-- EB --</option>
           <option v-for="branch in EARTHLY_BRANCHES_LIST" :key="branch.id" :value="branch.id">{{ branch.display }}</option>
          </select>
         </div>
        </div>
        
        <!-- Talisman Year -->
        <div class="w-28 flex-shrink-0">
         <div class="flex items-center justify-center gap-1 mb-1">
          <span class="text-[10px] font-semibold text-center text-teal-700">Á¨¶Âπ¥<br/>Year</span>
          <span v-if="!isValidJiaziPair(talismanYearHS, talismanYearEB)" class="text-red-600 text-xs" title="Invalid Jia-Zi pair">‚ö†Ô∏è</span>
         </div>
         <div class="flex flex-col gap-1">
          <select 
           v-model="talismanYearHS" 
           class="w-full px-1 py-1.5 text-[9px] rounded border-2 transition-all"
           :class="isValidJiaziPair(talismanYearHS, talismanYearEB) ? 'bg-teal-50 border-teal-400 text-teal-800' : 'bg-red-50 border-red-400 text-red-800'"
           @change="handleInputChange"
          >
           <option :value="null">-- HS --</option>
           <option v-for="stem in HEAVENLY_STEMS_LIST" :key="stem.id" :value="stem.id">{{ stem.display }}</option>
          </select>
          <select 
           v-model="talismanYearEB" 
           class="w-full px-1 py-1.5 text-[9px] rounded border-2 transition-all"
           :class="isValidJiaziPair(talismanYearHS, talismanYearEB) ? 'bg-teal-50 border-teal-400 text-teal-800' : 'bg-red-50 border-red-400 text-red-800'"
           @change="handleInputChange"
          >
           <option :value="null">-- EB --</option>
           <option v-for="branch in EARTHLY_BRANCHES_LIST" :key="branch.id" :value="branch.id">{{ branch.display }}</option>
          </select>
         </div>
        </div>
       </div>
      </div>
      
      <!-- Talisman Pillars Display (Á¨¶) - Chart display below input controls -->
      <div v-if="showTalismans && talismanPillarsDisplay.some(p => p !== null)" class="relative overflow-x-auto max-w-lg">
       <div class="mb-2">
        <span class="text-sm font-semibold text-teal-700">Á¨¶ Talisman Pillars</span>
       </div>
       
       <!-- Talisman Stems Row -->
       <div class="flex gap-1 items-center">
        <template v-for="(pillar, index) in talismanPillarsDisplay" :key="`talisman-stem-${index}`">
         <!-- Empty slot if no talisman for this position -->
         <div v-if="!pillar" class="w-28 flex-shrink-0"></div>
         
         <!-- Talisman Stem Cell -->
         <div v-else class="relative w-28 flex-shrink-0">
          <div 
           :id="`talisman-stem-${index}`"
           class="aspect-square p-3 transition-all duration-300 relative flex flex-col items-center justify-center border-2 border-teal-500"
           :class="[
            hoveredNode === `talisman-stem-${index}` ? 'shadow-lg scale-105' : '',
            getNodeHighlightClass(`talisman-stem-${index}`),
            highlightedNodes.includes(`talisman-stem-${index}`) ? 'z-50' : '',
            pillar.isUnknown ? 'bg-gray-100 border-dashed opacity-60' : ''
           ]"
           :style="pillar.isUnknown ? {} : (pillar.stem ? getNodeBgColor(pillar.stem.element, pillar.stem.color) : {})"
          >
           <!-- Negative Badges (top-left) -->
           <div v-if="pillar.stemNegatives && pillar.stemNegatives.length > 0" 
              class="absolute top-1 left-1 gap-0.5 z-20"
              :class="pillar.stemNegatives.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-start'">
            <div v-for="(neg, idx) in pillar.stemNegatives" 
               :key="`talisman-stem-neg-${index}-${idx}`"
               class="flex items-center justify-center font-bold transition-transform cursor-help"
               :class="[
                getNegativeBadgeSizeClass(neg.strength),
                isBadgeHighlighted(neg) ? 'scale-125 shadow-lg' : 'hover:scale-110'
               ]"
               :style="getNegativeBadgeStyle(neg)"
               :title="getNegativeBadgeTooltip(neg)"
               @mouseenter="handleBadgeHover(neg)"
               @mouseleave="clearHighlight()">
             <span class="leading-none">{{ getNegativeBadgeSymbol(neg) }}</span>
            </div>
           </div>
           
           <!-- Transformation Badges (top-right) -->
           <div v-if="pillar.stemTransformations && pillar.stemTransformations.length > 0" 
              class="absolute top-1 right-1 gap-0.5"
              :class="pillar.stemTransformations.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-end'">
            <div v-for="(trans, idx) in pillar.stemTransformations" 
               :key="`talisman-stem-trans-${index}-${idx}`"
               class="flex items-center justify-center font-bold rounded-full shadow-md transition-transform cursor-help"
               :class="[
                getTransformationSizeClass(trans.strength),
                isBadgeHighlighted(trans) ? 'scale-125 shadow-lg' : 'hover:scale-110'
               ]"
               :style="getTransformationBadgeStyles(trans)"
               :title="getTransformationTooltip(trans)"
               @mouseenter="handleBadgeHover(trans)"
               @mouseleave="clearHighlight()">
             <span class="leading-none">{{ getTransformBadgeDisplay(trans.badge) }}</span>
            </div>
           </div>
           
           <!-- Pinyin name -->
           <div v-if="!pillar.isUnknown && pillar.stemName" class="text-xs text-gray-700 mb-1">{{ pillar.stemName }}</div>
           <!-- Chinese character -->
           <div v-if="pillar.stem" class="text-2xl font-bold text-black">{{ pillar.stem.chinese }}</div>
           <div v-else class="text-xl text-gray-400">-</div>
           <!-- Element type -->
           <div v-if="!pillar.isUnknown && pillar.stem" class="text-xs text-gray-700">
            {{ pillar.stem.element.replace('Yang ', '').replace('Yin ', '') }} {{ pillar.stem.element.includes('Yang') ? '+' : '-' }}
           </div>
           <!-- Ten God -->
           <div v-if="!pillar.isUnknown" class="text-xs mt-1 text-gray-900">{{ pillar.tenGod || '' }}</div>
           
           <!-- Combination Badges (bottom-right) -->
           <div v-if="pillar.stemCombinations && pillar.stemCombinations.length > 0" 
              class="absolute bottom-1 right-1 gap-0.5 flex items-start content-start"
              :class="pillar.stemCombinations.length >= 3 ? 'flex-wrap-reverse flex-row justify-end' : 'flex-row items-end'"
              :style="pillar.stemCombinations.length >= 3 ? 'max-width: 40px;' : ''">
            <div v-for="(comb, idx) in pillar.stemCombinations" 
               :key="`talisman-stem-comb-${index}-${idx}`"
               class="flex items-center justify-center font-bold rounded-full transition-transform cursor-help"
               :class="[
                getCombinationBadgeSizeClass(comb.strength),
                isBadgeHighlighted(comb) ? 'scale-125 shadow-lg' : 'hover:scale-110'
               ]"
               :style="getCombinationBadgeStyle(comb)"
               :title="getCombinationTooltip(comb)"
               @mouseenter="handleBadgeHover(comb)"
               @mouseleave="clearHighlight()">
             <span class="leading-none">{{ getTransformBadgeDisplay(comb.badge) }}</span>
            </div>
           </div>
          </div>
         </div>
        </template>
       </div>
       
       <!-- Vertical Flow Indicators (Stem to Branch) -->
       <div class="flex gap-1 -mt-1.5 -mb-1.5 relative z-40 items-center">
        <template v-for="(pillar, index) in talismanPillarsDisplay" :key="`talisman-flow-${index}`">
         <div class="flex justify-center items-center h-5 w-28 flex-shrink-0">
          <div v-if="pillar && viewMode !== 'base' && !pillar.isUnknown && pillar.stem && pillar.branch && getVerticalWuXingRelation(pillar.stem.element, pillar.branch.element)"
             class="text-lg font-bold"
             :class="getVerticalWuXingClass(pillar.stem.element, pillar.branch.element)"
             :title="`${pillar.stem.element} to ${pillar.branch.element}`">
           {{ getVerticalWuXingRelation(pillar.stem.element, pillar.branch.element) }}
          </div>
         </div>
        </template>
       </div>
       
       <!-- Talisman Branches Row -->
       <div class="flex gap-1 overflow-visible items-stretch">
        <template v-for="(pillar, index) in talismanPillarsDisplay" :key="`talisman-branch-${index}`">
         <!-- Empty slot if no talisman -->
         <div v-if="!pillar" class="w-28 flex-shrink-0"></div>
         
         <!-- Talisman Branch Cell -->
         <div v-else class="relative w-28 flex-shrink-0">
          <div 
           :id="`talisman-branch-${index}`"
           class="pb-0 pt-2 px-3 transition-all duration-300 relative flex flex-col items-center justify-start border-2 border-teal-500"
           :class="[
            hoveredNode === `talisman-branch-${index}` ? 'shadow-lg scale-105' : '',
            getNodeHighlightClass(`talisman-branch-${index}`),
            highlightedNodes.includes(`talisman-branch-${index}`) ? 'z-50' : '',
            pillar.isUnknown ? 'bg-gray-100 border-dashed opacity-60' : ''
           ]"
           :style="pillar.isUnknown ? { aspectRatio: '1/1.2' } : {
            ...(pillar.branch ? getNodeBgColor(pillar.branch.element, pillar.branch.color) : {}),
            aspectRatio: '1/1.2'
           }"
          >
           <!-- Negative Badges (top-left) -->
           <div v-if="pillar.branchNegatives && pillar.branchNegatives.length > 0" 
              class="absolute top-1 left-1 gap-0.5 z-20"
              :class="pillar.branchNegatives.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-start'">
            <div v-for="(neg, idx) in pillar.branchNegatives" 
               :key="`talisman-branch-neg-${index}-${idx}`"
               class="flex items-center justify-center font-bold transition-transform cursor-help"
               :class="[
                getNegativeBadgeSizeClass(neg.strength),
                isBadgeHighlighted(neg) ? 'scale-125 shadow-lg' : 'hover:scale-110'
               ]"
               :style="getNegativeBadgeStyle(neg)"
               :title="getNegativeBadgeTooltip(neg)"
               @mouseenter="handleBadgeHover(neg)"
               @mouseleave="clearHighlight()">
             <span class="leading-none">{{ getNegativeBadgeSymbol(neg) }}</span>
            </div>
           </div>
           
           <!-- Transformation Badges (top-right) -->
           <div v-if="pillar.branchTransformations && pillar.branchTransformations.length > 0" 
              class="absolute top-1 right-1 gap-0.5 z-10"
              :class="pillar.branchTransformations.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-end'">
            <div v-for="(trans, idx) in pillar.branchTransformations" 
               :key="`talisman-branch-trans-${index}-${idx}`"
               class="flex items-center justify-center font-bold rounded-full shadow-md transition-transform cursor-help"
               :class="[
                getTransformationSizeClass(trans.strength),
                isBadgeHighlighted(trans) ? 'scale-125 shadow-lg' : 'hover:scale-110'
               ]"
               :style="getTransformationBadgeStyles(trans)"
               :title="getTransformationTooltip(trans)"
               @mouseenter="handleBadgeHover(trans)"
               @mouseleave="clearHighlight()">
             <span class="leading-none">{{ getTransformBadgeDisplay(trans.badge) }}</span>
            </div>
           </div>
           
           <!-- Main content -->
           <div class="flex-1 flex flex-col items-center justify-center pb-10">
            <!-- Branch pinyin name -->
            <div v-if="!pillar.isUnknown && pillar.branchName" class="text-xs text-gray-700 mb-1">{{ pillar.branchName }}</div>
            <!-- Chinese character -->
            <div v-if="pillar.branch" class="text-2xl font-bold text-black">{{ pillar.branch.chinese }}</div>
            <div v-else class="text-xl text-gray-400">-</div>
            <!-- Animal name -->
            <div v-if="!pillar.isUnknown && pillar.branch && !['Fire', 'Water', 'Metal', 'Wood', 'Earth'].includes(pillar.branch.animal)" class="text-xs text-gray-800">{{ pillar.branch.animal }}</div>
           </div>
           
           <!-- Combination Badges (bottom-right, above hidden stems) -->
           <div v-if="pillar.branchCombinations && pillar.branchCombinations.length > 0" 
              class="absolute bottom-11 right-1 gap-0.5 z-20 flex items-start content-start"
              :class="pillar.branchCombinations.length >= 3 ? 'flex-wrap-reverse flex-row justify-end' : 'flex-row items-end'"
              :style="pillar.branchCombinations.length >= 3 ? 'max-width: 40px;' : ''">
            <div v-for="(comb, idx) in pillar.branchCombinations" 
               :key="`talisman-branch-comb-${index}-${idx}`"
               class="flex items-center justify-center font-bold rounded-full transition-transform cursor-help"
               :class="[
                getCombinationBadgeSizeClass(comb.strength),
                isBadgeHighlighted(comb) ? 'scale-125 shadow-lg' : 'hover:scale-110'
               ]"
               :style="getCombinationBadgeStyle(comb)"
               :title="getCombinationTooltip(comb)"
               @mouseenter="handleBadgeHover(comb)"
               @mouseleave="clearHighlight()">
             <span class="leading-none">{{ getTransformBadgeDisplay(comb.badge) }}</span>
            </div>
           </div>
           
           <!-- Hidden Heavenly Stems -->
           <div v-if="pillar.hiddenStems || pillar.hiddenQi" class="absolute bottom-0 left-0 right-0 flex overflow-hidden h-10">
            <div 
             v-for="(qiData, stem) in getHiddenStemsWithWeights(pillar)" 
             :key="stem"
             class="flex flex-col items-center justify-start text-black overflow-hidden pt-1 pb-0.5 h-full"
             :style="{
              ...getNodeBgColor(getStemElement(stem), qiData.color),
              width: `${qiData.weight}%`
             }"
             :title="`${stem}: ${qiData.god ? qiData.god + ' - ' : ''}Score: ${qiData.score || 'N/A'} (${qiData.weight}%)`"
            >
             <div class="text-[8px] text-gray-600 leading-tight">{{ stem }}</div>
             <div class="text-[10px] text-black leading-tight">{{ stemMappings[stem] || stem }}</div>
             <div class="text-[8px] text-gray-800 font-medium leading-tight">{{ qiData.god || '' }}</div>
            </div>
           </div>
          </div>
         </div>
        </template>
       </div>
      </div>
     </div>
     
      <!-- Location Pillars Display (Âú∞) - Display location nodes WITHOUT badges -->
      <div v-if="showLocation && locationPillarsOrdered.length > 0" class="relative overflow-x-auto max-w-full mt-6 mb-4">
       <div class="mb-2">
        <span class="text-sm font-semibold" :class="locationType === 'overseas' ? 'text-blue-700' : 'text-amber-700'">
         Âú∞ Location: {{ locationType === 'overseas' ? 'Êµ∑Â§ñ Overseas' : 'ÈÑâÂúü Birthplace' }}
        </span>
       </div>
       
       <!-- Location Stems Row -->
       <div class="flex gap-1 items-center">
        <template v-for="(pillar, index) in locationPillarsOrdered" :key="`location-stem-${index}`">
         <div class="relative w-28 flex-shrink-0">
          <div 
           :id="`location-stem-${index}`"
           class="aspect-square p-3 transition-all duration-300 relative flex flex-col items-center justify-center border-2"
           :class="[
            hoveredNode === `location-stem-${index}` ? 'shadow-lg scale-105' : 'border-gray-300',
            pillar.locationBorderColor,
            getNodeHighlightClass(`location-stem-${index}`),
            highlightedNodes.includes(`location-stem-${index}`) ? 'z-50' : ''
           ]"
           :style="pillar.stem ? getNodeBgColor(pillar.stem.element, pillar.stem.color) : {}"
          >
           <!-- NO BADGES - just content -->
           <!-- Pinyin name -->
           <div v-if="pillar.stemName" class="text-xs text-gray-700 mb-1">{{ pillar.stemName }}</div>
           <!-- Chinese character -->
           <div v-if="pillar.stem" class="text-2xl font-bold text-black">{{ pillar.stem.chinese }}</div>
           <div v-else class="text-xl text-gray-400">-</div>
           <!-- Element type -->
           <div v-if="pillar.stem" class="text-xs text-gray-700">
            {{ pillar.stem.element.replace('Yang ', '').replace('Yin ', '') }} {{ pillar.stem.element.includes('Yang') ? '+' : '-' }}
           </div>
           <!-- Ten God -->
           <div class="text-xs mt-1 text-gray-900">{{ pillar.tenGod || '' }}</div>
          </div>
         </div>
        </template>
       </div>
       
       <!-- Vertical Flow Indicators (Stem to Branch) -->
       <div class="flex gap-1 -mt-1.5 -mb-1.5 relative z-40 items-center">
        <template v-for="(pillar, index) in locationPillarsOrdered" :key="`location-flow-${index}`">
         <div class="flex justify-center items-center h-5 w-28 flex-shrink-0">
          <div v-if="viewMode !== 'base' && pillar.stem && pillar.branch && getVerticalWuXingRelation(pillar.stem.element, pillar.branch.element)"
             class="text-lg font-bold"
             :class="getVerticalWuXingClass(pillar.stem.element, pillar.branch.element)"
             :title="`${pillar.stem.element} to ${pillar.branch.element}`">
           {{ getVerticalWuXingRelation(pillar.stem.element, pillar.branch.element) }}
          </div>
         </div>
        </template>
       </div>
       
       <!-- Location Branches Row -->
       <div class="flex gap-1 overflow-visible items-stretch">
        <template v-for="(pillar, index) in locationPillarsOrdered" :key="`location-branch-${index}`">
         <div class="relative w-28 flex-shrink-0">
          <div 
           :id="`location-branch-${index}`"
           class="pb-0 pt-2 px-3 transition-all duration-300 relative flex flex-col items-center justify-start border-2"
           :class="[
            hoveredNode === `location-branch-${index}` ? 'shadow-lg scale-105' : 'border-gray-300',
            pillar.locationBorderColor,
            getNodeHighlightClass(`location-branch-${index}`),
            highlightedNodes.includes(`location-branch-${index}`) ? 'z-50' : ''
           ]"
           :style="{
            ...(pillar.branch ? getNodeBgColor(pillar.branch.element, pillar.branch.color) : {}),
            aspectRatio: '1/1.2'
           }"
          >
           <!-- NO BADGES - just content -->
           <!-- Main content -->
           <div class="flex-1 flex flex-col items-center justify-center pb-10">
            <!-- Branch pinyin name -->
            <div v-if="pillar.branchName" class="text-xs text-gray-700 mb-1">{{ pillar.branchName }}</div>
            <!-- Chinese character -->
            <div v-if="pillar.branch" class="text-2xl font-bold text-black">{{ pillar.branch.chinese }}</div>
            <div v-else class="text-xl text-gray-400">-</div>
            <!-- Animal name -->
            <div v-if="pillar.branch && !['Fire', 'Water', 'Metal', 'Wood', 'Earth'].includes(pillar.branch.animal)" class="text-xs text-gray-800">{{ pillar.branch.animal }}</div>
           </div>
           
           <!-- Hidden Stems Section (at bottom) -->
           <div class="absolute bottom-0 left-0 right-0 bg-white/80 border-t border-gray-300 p-1">
            <div class="flex flex-wrap justify-center items-center gap-0.5 min-h-[24px]">
             <div v-for="(god, stem) in pillar.hiddenStems" 
                :key="`location-hidden-${index}-${stem}`"
                class="relative flex items-center justify-center text-[9px] px-1 py-0.5 rounded"
                :style="{
                 backgroundColor: stemMappings[stem] ? getElementColorHex(stemMappings[stem]) + '20' : '#F3F4F6',
                 border: `1px solid ${stemMappings[stem] ? getElementColorHex(stemMappings[stem]) + '60' : '#D1D5DB'}`
                }"
                :title="`${stem}: ${god || 'Unknown'} - ${pillar.hiddenQi ? pillar.hiddenQi[stem] || 'N/A' : 'N/A'}`"
             >
              <div class="text-black font-medium">{{ stemMappings[stem] || stem }}</div>
              <div v-if="god" class="ml-0.5 text-gray-600">{{ god }}</div>
             </div>
            </div>
           </div>
          </div>
         </div>
        </template>
       </div>
      </div>
       
      <!-- Interaction Tooltip -->
     
     <!-- Element Scores Comparison (Wu Xing) -->
     <div v-if="chartData?.daymaster_analysis" class="mt-2 p-2 bg-white shadow-sm border border-gray-200 max-w-2xl">
      <div class="flex items-center justify-between mb-1.5">
       <h3 class="text-xs font-semibold text-gray-800">‰∫îË°å Wu Xing Elements</h3>
       <!-- View Mode Toggle -->
       <div class="flex items-center gap-2">
        <span class="text-xs text-gray-600">View:</span>
        <div class="flex bg-gray-100 p-0.5">
         <button
          @click="viewMode = 'base'"
          :class="[
           'px-2 py-0.5 text-xs transition-all',
           viewMode === 'base' 
            ? 'bg-white text-gray-900 shadow-sm' 
            : 'text-gray-600 hover:text-gray-900'
          ]"
         >
          Base
         </button>
         <button
          @click="viewMode = 'post'"
          :class="[
           'px-2 py-0.5 text-xs transition-all',
           viewMode === 'post' 
            ? 'bg-white text-gray-900 shadow-sm' 
            : 'text-gray-600 hover:text-gray-900'
          ]"
         >
          Post Interaction
         </button>
        </div>
       </div>
      </div>
      <div class="flex items-center justify-between text-[9px] text-gray-500 mb-1">
       <div>
        <span v-if="viewMode === 'base'" class="text-blue-700 font-medium">Base: 8 natal nodes, no interactions</span>
        <span v-else class="text-indigo-700 font-medium">Post: All nodes (natal + luck + talisman + location) with interactions</span>
       </div>
       <div>Total: {{ Math.round(viewMode === 'base' ? naiveTotal : finalTotal) }}%</div>
      </div>
      <div class="space-y-1">
       <div v-for="element in fiveElementsWithRelations" :key="element.name">
        <div class="flex justify-between items-center text-[10px] mb-0.5">
         <div class="flex items-center gap-1">
          <span :class="getElementColor(element.name)" class="font-medium">{{ element.name }}</span>
          <span v-if="element.relationship" class="text-[8px] px-0.5 py-0 bg-gray-100 text-gray-600">{{ element.relationship }}</span>
          <span v-if="viewMode === 'post' && element.change > 0" class="text-[8px] px-0.5 py-0 bg-green-50 text-green-600 opacity-80">‚Üë</span>
          <span v-else-if="viewMode === 'post' && element.change < 0" class="text-[8px] px-0.5 py-0 bg-red-50 text-red-600 opacity-80">‚Üì</span>
         </div>
         <span class="text-gray-600 text-[9px]">
          <template v-if="viewMode === 'base'">{{ Math.round(element.naiveRaw) }}pts ({{ Math.round(element.naive) }}%)</template>
          <template v-else>{{ Math.round(element.naiveRaw) }}‚Üí{{ Math.round(element.finalRaw) }}pts ({{ Math.round(element.naive) }}‚Üí{{ Math.round(element.final) }}%<span :class="element.change > 0 ? 'text-green-600 font-medium' : element.change < 0 ? 'text-red-600 font-medium' : 'text-gray-400'">{{ element.change > 0 ? '+' : '' }}{{ Math.round(element.change) }}%</span>)</template>
         </span>
        </div>
        <div class="relative h-4 bg-gray-100 overflow-hidden">
         <div class="absolute inset-0 flex"><div class="w-1/5 border-r border-gray-200"></div><div class="w-1/5 border-r border-gray-200"></div><div class="w-1/5 border-r border-gray-200"></div><div class="w-1/5 border-r border-gray-200"></div><div class="w-1/5"></div></div>
         <template v-if="viewMode === 'base'">
          <div class="absolute top-0 left-0 h-full transition-all duration-500" :class="getElementBgColor(element.name)" :style="`width: ${Math.min((element.naive / maxElementScore) * 100, 100)}%`"></div>
          <div class="absolute top-0 h-full flex items-center transition-all duration-500" :style="`left: ${Math.min((element.naive / maxElementScore) * 100, 100)}%`"><span class="ml-1 text-[8px] font-medium text-gray-700">{{ Math.round((element.naive / maxElementScore) * 100) }}%</span></div>
         </template>
         <template v-else>
          <template v-if="element.change > 0">
           <div class="absolute top-0 left-0 h-full rounded-l transition-all duration-500" :class="getElementBgColor(element.name)" :style="`width: ${Math.min((element.naive / maxElementScore) * 100, 100)}%`"></div>
           <div class="absolute top-0 h-full rounded-r transition-all duration-500" :class="getElementBgColor(element.name)" :style="`left: ${Math.min((element.naive / maxElementScore) * 100, 100)}%; width: ${Math.min(((element.final - element.naive) / maxElementScore) * 100, 100 - (element.naive / maxElementScore) * 100)}%; background-image: repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(255,255,255,0.2) 2px, rgba(255,255,255,0.2) 4px);`"></div>
          </template>
          <template v-else>
           <div class="absolute top-0 left-0 h-full transition-all duration-500" :class="[element.change < 0 ? 'border border-dotted' : 'border', getElementBorderColor(element.name)]" :style="`width: ${Math.min((element.naive / maxElementScore) * 100, 100)}%; background-color: transparent;`"></div>
           <div class="absolute top-0 left-0 h-full transition-all duration-700" :class="[getElementBgColor(element.name), element.change < 0 ? 'opacity-80' : '']" :style="`width: ${Math.min((element.final / maxElementScore) * 100, 100)}%`"></div>
          </template>
          <div class="absolute top-0 h-full flex items-center transition-all duration-500" :style="`left: ${Math.min((element.final / maxElementScore) * 100, 100)}%`"><span class="ml-1 text-[8px] font-medium text-gray-700">{{ Math.round((element.final / maxElementScore) * 100) }}%</span></div>
         </template>
        </div>
       </div>
      </div>
     </div>
     
     <!-- Day Master Analysis -->
     <div v-if="chartData?.daymaster_analysis" class="mt-2 p-2 bg-blue-50 max-w-2xl">
      <div class="text-[10px]">
       <span class="font-semibold">Day Master:</span> 
       {{ chartData?.daymaster_analysis?.daymaster }} 
       ({{ chartData?.daymaster_analysis?.daymaster_strength }} - {{ Math.round(chartData?.daymaster_analysis?.daymaster_percentage) }}%)
      </div>
      <div class="text-[10px] mt-1">
       <span class="font-semibold text-green-700">Favorable:</span> 
       {{ chartData?.daymaster_analysis?.favorable_elements?.join(', ') }}
      </div>
      <div class="text-[10px]">
       <span class="font-semibold text-red-700">Unfav:</span> 
       {{ chartData?.daymaster_analysis?.unfavorable_elements?.join(', ') }}
      </div>
     </div>
     
     <!-- Analysis Period Info -->
     <div v-if="chartData?.analysis_info && (chartData.analysis_info.has_luck_pillar || chartData.analysis_info.has_annual || chartData.analysis_info.has_monthly || chartData.analysis_info.has_daily || chartData.analysis_info.has_hourly)" class="mt-2 p-2 bg-gradient-to-r from-indigo-50 to-purple-50 border border-indigo-200 max-w-2xl">
      <div class="text-[10px] font-semibold text-indigo-900 mb-1">üìÖ Analysis Period</div>
      <div class="grid grid-cols-2 gap-1 text-[9px]">
       <div v-if="chartData.analysis_info.year">
        <span class="font-medium text-indigo-700">Year:</span> 
        <span class="text-gray-700">{{ chartData.analysis_info.year }}</span>
       </div>
       <div v-if="chartData.analysis_info.month">
        <span class="font-medium text-indigo-700">Month:</span> 
        <span class="text-gray-700">{{ chartData.analysis_info.month }}</span>
       </div>
       <div v-if="chartData.analysis_info.day">
        <span class="font-medium text-indigo-700">Day:</span> 
        <span class="text-gray-700">{{ chartData.analysis_info.day }}</span>
       </div>
       <div v-if="chartData.analysis_info.time">
        <span class="font-medium text-indigo-700">Time:</span> 
        <span class="text-gray-700">{{ chartData.analysis_info.time }}</span>
       </div>
      </div>
      <div class="mt-1.5 pt-1.5 border-t border-indigo-200 text-[9px] text-indigo-600">
       <div class="flex flex-wrap gap-1">
        <span v-if="chartData.analysis_info.has_luck_pillar" class="px-2 py-0.5 bg-purple-100 text-purple-700 ">10-Year Luck</span>
        <span v-if="chartData.analysis_info.has_annual" class="px-2 py-0.5 " style="background: #FEF3C7; color: #92400E; border: 1px solid #D97706;">Annual ‚úì</span>
        <span v-if="chartData.analysis_info.annual_disabled" class="px-2 py-0.5 bg-gray-100 text-gray-500 opacity-60">Annual (display only)</span>
        <span v-if="chartData.analysis_info.has_monthly" class="px-2 py-0.5 " style="background: #FEF3C7; color: #92400E; border: 1px solid #D97706;">Monthly</span>
        <span v-if="chartData.analysis_info.has_daily" class="px-2 py-0.5 " style="background: #FEF3C7; color: #92400E; border: 1px solid #D97706;">Daily</span>
        <span v-if="chartData.analysis_info.has_hourly" class="px-2 py-0.5 " style="background: #FEF3C7; color: #92400E; border: 1px solid #D97706;">Hourly</span>
       </div>
       <div v-if="chartData.analysis_info.annual_disabled" class="mt-1 text-[8px] text-gray-600 italic">
        üí° Year {{ chartData.analysis_info.year }} determines 10-year luck only. Annual pillar shown but excluded from element balance and interactions.
       </div>
      </div>
     </div>
     
     <!-- Current Luck Pillar Timing Info -->
     <div v-if="currentLuckPillar" class="mt-2 p-2 bg-purple-50 border border-purple-200 max-w-2xl">
      <div class="text-[10px] font-semibold text-purple-900 mb-1">Current 10-Year Luck Pillar</div>
      <div class="text-[9px]">
       <span class="font-medium">Period:</span> 
       {{ currentLuckPillar.timing.start_year }} - {{ currentLuckPillar.timing.end_year }}
      </div>
      <div class="text-[9px]">
       <span class="font-medium">Age Range:</span> 
       {{ Math.floor(currentLuckPillar.timing.start_age) }} - {{ Math.floor(currentLuckPillar.timing.end_age) }} years old
      </div>
      <div class="text-[9px] text-purple-700 mt-1 bg-purple-100 border border-purple-300 p-2 rounded">
       <strong>‚è∞ Temporal Overlay:</strong> The 10-year luck pillar is a <strong>time period</strong> that overlays your entire natal chart.
       It interacts with <strong>all four natal pillars</strong> (Year, Month, Day, Hour) <strong>equally and adjacently</strong>,
       regardless of its visual position in the UI. This reflects authentic BaZi metaphysics where luck periods are temporal influences, not spatial positions.
      </div>
      
      <!-- Luck Pillar Interactions -->
      <div v-if="luckPillarInteractions.length > 0" class="mt-1.5 pt-1.5 border-t border-purple-200">
       <div class="text-[9px] font-semibold text-purple-900 mb-1">Interactions with Natal Chart:</div>
       <div class="space-y-0.5">
        <div v-for="(interaction, idx) in luckPillarInteractions" :key="idx" 
           class="text-[9px] p-1 rounded"
           :class="interaction.effect === 'positive' ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'">
         <span class="font-medium" :class="interaction.effect === 'positive' ? 'text-green-700' : 'text-red-700'">
          {{ interaction.label }}
         </span>
         <span class="text-gray-700 ml-1">{{ interaction.description }}</span>
        </div>
       </div>
      </div>
      <div v-else class="mt-1.5 pt-1.5 border-t border-purple-200 text-[9px] text-gray-600">
       No major interactions (harmonies/clashes) detected with natal chart.
      </div>
     </div>
    </div>
   </div>
    </div>
   </div>
  </main>
 </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue'

// LocalStorage keys
const STORAGE_KEY = 'bazingse_form_data'

// Helper to load from localStorage
function loadFromStorage() {
 if (typeof window === 'undefined') return null
 try {
  const saved = localStorage.getItem(STORAGE_KEY)
  return saved ? JSON.parse(saved) : null
 } catch (e) {
  console.error('Error loading from localStorage:', e)
  return null
 }
}

// Helper to save to localStorage
function saveToStorage() {
 if (typeof window === 'undefined') return
 try {
  const data = {
   birthDate: birthDate.value,
   birthTime: birthTime.value,
   gender: gender.value,
   unknownHour: unknownHour.value,
   yearInput: yearInput.value,
   monthInput: monthInput.value,
   dayInput: dayInput.value,
   analysisYear: analysisYear.value,
   analysisMonth: analysisMonth.value,
   analysisDay: analysisDay.value,
   analysisTime: analysisTime.value,
   showAnalysisPeriod: showAnalysisPeriod.value,
   includeAnnualLuck: includeAnnualLuck.value,
   includeMonthlyLuck: includeMonthlyLuck.value,
   includeDailyLuck: includeDailyLuck.value,
   includeHourlyLuck: includeHourlyLuck.value,
   showTalismans: showTalismans.value,
   talismanYearHS: talismanYearHS.value,
   talismanYearEB: talismanYearEB.value,
   talismanMonthHS: talismanMonthHS.value,
   talismanMonthEB: talismanMonthEB.value,
   talismanDayHS: talismanDayHS.value,
   talismanDayEB: talismanDayEB.value,
   talismanHourHS: talismanHourHS.value,
   talismanHourEB: talismanHourEB.value,
   showLocation: showLocation.value,
   locationType: locationType.value,
   viewMode: viewMode.value
  }
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data))
 } catch (e) {
  console.error('Error saving to localStorage:', e)
 }
}

// Load saved values or use defaults
const savedData = loadFromStorage()

// Quick test presets
const testPresets = [
 { date: '1969-07-04', time: '18:20', gender: 'female' },
 { date: '1992-07-06', time: '09:30', gender: 'female' },
 { date: '1995-04-19', time: '17:30', gender: 'male' },
 { date: '1985-06-23', time: '13:30', gender: 'male' },
 { date: '1988-02-02', time: '13:30', gender: 'male' },
 { date: '1986-11-29', time: '13:30', gender: 'male' },
 { date: '1995-08-14', time: '11:30', gender: 'female' },
 { date: '1995-07-18', time: '16:30', gender: 'female' },
 { date: '1992-09-18', time: '09:30', gender: 'female' }
]

// Heavenly Stems for dropdowns (10 stems)
const HEAVENLY_STEMS_LIST = [
  { id: 'Jia', display: 'Áî≤ Jia (Yang Wood)' },
  { id: 'Yi', display: '‰πô Yi (Yin Wood)' },
  { id: 'Bing', display: '‰∏ô Bing (Yang Fire)' },
  { id: 'Ding', display: '‰∏Å Ding (Yin Fire)' },
  { id: 'Wu', display: 'Êàä Wu (Yang Earth)' },
  { id: 'Ji', display: 'Â∑± Ji (Yin Earth)' },
  { id: 'Geng', display: 'Â∫ö Geng (Yang Metal)' },
  { id: 'Xin', display: 'Ëæõ Xin (Yin Metal)' },
  { id: 'Ren', display: 'Â£¨ Ren (Yang Water)' },
  { id: 'Gui', display: 'Áô∏ Gui (Yin Water)' }
]

// Earthly Branches for dropdowns (12 branches)
const EARTHLY_BRANCHES_LIST = [
  { id: 'Zi', display: 'Â≠ê Zi (Rat)' },
  { id: 'Chou', display: '‰∏ë Chou (Ox)' },
  { id: 'Yin', display: 'ÂØÖ Yin (Tiger)' },
  { id: 'Mao', display: 'ÂçØ Mao (Rabbit)' },
  { id: 'Chen', display: 'Ëæ∞ Chen (Dragon)' },
  { id: 'Si', display: 'Â∑≥ Si (Snake)' },
  { id: 'Wu', display: 'Âçà Wu (Horse)' },
  { id: 'Wei', display: 'Êú™ Wei (Goat)' },
  { id: 'Shen', display: 'Áî≥ Shen (Monkey)' },
  { id: 'You', display: 'ÈÖâ You (Rooster)' },
  { id: 'Xu', display: 'Êàå Xu (Dog)' },
  { id: 'Hai', display: '‰∫• Hai (Pig)' }
]

// 60 Jia-Zi combinations (traditional order) - for validation
const JIAZI_60 = [
  { stem: 'Jia', branch: 'Zi', display: 'Áî≤Â≠ê Jia-Zi' },
  { stem: 'Yi', branch: 'Chou', display: '‰πô‰∏ë Yi-Chou' },
  { stem: 'Bing', branch: 'Yin', display: '‰∏ôÂØÖ Bing-Yin' },
  { stem: 'Ding', branch: 'Mao', display: '‰∏ÅÂçØ Ding-Mao' },
  { stem: 'Wu', branch: 'Chen', display: 'ÊàäËæ∞ Wu-Chen' },
  { stem: 'Ji', branch: 'Si', display: 'Â∑±Â∑≥ Ji-Si' },
  { stem: 'Geng', branch: 'Wu', display: 'Â∫öÂçà Geng-Wu' },
  { stem: 'Xin', branch: 'Wei', display: 'ËæõÊú™ Xin-Wei' },
  { stem: 'Ren', branch: 'Shen', display: 'Â£¨Áî≥ Ren-Shen' },
  { stem: 'Gui', branch: 'You', display: 'Áô∏ÈÖâ Gui-You' },
  { stem: 'Jia', branch: 'Xu', display: 'Áî≤Êàå Jia-Xu' },
  { stem: 'Yi', branch: 'Hai', display: '‰πô‰∫• Yi-Hai' },
  { stem: 'Bing', branch: 'Zi', display: '‰∏ôÂ≠ê Bing-Zi' },
  { stem: 'Ding', branch: 'Chou', display: '‰∏Å‰∏ë Ding-Chou' },
  { stem: 'Wu', branch: 'Yin', display: 'ÊàäÂØÖ Wu-Yin' },
  { stem: 'Ji', branch: 'Mao', display: 'Â∑±ÂçØ Ji-Mao' },
  { stem: 'Geng', branch: 'Chen', display: 'Â∫öËæ∞ Geng-Chen' },
  { stem: 'Xin', branch: 'Si', display: 'ËæõÂ∑≥ Xin-Si' },
  { stem: 'Ren', branch: 'Wu', display: 'Â£¨Âçà Ren-Wu' },
  { stem: 'Gui', branch: 'Wei', display: 'Áô∏Êú™ Gui-Wei' },
  { stem: 'Jia', branch: 'Shen', display: 'Áî≤Áî≥ Jia-Shen' },
  { stem: 'Yi', branch: 'You', display: '‰πôÈÖâ Yi-You' },
  { stem: 'Bing', branch: 'Xu', display: '‰∏ôÊàå Bing-Xu' },
  { stem: 'Ding', branch: 'Hai', display: '‰∏Å‰∫• Ding-Hai' },
  { stem: 'Wu', branch: 'Zi', display: 'ÊàäÂ≠ê Wu-Zi' },
  { stem: 'Ji', branch: 'Chou', display: 'Â∑±‰∏ë Ji-Chou' },
  { stem: 'Geng', branch: 'Yin', display: 'Â∫öÂØÖ Geng-Yin' },
  { stem: 'Xin', branch: 'Mao', display: 'ËæõÂçØ Xin-Mao' },
  { stem: 'Ren', branch: 'Chen', display: 'Â£¨Ëæ∞ Ren-Chen' },
  { stem: 'Gui', branch: 'Si', display: 'Áô∏Â∑≥ Gui-Si' },
  { stem: 'Jia', branch: 'Wu', display: 'Áî≤Âçà Jia-Wu' },
  { stem: 'Yi', branch: 'Wei', display: '‰πôÊú™ Yi-Wei' },
  { stem: 'Bing', branch: 'Shen', display: '‰∏ôÁî≥ Bing-Shen' },
  { stem: 'Ding', branch: 'You', display: '‰∏ÅÈÖâ Ding-You' },
  { stem: 'Wu', branch: 'Xu', display: 'ÊàäÊàå Wu-Xu' },
  { stem: 'Ji', branch: 'Hai', display: 'Â∑±‰∫• Ji-Hai' },
  { stem: 'Geng', branch: 'Zi', display: 'Â∫öÂ≠ê Geng-Zi' },
  { stem: 'Xin', branch: 'Chou', display: 'Ëæõ‰∏ë Xin-Chou' },
  { stem: 'Ren', branch: 'Yin', display: 'Â£¨ÂØÖ Ren-Yin' },
  { stem: 'Gui', branch: 'Mao', display: 'Áô∏ÂçØ Gui-Mao' },
  { stem: 'Jia', branch: 'Chen', display: 'Áî≤Ëæ∞ Jia-Chen' },
  { stem: 'Yi', branch: 'Si', display: '‰πôÂ∑≥ Yi-Si' },
  { stem: 'Bing', branch: 'Wu', display: '‰∏ôÂçà Bing-Wu' },
  { stem: 'Ding', branch: 'Wei', display: '‰∏ÅÊú™ Ding-Wei' },
  { stem: 'Wu', branch: 'Shen', display: 'ÊàäÁî≥ Wu-Shen' },
  { stem: 'Ji', branch: 'You', display: 'Â∑±ÈÖâ Ji-You' },
  { stem: 'Geng', branch: 'Xu', display: 'Â∫öÊàå Geng-Xu' },
  { stem: 'Xin', branch: 'Hai', display: 'Ëæõ‰∫• Xin-Hai' },
  { stem: 'Ren', branch: 'Zi', display: 'Â£¨Â≠ê Ren-Zi' },
  { stem: 'Gui', branch: 'Chou', display: 'Áô∏‰∏ë Gui-Chou' },
  { stem: 'Jia', branch: 'Yin', display: 'Áî≤ÂØÖ Jia-Yin' },
  { stem: 'Yi', branch: 'Mao', display: '‰πôÂçØ Yi-Mao' },
  { stem: 'Bing', branch: 'Chen', display: '‰∏ôËæ∞ Bing-Chen' },
  { stem: 'Ding', branch: 'Si', display: '‰∏ÅÂ∑≥ Ding-Si' },
  { stem: 'Wu', branch: 'Wu', display: 'ÊàäÂçà Wu-Wu' },
  { stem: 'Ji', branch: 'Wei', display: 'Â∑±Êú™ Ji-Wei' },
  { stem: 'Geng', branch: 'Shen', display: 'Â∫öÁî≥ Geng-Shen' },
  { stem: 'Xin', branch: 'You', display: 'ËæõÈÖâ Xin-You' },
  { stem: 'Ren', branch: 'Xu', display: 'Â£¨Êàå Ren-Xu' },
  { stem: 'Gui', branch: 'Hai', display: 'Áô∏‰∫• Gui-Hai' }
]

// Validation: Check if HS+EB combination is valid Jia-Zi pair
function isValidJiaziPair(hs, eb) {
  // If either is null, it's valid (partial selection allowed)
  if (!hs || !eb) return true
  
  // Check if the combination exists in JIAZI_60
  return JIAZI_60.some(pair => pair.stem === hs && pair.branch === eb)
}

// Computed: Check if any talisman pair is invalid
const hasInvalidTalismanPairs = computed(() => {
  return !isValidJiaziPair(talismanYearHS.value, talismanYearEB.value) ||
         !isValidJiaziPair(talismanMonthHS.value, talismanMonthEB.value) ||
         !isValidJiaziPair(talismanDayHS.value, talismanDayEB.value) ||
         !isValidJiaziPair(talismanHourHS.value, talismanHourEB.value)
})

// Form data
const birthDate = ref(savedData?.birthDate || '1992-07-06')
const birthTime = ref(savedData?.birthTime || '09:30')
const gender = ref(savedData?.gender || 'female')
const isLoading = ref(false)
const chartData = ref(null)
const currentLuckPillar = ref(null) // Current 10-year luck pillar
const annualLuckPillar = ref(null) // Current annual luck pillar
const unknownHour = ref(savedData?.unknownHour || false)

// Individual pillar inputs
const yearInput = ref(savedData?.yearInput || 1992)
const monthInput = ref(savedData?.monthInput || 7)
const dayInput = ref(savedData?.dayInput || 6)

// Analysis period controls (for time travel functionality)
const analysisYear = ref(savedData?.analysisYear || null)
const analysisMonth = ref(savedData?.analysisMonth || null)
const analysisDay = ref(savedData?.analysisDay || null)
const analysisTime = ref(savedData?.analysisTime || '')
const showAnalysisPeriod = ref(savedData?.showAnalysisPeriod || false)
const includeAnnualLuck = ref(savedData?.includeAnnualLuck !== undefined ? savedData.includeAnnualLuck : true)
const includeMonthlyLuck = ref(savedData?.includeMonthlyLuck !== undefined ? savedData.includeMonthlyLuck : true)
const includeDailyLuck = ref(savedData?.includeDailyLuck !== undefined ? savedData.includeDailyLuck : true)
const includeHourlyLuck = ref(savedData?.includeHourlyLuck !== undefined ? savedData.includeHourlyLuck : true)

// Talisman selection (Á¨¶) - Separate HS and EB selection
const showTalismans = ref(savedData?.showTalismans || false)
const talismanYearHS = ref(savedData?.talismanYearHS || null)
const talismanYearEB = ref(savedData?.talismanYearEB || null)
const talismanMonthHS = ref(savedData?.talismanMonthHS || null)
const talismanMonthEB = ref(savedData?.talismanMonthEB || null)
const talismanDayHS = ref(savedData?.talismanDayHS || null)
const talismanDayEB = ref(savedData?.talismanDayEB || null)
const talismanHourHS = ref(savedData?.talismanHourHS || null)
const talismanHourEB = ref(savedData?.talismanHourEB || null)

// Location (overseas/birthplace) - Residence status
const showLocation = ref(savedData?.showLocation || false)
const locationType = ref(savedData?.locationType || null) // 'overseas' or 'birthplace'

// Calculate grid columns for luck pillars (backward compatibility)
const luckPillarCount = computed(() => {
 let count = 0
 if (currentLuckPillar.value) count++
 if (annualLuckPillar.value) count++
 return count
})

// Total pillar count (dynamic: 4 natal + analysis pillars)
const totalPillarCount = computed(() => {
 // If no chart data yet, return 4 (natal only)
 if (!chartData.value) return 4
 
 let count = 4 // Base natal pillars (hour, day, month, year)
 
 if (chartData.value?.analysis_info) {
  const info = chartData.value.analysis_info
  if (info.has_luck_pillar) count++ // 10-year luck
  if (info.has_annual) count++    // Annual
  if (info.has_monthly) count++   // Monthly
  if (info.has_daily) count++    // Daily
  if (info.has_hourly) count++    // Hourly
 }
 
 // Add talisman pillars (use ty/tm/td/th node IDs)
 if (chartData.value?.hs_ty || chartData.value?.eb_ty) count++ // Talisman year
 if (chartData.value?.hs_tm || chartData.value?.eb_tm) count++ // Talisman month
 if (chartData.value?.hs_td || chartData.value?.eb_td) count++ // Talisman day
 if (chartData.value?.hs_th || chartData.value?.eb_th) count++ // Talisman hour
 
 // Add location pillars (overseas: o1-o2, birthplace: b1-b4)
 if (chartData.value?.hs_o1 || chartData.value?.eb_o1) count++ // Overseas 1
 if (chartData.value?.hs_o2 || chartData.value?.eb_o2) count++ // Overseas 2
 if (chartData.value?.hs_b1 || chartData.value?.eb_b1) count++ // Birthplace 1
 if (chartData.value?.hs_b2 || chartData.value?.eb_b2) count++ // Birthplace 2
 if (chartData.value?.hs_b3 || chartData.value?.eb_b3) count++ // Birthplace 3
 if (chartData.value?.hs_b4 || chartData.value?.eb_b4) count++ // Birthplace 4
 
 // Ensure count is within valid range (4-19 with talismans and location)
 return Math.max(4, Math.min(19, count))
})

// Update birthDate from individual pillar inputs
function updateDateFromPillars() {
 const year = yearInput.value || new Date().getFullYear()
 const month = String(monthInput.value || 1).padStart(2, '0')
 const day = String(dayInput.value || 1).padStart(2, '0')
 birthDate.value = `${year}-${month}-${day}`
}

// Initialize pillar inputs from birthDate
function initializePillarInputs() {
 if (birthDate.value) {
  const [year, month, day] = birthDate.value.split('-')
  yearInput.value = parseInt(year)
  monthInput.value = parseInt(month)
  dayInput.value = parseInt(day)
 }
}

// Debounce timer
let debounceTimer = null

// Handle input changes with debounce
function handleInputChange() {
 updateDateFromPillars()
 
 // Save to localStorage
 saveToStorage()
 
 // Clear existing timer
 if (debounceTimer) {
  clearTimeout(debounceTimer)
 }
 
 // Set new timer to generate chart after 500ms of no changes
 debounceTimer = setTimeout(() => {
  generateChart()
 }, 500)
}

// Handle unknown hour toggle
function handleUnknownHourChange() {
 if (!unknownHour.value) {
  // Restore to default time when unchecking unknown
  birthTime.value = '12:00'
 }
 handleInputChange()
}

// Load a preset test case
function loadPreset(preset) {
 // Set birth date and time
 birthDate.value = preset.date
 birthTime.value = preset.time
 gender.value = preset.gender
 unknownHour.value = false
 
 // Update individual pillar inputs
 const [year, month, day] = preset.date.split('-')
 yearInput.value = parseInt(year)
 monthInput.value = parseInt(month)
 dayInput.value = parseInt(day)
 
 // Reset time travel mode
 showAnalysisPeriod.value = false
 includeAnnualLuck.value = true
 includeMonthlyLuck.value = false
 includeDailyLuck.value = false
 includeHourlyLuck.value = false
 
 // Clear analysis inputs
 analysisYear.value = null
 analysisMonth.value = null
 analysisDay.value = null
 analysisTime.value = ''
 
 // Save and generate
 saveToStorage()
 generateChart()
}

// Handle analysis mode toggle
function handleAnalysisModeToggle() {
 if (showAnalysisPeriod.value && !analysisYear.value) {
  // Pre-fill with current year for convenience
  analysisYear.value = new Date().getFullYear()
 }
 handleInputChange()
}

// Watch for cascading resets when toggles are disabled
watch(includeAnnualLuck, (newValue) => {
 if (!newValue) {
  // Clear monthly and all dependent values
  analysisMonth.value = null
  analysisDay.value = null
  analysisTime.value = ''
 }
})

watch(includeMonthlyLuck, (newValue) => {
 if (!newValue) {
  // Clear daily and hourly
  analysisDay.value = null
  analysisTime.value = ''
 }
})

watch(includeDailyLuck, (newValue) => {
 if (!newValue) {
  // Clear hourly
  analysisTime.value = ''
 }
})

// Clear analysis period
function clearAnalysisPeriod() {
 analysisYear.value = null
 analysisMonth.value = null
 analysisDay.value = null
 analysisTime.value = ''
 handleInputChange()
}

// Initialize on mount (client-side only)
onMounted(() => {
 console.log('Component mounted, initializing...')
 initializePillarInputs()
 // Generate initial chart after component mounts
 setTimeout(() => {
  console.log('Calling generateChart from onMounted')
  generateChart()
 }, 100)
})

// Interactive UI state
const hoveredNode = ref(null)
const hoveredInteraction = ref(null)
const highlightedNodes = ref([])
const highlightContext = ref(null) // NEW: Stores interaction context for element-based coloring
const hoveredTransformationId = ref(null) // NEW: Track which transformation is hovered
const activeConnections = ref([])
const showConnections = ref(true)
const tooltipContent = ref(null)
const tooltipPosition = ref({ x: 0, y: 0 })

// View mode state: 'base' or 'post' - default to 'post' to show energy flow
// This controls both the interaction view and Wu Xing element graph
// Base = natal chart only (8 nodes, no interactions)
// Post = all nodes with all interactions
const viewMode = ref(savedData?.viewMode || 'post')
const showTransformed = computed(() => viewMode.value === 'post')

// Interactions display state
const highlightedInteraction = ref(null)

// Watch for view mode changes
watch(viewMode, () => {
 // Save view mode preference
 saveToStorage()
})

// Stem and Branch mappings
const stemMappings = {
 'Jia': 'Áî≤', 'Yi': '‰πô', 'Bing': '‰∏ô', 'Ding': '‰∏Å', 'Wu': 'Êàä',
 'Ji': 'Â∑±', 'Geng': 'Â∫ö', 'Xin': 'Ëæõ', 'Ren': 'Â£¨', 'Gui': 'Áô∏'
}

// Ten God abbreviation to full name mappings
const tenGodMappings = {
 'F': 'Companion',
 'RW': 'Robbery',
 'EG': 'Output',
 'HO': 'Hurting',
 'IW': 'Wealth',
 'DW': 'Direct Wealth',
 '7K': 'Officer',
 'DO': 'Direct Officer',
 'IR': 'Resource',
 'DR': 'Direct Resource',
 // Keep full names as is
 'Companion': 'Companion',
 'Robbery': 'Robbery',
 'Output': 'Output',
 'Hurting': 'Hurting',
 'Wealth': 'Wealth',
 'Direct Wealth': 'Direct Wealth',
 'Officer': 'Officer',
 'Direct Officer': 'Direct Officer',
 'Resource': 'Resource',
 'Direct Resource': 'Direct Resource'
}

// Branch name to Chinese character mappings
const branchMappings = {
 'Zi': 'Â≠ê', 'Chou': '‰∏ë', 'Yin': 'ÂØÖ', 'Mao': 'ÂçØ',
 'Chen': 'Ëæ∞', 'Si': 'Â∑≥', 'Wu': 'Âçà', 'Wei': 'Êú™',
 'Shen': 'Áî≥', 'You': 'ÈÖâ', 'Xu': 'Êàå', 'Hai': '‰∫•'
}

// Branch polarity mappings based on BaZi theory
const branchPolarities = {
 'Zi': 'Yang',  // Yang Water
 'Chou': 'Yin', // Yin Earth
 'Yin': 'Yang', // Yang Wood
 'Mao': 'Yin',  // Yin Wood
 'Chen': 'Yang', // Yang Earth
 'Si': 'Yang',  // Yang Fire
 'Wu': 'Yang',  // Yang Fire
 'Wei': 'Yin',  // Yin Earth
 'Shen': 'Yang', // Yang Metal
 'You': 'Yin',  // Yin Metal
 'Xu': 'Yang',  // Yang Earth
 'Hai': 'Yin'  // Yin Water
}

// Element to Chinese character mappings (for transformed display)
const elementCharacterMappings = {
 'Wood': 'Êú®',
 'Fire': 'ÁÅ´',
 'Earth': 'Âúü',
 'Metal': 'Èáë',
 'Water': 'Ê∞¥',
 'Yang Wood': 'Êú®',
 'Yin Wood': 'Êú®',
 'Yang Fire': 'ÁÅ´',
 'Yin Fire': 'ÁÅ´',
 'Yang Earth': 'Âúü',
 'Yin Earth': 'Âúü',
 'Yang Metal': 'Èáë',
 'Yin Metal': 'Èáë',
 'Yang Water': 'Ê∞¥',
 'Yin Water': 'Ê∞¥'
}

const HEAVENLY_STEMS = {
 'Jia': { chinese: 'Áî≤', element: 'Yang Wood' },
 'Yi': { chinese: '‰πô', element: 'Yin Wood' },
 'Bing': { chinese: '‰∏ô', element: 'Yang Fire' },
 'Ding': { chinese: '‰∏Å', element: 'Yin Fire' },
 'Wu': { chinese: 'Êàä', element: 'Yang Earth' },
 'Ji': { chinese: 'Â∑±', element: 'Yin Earth' },
 'Geng': { chinese: 'Â∫ö', element: 'Yang Metal' },
 'Xin': { chinese: 'Ëæõ', element: 'Yin Metal' },
 'Ren': { chinese: 'Â£¨', element: 'Yang Water' },
 'Gui': { chinese: 'Áô∏', element: 'Yin Water' }
}

const EARTHLY_BRANCHES = {
 'Zi': { chinese: 'Â≠ê', animal: 'Rat', element: 'Yang Water' },
 'Chou': { chinese: '‰∏ë', animal: 'Ox', element: 'Yin Earth' },
 'Yin': { chinese: 'ÂØÖ', animal: 'Tiger', element: 'Yang Wood' },
 'Mao': { chinese: 'ÂçØ', animal: 'Rabbit', element: 'Yin Wood' },
 'Chen': { chinese: 'Ëæ∞', animal: 'Dragon', element: 'Yang Earth' },
 'Si': { chinese: 'Â∑≥', animal: 'Snake', element: 'Yin Fire' },
 'Wu': { chinese: 'Âçà', animal: 'Horse', element: 'Yang Fire' },
 'Wei': { chinese: 'Êú™', animal: 'Goat', element: 'Yin Earth' },
 'Shen': { chinese: 'Áî≥', animal: 'Monkey', element: 'Yang Metal' },
 'You': { chinese: 'ÈÖâ', animal: 'Rooster', element: 'Yin Metal' },
 'Xu': { chinese: 'Êàå', animal: 'Dog', element: 'Yang Earth' },
 'Hai': { chinese: '‰∫•', animal: 'Pig', element: 'Yin Water' }
}

// Check if there are transformations
const hasTransformations = computed(() => {
 if (!chartData.value?.nodes) return false
 
 // Check if any node has badges array with transformation items
 for (const node of Object.values(chartData.value.nodes)) {
  if (node.badges && node.badges.some(b => b.type === 'transformation')) return true
 }
 return false
})

// Count number of transformations (total across all nodes)
const transformationCount = computed(() => {
 if (!chartData.value?.nodes) return 0
 
 let count = 0
 for (const node of Object.values(chartData.value.nodes)) {
  if (node.badges && node.badges.length > 0) {
   count += node.badges.filter(b => b.type === 'transformation').length
  }
 }
 return count
})

// Get the active chart (original or transformed)
const activeChart = computed(() => {
 // Since API now returns nodes directly, we don't need natal_chart
 // Return null to force using the nodes-based approach
 return null
})

// Helper to parse pillar (handles both normal and transformed format)
function parsePillarForDisplay(pillarStr, isTransformed = false) {
 const parts = pillarStr.split(' ')
 
 // Handle transformed format like "Bing Fire" where branch is replaced by element
 if (parts.length === 2 && (parts[1] === 'Fire' || parts[1] === 'Water' || parts[1] === 'Wood' || parts[1] === 'Metal' || parts[1] === 'Earth')) {
  const stemName = parts[0]
  const element = parts[1]
  
  // Create a special display for transformed element branches
  return {
   stemName,
   stem: HEAVENLY_STEMS[stemName] || { chinese: stemName, element: 'Unknown' },
   branchName: element,
   branch: {
    chinese: element === 'Fire' ? 'ÁÅ´' : element === 'Water' ? 'Ê∞¥' : element === 'Wood' ? 'Êú®' : element === 'Metal' ? 'Èáë' : 'Âúü',
    animal: element,
    element: `Yang ${element}` // Default to Yang for transformed elements
   }
  }
 }
 
 // Normal pillar format
 const [stemName, branchName] = parts
 return {
  stemName,
  stem: HEAVENLY_STEMS[stemName] || { chinese: stemName, element: 'Unknown' },
  branchName,
  branch: EARTHLY_BRANCHES[branchName] || { chinese: branchName, animal: branchName, element: 'Unknown' }
 }
}

// Node-based chart data - now directly at top level
const nodes = computed(() => {
 if (!chartData.value) return null
 
 // Extract node data (hs_y, eb_y, etc.) from top level
 const nodeKeys = ['hs_y', 'eb_y', 'hs_m', 'eb_m', 'hs_d', 'eb_d', 'hs_h', 'eb_h', 
          'hs_10yl', 'eb_10yl', 'hs_yl', 'eb_yl',
          'hs_month', 'eb_month', 'hs_day', 'eb_day']
 
 const nodesData = {}
 for (const key of nodeKeys) {
  if (chartData.value[key]) {
   nodesData[key] = chartData.value[key]
  }
 }
 
 return Object.keys(nodesData).length > 0 ? nodesData : null
})

// Get node by ID
function getNode(nodeId) {
 return nodes.value?.[nodeId] || null
}

// Helper function to enrich badge with interaction data
function enrichBadgeWithInteraction(badge) {
 if (!badge || !badge.interaction_id) return badge
 
 // Map size to strength for backward compatibility
 const sizeToStrength = {
  'xs': 'weak',
  'sm': 'normal',
  'md': 'normal',      // Medium = normal
  'lg': 'strong',
  'xl': 'ultra_strong'
 }
 
 // Normalize interaction_id to match the interactions object keys
 // Badge format: HS_COMBINATION_Ding-Ren_hs_h-hs_y
 // Interaction key: STEM_COMBINATION~Ding-Ren~hs_h-hs_y
 let normalizedId = badge.interaction_id
 
 // Replace HS_COMBINATION with STEM_COMBINATION
 normalizedId = normalizedId.replace('HS_COMBINATION', 'STEM_COMBINATION')
 
 // Split by underscore and identify parts
 // Pattern: TYPE_Pattern_nodes where nodes contain underscores
 const parts = normalizedId.split('_')
 if (parts.length >= 3) {
  // Reconstruct: TYPE~Pattern~nodes
  // The first part is the type (may have multiple words joined by underscores)
  // Find where the pattern starts (contains dash or is a node ID)
  let typeEndIndex = 1
  for (let i = 1; i < parts.length; i++) {
   if (parts[i].includes('-') || parts[i].match(/^(hs|eb)$/)) {
    typeEndIndex = i
    break
   }
  }
  const type = parts.slice(0, typeEndIndex).join('_')
  const restParts = parts.slice(typeEndIndex)
  // Find where nodes start (after pattern)
  let patternEndIndex = 0
  for (let i = 0; i < restParts.length; i++) {
   if (restParts[i].match(/^(hs|eb)$/)) {
    patternEndIndex = i
    break
   }
  }
  const pattern = restParts.slice(0, patternEndIndex).join('_')
  const nodes = restParts.slice(patternEndIndex).join('_')
  normalizedId = `${type}~${pattern}~${nodes}`
 }
 
 // Get interaction data from chartData
 const interaction = chartData.value?.interactions?.[normalizedId] || chartData.value?.interactions?.[badge.interaction_id] || {}
 
 return {
  badge: badge.badge || '',
  type: interaction.type || badge.type || '',
  element: interaction.element || '',
  pattern: interaction.pattern || '',
  strength: sizeToStrength[badge.size] || 'normal',
  interaction_id: badge.interaction_id,
  interactionKey: normalizedId,
  tooltip: interaction.description || badge.type || ''
 }
}

// Computed properties
const pillars = computed(() => {
 // Simple direct access to node data as requested
 if (!chartData.value) {
  console.log('pillars computed: no chartData')
  return null
 }
 
 const data = chartData.value
 const mappings = data.mappings || {}
 console.log('pillars computed: has chartData, mappings:', !!mappings)
 
 // Helper to build pillar from node data
 const buildPillar = (hsKey, ebKey, label, isDayMaster = false) => {
  const hsNode = data[hsKey]
  const ebNode = data[ebKey]
  
  if (!hsNode && !ebNode) return null
  
  // Use viewMode to determine which state to show (base or post)
  const usePost = viewMode.value === 'post'
  
  // For stems: always use the base ID for the main character
  // Store badges array and split by type
  const stemId = hsNode?.id
  const stemBadges = usePost ? (hsNode?.badges || []) : []
  const stemTransformations = stemBadges.filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b))
  const stemCombinations = stemBadges.filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b))
  const stemNegatives = stemBadges.filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b))
  
  // Check if stem transformed to element name (like "Yang Metal")
  const isElementName = stemId && stemId.includes(' ') && ['Yang', 'Yin'].some(p => stemId.startsWith(p))
  
  let stemChinese, stemElement, stemColor
  
  if (isElementName) {
   // Handle element name transformations - map back to proper stem ID
   const elementToStemMap = {
    'Yang Metal': 'Geng',
    'Yin Metal': 'Xin',
    'Yang Water': 'Ren',
    'Yin Water': 'Gui',
    'Yang Wood': 'Jia',
    'Yin Wood': 'Yi',
    'Yang Fire': 'Bing',
    'Yin Fire': 'Ding',
    'Yang Earth': 'Wu',
    'Yin Earth': 'Ji'
   }
   const actualStemId = elementToStemMap[stemId] || stemId
   const stemMapping = mappings.heavenly_stems?.[actualStemId] || {}
   stemChinese = stemMapping.chinese || actualStemId || '?'
   stemElement = stemMapping.english || stemId
   // Use regular color from mapping for stem transformations
   stemColor = stemMapping.hex_color || hsNode?.hex_color || hsNode?.color || '#808080'
  } else {
   // Normal stem mapping
   const stemMapping = mappings.heavenly_stems?.[stemId] || {}
   stemChinese = stemMapping.chinese || stemId || '?'
   stemElement = stemMapping.english || hsNode?.element || 'Unknown'
   stemColor = stemMapping.hex_color || hsNode?.hex_color || hsNode?.color || '#808080'
  }
  
  const stem = {
   chinese: stemChinese,
   element: stemElement,
   color: stemColor
  }
  
  // Get the proper stem name (pinyin) for display
  let stemName
  if (isElementName) {
   // If it's an element name, get the corresponding stem ID
   const elementToStemMap = {
    'Yang Metal': 'Geng',
    'Yin Metal': 'Xin',
    'Yang Water': 'Ren',
    'Yin Water': 'Gui',
    'Yang Wood': 'Jia',
    'Yin Wood': 'Yi',
    'Yang Fire': 'Bing',
    'Yin Fire': 'Ding',
    'Yang Earth': 'Wu',
    'Yin Earth': 'Ji'
   }
   stemName = elementToStemMap[stemId] || stemId
  } else {
   stemName = stemId || '?'
  }
  
  // For branches: always use the base ID for the main character
  // Store badges array and split by type
  const branchId = ebNode?.id
  const branchBadges = usePost ? (ebNode?.badges || []) : []
  const branchTransformations = branchBadges.filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b))
  const branchCombinations = branchBadges.filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b))
  const branchNegatives = branchBadges.filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b))
  
  // Check if branch transformed to pure element (Fire, Water, etc)
  const isElementTransformation = usePost && ['Fire', 'Water', 'Metal', 'Wood', 'Earth'].includes(branchId)
  
  let branchChinese, branchAnimal, branchElement, branchColor
  
  if (isElementTransformation) {
   // Handle pure element transformation - use emphasized colors
   const elementMap = {
    'Fire': { chinese: 'ÁÅ´', color: '#ff6b6b' },
    'Water': { chinese: 'Ê∞¥', color: '#4dabf7' },
    'Metal': { chinese: 'Èáë', color: '#868e96' },
    'Wood': { chinese: 'Êú®', color: '#51cf66' },
    'Earth': { chinese: 'Âúü', color: '#fab005' }
   }
   branchChinese = elementMap[branchId]?.chinese || branchId
   branchAnimal = branchId // Show element name instead of animal
   branchElement = branchId
   // Use emphasized color for pure element transformations
   branchColor = elementMap[branchId]?.color || '#808080'
  } else {
   // Normal branch mapping
   const branchMapping = mappings.earthly_branches?.[branchId] || {}
   branchChinese = branchMapping.chinese || branchId || '?'
   branchAnimal = branchMapping.animal || '?'
   
   // Map branch ID to element (branches have dominant elements)
   const branchToElement = {
    'Zi': 'Water',  // Rat - Water
    'Chou': 'Earth', // Ox - Earth
    'Yin': 'Wood',  // Tiger - Wood
    'Mao': 'Wood',  // Rabbit - Wood
    'Chen': 'Earth', // Dragon - Earth
    'Si': 'Fire',  // Snake - Fire
    'Wu': 'Fire',  // Horse - Fire
    'Wei': 'Earth', // Goat - Earth
    'Shen': 'Metal', // Monkey - Metal
    'You': 'Metal', // Rooster - Metal
    'Xu': 'Earth',  // Dog - Earth
    'Hai': 'Water'  // Pig - Water
   }
   branchElement = branchToElement[branchId] || 'Unknown'
   branchColor = ebNode?.hex_color || ebNode?.color || branchMapping.hex_color || '#808080'
  }
  
  const branch = {
   chinese: branchChinese,
   animal: branchAnimal,
   element: branchElement,
   color: branchColor
  }
  
  // Hidden stems from eb.qi - use post_interaction_qi for post view, base_qi for base view
  const hiddenQi = usePost ? (ebNode?.post_interaction_qi || {}) : (ebNode?.base_qi || {})
  
  // Map hidden stems to Ten Gods using frontend mappings
  const hiddenStems = {}
  if (hiddenQi && data.mappings?.ten_gods) {
   const dayMasterStem = data.hs_d?.id || 'Yi'
   for (const stemName of Object.keys(hiddenQi)) {
    const tenGodData = data.mappings?.ten_gods?.[dayMasterStem]?.[stemName]
    hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
   }
  }
  
  // Calculate Ten God for the Heavenly Stem
  let stemTenGod = null
  if (isDayMaster) {
   stemTenGod = 'DM'
  } else if (hsNode?.id && data.mappings?.ten_gods) {
   const dayMasterStem = data.hs_d?.id || 'Yi'
   const tenGodData = data.mappings?.ten_gods?.[dayMasterStem]?.[hsNode.id]
   stemTenGod = tenGodData?.abbreviation || tenGodData?.id || null
  }
  
  return {
   label,
   stem,
   stemName: stemName,
   branch,
   branchName: branchId,
   stemKey: hsKey,
   branchKey: ebKey,
   hiddenStems,
   hiddenQi,
   tenGod: stemTenGod,
   isUnknown: !hsNode && !ebNode,
   // Transformation badges
   stemTransformations,
   branchTransformations,
   // Combination badges
   stemCombinations,
   branchCombinations,
   // Negative badges
   stemNegatives,
   branchNegatives
  }
 }
 
 const yearPillar = buildPillar('hs_y', 'eb_y', 'Year Âπ¥')
 const monthPillar = buildPillar('hs_m', 'eb_m', 'Month Êúà')
 const dayPillar = buildPillar('hs_d', 'eb_d', 'Day Êó•', true)
 const hourPillar = buildPillar('hs_h', 'eb_h', 'Hour ÊôÇ')
 
 // Check if we have at least the essential pillars (year, month, day)
 if (!yearPillar || !monthPillar || !dayPillar) {
  return null
 }
 
 const result = {
  year: yearPillar,
  month: monthPillar, 
  day: dayPillar,
  hour: hourPillar || {
   label: 'Hour ÊôÇ',
   stem: { chinese: '?', element: 'Unknown' },
   stemName: '?',
   branch: { chinese: '?', animal: '?', element: 'Unknown' },
   branchName: '?',
   stemKey: 'hs_h',
   branchKey: 'eb_h',
   hiddenStems: null,
   tenGod: null,
   transformed: false,
   isUnknown: true
  }
 }
 
 console.log('Simplified pillars from direct node access:', result)
 return result
})

// Natal pillars only (4 columns: Hour, Day, Month, Year)
const natalPillarsOrdered = computed(() => {
 if (!pillars.value) return null
 
 return [
  pillars.value.hour,
  pillars.value.day,
  pillars.value.month,
  pillars.value.year
 ]
})

// Luck pillars only (for separate display below natal chart)
const luckPillarsOrdered = computed(() => {
 if (!chartData.value?.mappings) return []
 
 const luckPillars = []
 
 // Add 10-year luck pillar if available
 if (currentLuckPillar.value) {
  const luckPillarStr = currentLuckPillar.value.pillar
  const [hsName, ebName] = luckPillarStr.split(' ')
  const mappings = chartData.value.mappings
  
  const hsMapping = mappings.heavenly_stems?.[hsName] || {}
  const ebMapping = mappings.earthly_branches?.[ebName] || {}
  
  // Get hidden stems from backend node data
  const ebLuckNode = chartData.value?.eb_10yl
  const hsLuckNode = chartData.value?.hs_10yl
  
  // Calculate Ten God for 10Y luck HS
  const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
  const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
  const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
  
  // Map hidden stems to Ten Gods using frontend mappings (use post_interaction_qi in post view, base_qi in base view)
  const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
  const luckQi = usePost ? (ebLuckNode?.post_interaction_qi || ebLuckNode?.base_qi || {}) : (ebLuckNode?.base_qi || {})
  const hiddenStems = {}
  if (luckQi && mappings.ten_gods) {
   for (const stemName of Object.keys(luckQi)) {
    const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
    hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
   }
  }
  
  luckPillars.push({
   label: '10Y Luck ÈÅã',
   stem: {
    chinese: hsMapping.chinese || hsName,
    element: currentLuckPillar.value.hs_element || hsMapping.english || 'Unknown',
    color: hsMapping.hex_color || '#808080'
   },
   stemName: hsName,
   branch: {
    chinese: ebMapping.chinese || ebName,
    animal: currentLuckPillar.value.eb_animal || ebMapping.animal || 'Unknown',
    element: currentLuckPillar.value.eb_animal || 'Unknown',
    color: ebMapping.hex_color || '#808080'
   },
   branchName: ebName,
   stemKey: 'hs_10yl',
   branchKey: 'eb_10yl',
   hiddenStems: hiddenStems,
   hiddenQi: ebLuckNode?.base_qi || null, // Get hidden stems qi from backend
   tenGod: tenGodLabel,
   isUnknown: false,
   stemTransformations: (hsLuckNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   branchTransformations: (ebLuckNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   stemCombinations: (hsLuckNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   branchCombinations: (ebLuckNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   stemNegatives: (hsLuckNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   branchNegatives: (ebLuckNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   isLuckPillar: true,
   timing: currentLuckPillar.value.timing
  })
 }
 
 // Add annual luck pillar if available
 if (annualLuckPillar.value && chartData.value?.mappings) {
  const annualPillarStr = annualLuckPillar.value.pillar
  const [hsName, ebName] = annualPillarStr.split(' ')
  const mappings = chartData.value.mappings
  
  const hsMapping = mappings.heavenly_stems?.[hsName] || {}
  const ebMapping = mappings.earthly_branches?.[ebName] || {}
  
  // Get hidden stems from backend node data
  const ebAnnualNode = chartData.value?.eb_yl
  const hsAnnualNode = chartData.value?.hs_yl
  
  // Calculate Ten God for annual luck HS
  const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
  const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
  const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
  
  // Map hidden stems to Ten Gods using frontend mappings (use post.qi in post view, base.qi in base view)
  const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
  const annualQi = usePost ? (ebAnnualNode?.post_interaction_qi || ebAnnualNode?.base_qi || {}) : (ebAnnualNode?.base_qi || {})
  const hiddenStems = {}
  if (annualQi && mappings.ten_gods) {
   for (const stemName of Object.keys(annualQi)) {
    const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
    hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
   }
  }
  
  luckPillars.push({
   label: 'Annual Âπ¥ÈÅã',
   stem: {
    chinese: hsMapping.chinese || hsName,
    element: annualLuckPillar.value.hs_element || hsMapping.english || 'Unknown',
    color: hsMapping.hex_color || '#808080'
   },
   stemName: hsName,
   branch: {
    chinese: ebMapping.chinese || ebName,
    animal: annualLuckPillar.value.eb_animal || ebMapping.animal || 'Unknown',
    element: annualLuckPillar.value.eb_animal || 'Unknown',
    color: ebMapping.hex_color || '#808080'
   },
   branchName: ebName,
   stemKey: 'hs_yl',
   branchKey: 'eb_yl',
   hiddenStems: hiddenStems,
   hiddenQi: ebAnnualNode?.base_qi || null, // Get hidden stems qi from backend
   tenGod: tenGodLabel,
   isUnknown: false,
   stemTransformations: (hsAnnualNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   branchTransformations: (ebAnnualNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   stemCombinations: (hsAnnualNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   branchCombinations: (ebAnnualNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   stemNegatives: (hsAnnualNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   branchNegatives: (ebAnnualNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   isAnnualLuck: true,
   year: annualLuckPillar.value.year
  })
 }
 
 // Extract Monthly Pillar (if available)
 if (chartData.value?.analysis_info?.has_monthly && chartData.value?.hs_ml && chartData.value?.eb_ml) {
  const hsMonthlyNode = chartData.value.hs_ml
  const ebMonthlyNode = chartData.value.eb_ml
  const [hsName, ebName] = [hsMonthlyNode.id, ebMonthlyNode.id]
  
  if (hsName && ebName) {
   const mappings = chartData.value.mappings
   const hsMapping = mappings.heavenly_stems?.[hsName] || {}
   const ebMapping = mappings.earthly_branches?.[ebName] || {}
   
   const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
   const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
   const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
   
   // Map hidden stems to Ten Gods using frontend mappings (use post_interaction_qi in post view, base_qi in base view)
   const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
   const monthlyQi = usePost ? (ebMonthlyNode?.post_interaction_qi || ebMonthlyNode?.base_qi || {}) : (ebMonthlyNode?.base_qi || {})
   const hiddenStems = {}
   if (monthlyQi && mappings.ten_gods) {
    for (const stemName of Object.keys(monthlyQi)) {
     const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
     hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
    }
   }
   
   luckPillars.push({
    label: 'Monthly ÊúàÈÅã',
    stem: {
     chinese: hsMapping.chinese || hsName,
     element: hsMapping.english || 'Unknown',
     color: hsMapping.hex_color || '#808080'
    },
    stemName: hsName,
    branch: {
     chinese: ebMapping.chinese || ebName,
     animal: ebMapping.animal || 'Unknown',
     element: ebMapping.animal || 'Unknown',
     color: ebMapping.hex_color || '#808080'
    },
    branchName: ebName,
    stemKey: 'hs_ml',
    branchKey: 'eb_ml',
    hiddenStems: hiddenStems,
    hiddenQi: ebMonthlyNode?.base_qi || null,
    tenGod: tenGodLabel,
    isUnknown: false,
    stemTransformations: (hsMonthlyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    branchTransformations: (ebMonthlyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    stemCombinations: (hsMonthlyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    branchCombinations: (ebMonthlyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    stemNegatives: (hsMonthlyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    branchNegatives: (ebMonthlyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    isMonthlyLuck: true
   })
  }
 }
 
 // Extract Daily Pillar (if available)
 if (chartData.value?.analysis_info?.has_daily && chartData.value?.hs_dl && chartData.value?.eb_dl) {
  const hsDailyNode = chartData.value.hs_dl
  const ebDailyNode = chartData.value.eb_dl
  const [hsName, ebName] = [hsDailyNode.id, ebDailyNode.id]
  
  if (hsName && ebName) {
   const mappings = chartData.value.mappings
   const hsMapping = mappings.heavenly_stems?.[hsName] || {}
   const ebMapping = mappings.earthly_branches?.[ebName] || {}
   
   const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
   const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
   const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
   
   // Map hidden stems to Ten Gods using frontend mappings (use post_interaction_qi in post view, base_qi in base view)
   const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
   const dailyQi = usePost ? (ebDailyNode?.post_interaction_qi || ebDailyNode?.base_qi || {}) : (ebDailyNode?.base_qi || {})
   const hiddenStems = {}
   if (dailyQi && mappings.ten_gods) {
    for (const stemName of Object.keys(dailyQi)) {
     const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
     hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
    }
   }
   
   luckPillars.push({
    label: 'Daily Êó•ÈÅã',
    stem: {
     chinese: hsMapping.chinese || hsName,
     element: hsMapping.english || 'Unknown',
     color: hsMapping.hex_color || '#808080'
    },
    stemName: hsName,
    branch: {
     chinese: ebMapping.chinese || ebName,
     animal: ebMapping.animal || 'Unknown',
     element: ebMapping.animal || 'Unknown',
     color: ebMapping.hex_color || '#808080'
    },
    branchName: ebName,
    stemKey: 'hs_dl',
    branchKey: 'eb_dl',
    hiddenStems: hiddenStems,
    hiddenQi: ebDailyNode?.base_qi || null,
    tenGod: tenGodLabel,
    isUnknown: false,
    stemTransformations: (hsDailyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    branchTransformations: (ebDailyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    stemCombinations: (hsDailyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    branchCombinations: (ebDailyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    stemNegatives: (hsDailyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    branchNegatives: (ebDailyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    isDailyLuck: true
   })
  }
 }
 
 // Extract Hourly Pillar (if available)
 if (chartData.value?.analysis_info?.has_hourly && chartData.value?.hs_hl && chartData.value?.eb_hl) {
  const hsHourlyNode = chartData.value.hs_hl
  const ebHourlyNode = chartData.value.eb_hl
  const [hsName, ebName] = [hsHourlyNode.id, ebHourlyNode.id]
  
  if (hsName && ebName) {
   const mappings = chartData.value.mappings
   const hsMapping = mappings.heavenly_stems?.[hsName] || {}
   const ebMapping = mappings.earthly_branches?.[ebName] || {}
   
   const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
   const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
   const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
   
   // Map hidden stems to Ten Gods using frontend mappings (use post_interaction_qi in post view, base_qi in base view)
   const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
   const hourlyQi = usePost ? (ebHourlyNode?.post_interaction_qi || ebHourlyNode?.base_qi || {}) : (ebHourlyNode?.base_qi || {})
   const hiddenStems = {}
   if (hourlyQi && mappings.ten_gods) {
    for (const stemName of Object.keys(hourlyQi)) {
     const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
     hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
    }
   }
   
   luckPillars.push({
    label: 'Hourly ÊôÇÈÅã',
    stem: {
     chinese: hsMapping.chinese || hsName,
     element: hsMapping.english || 'Unknown',
     color: hsMapping.hex_color || '#808080'
    },
    stemName: hsName,
    branch: {
     chinese: ebMapping.chinese || ebName,
     animal: ebMapping.animal || 'Unknown',
     element: ebMapping.animal || 'Unknown',
     color: ebMapping.hex_color || '#808080'
    },
    branchName: ebName,
    stemKey: 'hs_hl',
    branchKey: 'eb_hl',
    hiddenStems: hiddenStems,
    hiddenQi: ebHourlyNode?.base_qi || null,
    tenGod: tenGodLabel,
    isUnknown: false,
    stemTransformations: (hsHourlyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    branchTransformations: (ebHourlyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    stemCombinations: (hsHourlyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    branchCombinations: (ebHourlyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    stemNegatives: (hsHourlyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    branchNegatives: (ebHourlyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    isHourlyLuck: true
   })
  }
 }
 
 return luckPillars
})

// Talisman pillars (Á¨¶) - User-selected pillars for harmony/balance
const talismanPillarsOrdered = computed(() => {
 if (!chartData.value?.mappings) return []
 
 const talismanPillars = []
 const mappings = chartData.value.mappings
 const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
 
 // Helper function to create talisman pillar (supports partial: HS-only, EB-only, or both)
 const createTalismanPillar = (label, hsNode, ebNode, hsKey, ebKey, isYear, isMonth, isDay, isHour) => {
  // Must have at least one node (HS or EB)
  if (!hsNode && !ebNode) return null
  
  const hsName = hsNode?.id || null
  const ebName = ebNode?.id || null
  
  const hsMapping = hsName ? (mappings.heavenly_stems?.[hsName] || {}) : {}
  const ebMapping = ebName ? (mappings.earthly_branches?.[ebName] || {}) : {}
  const tenGodData = hsName ? mappings.ten_gods?.[dayMasterStem]?.[hsName] : null
  const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
  
  // Hidden stems from eb.qi - use post_interaction_qi for post view, base_qi for base view (EXACT same as natal)
  const usePost = viewMode.value === 'post'
  const hiddenQi = usePost ? (ebNode?.post_interaction_qi || {}) : (ebNode?.base_qi || {})
  
  // Map hidden stems to Ten Gods using frontend mappings (EXACT same as natal)
  const hiddenStems = {}
  if (hiddenQi && mappings.ten_gods) {
   for (const stemName of Object.keys(hiddenQi)) {
    const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
    hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
   }
  }
  
  return {
   label,
   stem: hsName ? {
    chinese: hsMapping.chinese || hsName,
    element: hsMapping.english || 'Unknown',
    color: hsMapping.hex_color || '#808080'
   } : null,
   stemName: hsName || null,
   branch: ebName ? {
    chinese: ebMapping.chinese || ebName,
    animal: ebMapping.animal || 'Unknown',
    element: ebMapping.animal || 'Unknown',
    color: ebMapping.hex_color || '#808080'
   } : null,
   branchName: ebName || null,
   stemKey: hsKey,
   branchKey: ebKey,
   hiddenStems,
   hiddenQi,
   tenGod: tenGodLabel,
   isUnknown: false,
   stemTransformations: (hsNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   branchTransformations: (ebNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   stemCombinations: (hsNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   branchCombinations: (ebNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   stemNegatives: (hsNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   branchNegatives: (ebNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction', 'stem_conflict'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   isTalismanYear: isYear,
   isTalismanMonth: isMonth,
   isTalismanDay: isDay,
   isTalismanHour: isHour
  }
 }
 
 // Add talisman pillars if they exist (use ty/tm/td/th node IDs)
 const tyPillar = createTalismanPillar('Talisman Y Á¨¶Âπ¥', chartData.value.hs_ty, chartData.value.eb_ty, 'hs_ty', 'eb_ty', true, false, false, false)
 if (tyPillar) talismanPillars.push(tyPillar)
 
 const tmPillar = createTalismanPillar('Talisman M Á¨¶Êúà', chartData.value.hs_tm, chartData.value.eb_tm, 'hs_tm', 'eb_tm', false, true, false, false)
 if (tmPillar) talismanPillars.push(tmPillar)
 
 const tdPillar = createTalismanPillar('Talisman D Á¨¶Êó•', chartData.value.hs_td, chartData.value.eb_td, 'hs_td', 'eb_td', false, false, true, false)
 if (tdPillar) talismanPillars.push(tdPillar)
 
 const thPillar = createTalismanPillar('Talisman H Á¨¶ÊôÇ', chartData.value.hs_th, chartData.value.eb_th, 'hs_th', 'eb_th', false, false, false, true)
 if (thPillar) talismanPillars.push(thPillar)
 
 return talismanPillars
})

// Location pillars (Âú∞) - Overseas or birthplace nodes (NO badges)
const locationPillarsOrdered = computed(() => {
 if (!chartData.value?.mappings) return []
 
 const locationPillars = []
 const mappings = chartData.value.mappings
 const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
 
 // Helper function to create location pillar (NO badges - only display)
 const createLocationPillar = (label, hsNode, ebNode, hsKey, ebKey, borderColor) => {
  // Must have at least one node (HS or EB)
  if (!hsNode && !ebNode) return null
  
  const hsName = hsNode?.id || null
  const ebName = ebNode?.id || null
  
  const hsMapping = hsName ? (mappings.heavenly_stems?.[hsName] || {}) : {}
  const ebMapping = ebName ? (mappings.earthly_branches?.[ebName] || {}) : {}
  const tenGodData = hsName ? mappings.ten_gods?.[dayMasterStem]?.[hsName] : null
  const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
  
  // Hidden stems from eb.qi - use post_interaction_qi for post view, base_qi for base view
  const usePost = viewMode.value === 'post'
  const hiddenQi = usePost ? (ebNode?.post_interaction_qi || {}) : (ebNode?.base_qi || {})
  
  // Map hidden stems to Ten Gods
  const hiddenStems = {}
  if (hiddenQi && mappings.ten_gods) {
   for (const stemName of Object.keys(hiddenQi)) {
    const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
    hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
   }
  }
  
  return {
   label,
   stem: hsName ? {
    chinese: hsMapping.chinese || hsName,
    element: hsMapping.english || 'Unknown',
    color: hsMapping.hex_color || '#808080'
   } : null,
   stemName: hsName || null,
   branch: ebName ? {
    chinese: ebMapping.chinese || ebName,
    animal: ebMapping.animal || 'Unknown',
    element: ebMapping.animal || 'Unknown',
    color: ebMapping.hex_color || '#808080'
   } : null,
   branchName: ebName || null,
   stemKey: hsKey,
   branchKey: ebKey,
   hiddenStems,
   hiddenQi,
   tenGod: tenGodLabel,
   isUnknown: false,
   isLocationNode: true,
   locationBorderColor: borderColor,
   // NO badges for location nodes
   stemTransformations: [],
   branchTransformations: [],
   stemCombinations: [],
   branchCombinations: [],
   stemNegatives: [],
   branchNegatives: []
  }
 }
 
 // Add overseas pillars (o1, o2) - blue border for water
 const o1Pillar = createLocationPillar('Overseas 1', chartData.value.hs_o1, chartData.value.eb_o1, 'hs_o1', 'eb_o1', 'border-blue-600')
 if (o1Pillar) locationPillars.push(o1Pillar)
 
 const o2Pillar = createLocationPillar('Overseas 2', chartData.value.hs_o2, chartData.value.eb_o2, 'hs_o2', 'eb_o2', 'border-blue-600')
 if (o2Pillar) locationPillars.push(o2Pillar)
 
 // Add birthplace pillars (b1-b4) - amber border for earth
 const b1Pillar = createLocationPillar('Birthplace 1', chartData.value.hs_b1, chartData.value.eb_b1, 'hs_b1', 'eb_b1', 'border-amber-600')
 if (b1Pillar) locationPillars.push(b1Pillar)
 
 const b2Pillar = createLocationPillar('Birthplace 2', chartData.value.hs_b2, chartData.value.eb_b2, 'hs_b2', 'eb_b2', 'border-amber-600')
 if (b2Pillar) locationPillars.push(b2Pillar)
 
 const b3Pillar = createLocationPillar('Birthplace 3', chartData.value.hs_b3, chartData.value.eb_b3, 'hs_b3', 'eb_b3', 'border-amber-600')
 if (b3Pillar) locationPillars.push(b3Pillar)
 
 const b4Pillar = createLocationPillar('Birthplace 4', chartData.value.hs_b4, chartData.value.eb_b4, 'hs_b4', 'eb_b4', 'border-amber-600')
 if (b4Pillar) locationPillars.push(b4Pillar)
 
 return locationPillars
})

// Natal pillars only (4 columns: hour, day, month, year)
const natalPillarsOnly = computed(() => {
 if (!pillars.value) return null
 
 return [
  pillars.value.hour,
  pillars.value.day,
  pillars.value.month,
  pillars.value.year
 ]
})

// Combined ordered pillars (natal + luck + talismans - all need to be here for interaction calculations)
const pillarsOrdered = computed(() => {
 if (!pillars.value) return null
 
 const basePillars = [
  pillars.value.hour,
  pillars.value.day,
  pillars.value.month,
  pillars.value.year
 ]
 
 // Use luckPillarsOrdered to get all luck pillars (10Y, annual, monthly, daily, hourly)
 const allLuckPillars = luckPillarsOrdered.value || []
 
 // Get talisman pillars
 const allTalismanPillars = talismanPillarsOrdered.value || []
 
 // Combine natal + luck + talisman pillars (all must be in array for interactions)
 return [...basePillars, ...allLuckPillars, ...allTalismanPillars]
})

// Filter natal + luck pillars (exclude talismans for main chart display)
const natalAndLuckPillars = computed(() => {
 if (!pillarsOrdered.value) return null
 return pillarsOrdered.value.filter(p => 
  !p.isTalismanYear && !p.isTalismanMonth && !p.isTalismanDay && !p.isTalismanHour
 )
})

// Talisman display row (4 slots aligned: hour, day, month, year)
const talismanPillarsDisplay = computed(() => {
 if (!talismanPillarsOrdered.value) return []
 
 const talismans = talismanPillarsOrdered.value
 const display = [null, null, null, null] // [hour, day, month, year]
 
 talismans.forEach(t => {
  if (t.isTalismanHour) display[0] = t
  else if (t.isTalismanDay) display[1] = t
  else if (t.isTalismanMonth) display[2] = t
  else if (t.isTalismanYear) display[3] = t
 })
 
 return display
})

// Luck pillars display grid (5 slots: hour, day, month, annual, 10Y)
// Aligned below natal pillars for vertical reading
const luckPillarsDisplay = computed(() => {
 if (!luckPillarsOrdered.value) return []
 
 const luck = luckPillarsOrdered.value
 const display = [null, null, null, null, null] // [hour_luck, day_luck, month_luck, annual_luck, 10y_luck]
 
 luck.forEach(lp => {
  if (lp.isHourlyLuck) display[0] = lp
  else if (lp.isDailyLuck) display[1] = lp
  else if (lp.isMonthlyLuck) display[2] = lp
  else if (lp.isAnnualLuck) display[3] = lp
  else if (lp.isLuckPillar) display[4] = lp  // 10-year luck
 })
 
 return display
})

// Old manual pillar building logic removed - now using luckPillarsOrdered
// (Simplified from 150+ lines to just using luckPillarsOrdered above)

const tenElements = computed(() => {
 // Base = natal chart only (8 nodes, no interactions): natal_base_elements
 // Post = all nodes with all interactions: advanced_post_elements
 // Shows the journey from pure birth chart ‚Üí current state with everything
 if (!chartData.value) return []
 
 // Base: Pure natal chart (8 nodes, no interactions)
 const baseScores = chartData.value.natal_base_elements || chartData.value.base_element_score || {}
 
 // Post: All nodes (natal + luck + talisman + location) with all interactions
 const postScores = chartData.value.advanced_post_elements || chartData.value.post_element_score || {}
 
 // Map stem IDs to display names
 const stemToDisplay = {
  'Jia': 'Yang Wood',
  'Yi': 'Yin Wood',
  'Bing': 'Yang Fire',
  'Ding': 'Yin Fire',
  'Wu': 'Yang Earth',
  'Ji': 'Yin Earth',
  'Geng': 'Yang Metal',
  'Xin': 'Yin Metal',
  'Ren': 'Yang Water',
  'Gui': 'Yin Water'
 }
 
 return Object.entries(stemToDisplay).map(([stem, displayName]) => ({
  name: displayName,
  naive: baseScores[stem] || 0,
  final: postScores[stem] || 0,
  change: (postScores[stem] || 0) - (baseScores[stem] || 0)
 }))
})

const fiveElements = computed(() => {
 // Base = natal chart only (8 nodes, no interactions): natal_base_elements
 // Post = all nodes with all interactions: advanced_post_elements
 // Shows the journey from pure birth chart ‚Üí current state with everything
 if (!chartData.value) return []
 
 // Base: Pure natal chart (8 nodes, no interactions)
 const baseScores = chartData.value.natal_base_elements || chartData.value.base_element_score || {}
 
 // Post: All nodes (natal + luck + talisman + location) with all interactions
 const postScores = chartData.value.advanced_post_elements || chartData.value.post_element_score || {}
 
 // Map stems to elements and sum them up
 const stemToElement = {
  'Jia': 'Wood', 'Yi': 'Wood',
  'Bing': 'Fire', 'Ding': 'Fire',
  'Wu': 'Earth', 'Ji': 'Earth',
  'Geng': 'Metal', 'Xin': 'Metal',
  'Ren': 'Water', 'Gui': 'Water'
 }
 
 const naiveByElement = {}
 const finalByElement = {}
 const elements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 
 // Initialize
 elements.forEach(elem => {
  naiveByElement[elem] = 0
  finalByElement[elem] = 0
 })
 
 // Sum up scores by element
 Object.entries(stemToElement).forEach(([stem, element]) => {
  naiveByElement[element] += baseScores[stem] || 0
  finalByElement[element] += postScores[stem] || 0
 })
 
 // Calculate totals for normalization to 100%
 const naiveTotal = Object.values(naiveByElement).reduce((sum, val) => sum + val, 0)
 const finalTotal = Object.values(finalByElement).reduce((sum, val) => sum + val, 0)
 
 // Normalize to percentages (0-100) and keep raw points
 return elements.map(name => {
  const naiveRaw = naiveByElement[name] || 0
  const finalRaw = finalByElement[name] || 0
  
  // Convert raw scores to percentages that sum to 100
  const naive = naiveTotal > 0 ? (naiveRaw / naiveTotal) * 100 : 0
  const final = finalTotal > 0 ? (finalRaw / finalTotal) * 100 : 0
  
  return {
   name,
   naive,
   final,
   change: final - naive,
   naiveRaw,  // Keep raw points
   finalRaw   // Keep raw points
  }
 })
})

const fiveElementsWithRelations = computed(() => {
 if (!fiveElements.value.length) return []
 
 // If no daymaster_analysis, return elements without relationships
 if (!chartData.value?.daymaster_analysis) {
  return fiveElements.value.map(element => ({
   ...element,
   relationship: ''
  }))
 }
 
 const daymaster = chartData.value.daymaster_analysis.daymaster
 const daymasterElement = daymaster.split(' ')[1] // Get element from "Yang Fire" -> "Fire"
 
 return fiveElements.value.map(element => ({
  ...element,
  relationship: getElementRelationship(daymasterElement, element.name)
 }))
})

// Calculate totals for different views (now these are already percentages that sum to 100)
const naiveTotal = computed(() => {
 if (!fiveElements.value.length) return 100
 return fiveElements.value.reduce((sum, e) => sum + e.naive, 0)
})

const finalTotal = computed(() => {
 if (!fiveElements.value.length) return 100
 return fiveElements.value.reduce((sum, e) => sum + e.final, 0)
})

const maxElementScore = computed(() => {
 // Since scores are now normalized to 100%, always use 100 as the max
 return 100
})

const maxTenElementScore = computed(() => {
 if (!tenElements.value.length) return 100
 // Find the maximum single element score for scaling
 const maxScore = Math.max(...tenElements.value.map(e => e.final))
 return Math.max(maxScore, 100)
})

const totalChange = computed(() => {
 if (!fiveElements.value.length) return 0
 return fiveElements.value.reduce((sum, e) => sum + e.change, 0)
})

const interactions = computed(() => {
 // Handle both new format (direct interactions object) and wrapped format
 const interactionsData = chartData.value?.interactions || chartData.value?.interaction_analysis?.interactions
 if (!interactionsData) return []
 
 // If it's an object (new format), convert to array
 if (typeof interactionsData === 'object' && !Array.isArray(interactionsData)) {
  return Object.entries(interactionsData).map(([id, data]) => ({
   id,
   ...data
  }))
 }
 
 // If it's already an array, return as-is
 return interactionsData
})

const nonNaturalInteractions = computed(() => {
 if (!interactions.value || !Array.isArray(interactions.value)) return []
 return interactions.value.filter(i => {
  return !i.type?.includes('NATURAL') && !i.type?.includes('ENERGY_FLOW') && i.type !== 'SEASONAL_ADJUSTMENT'
 })
})

// Extract luck pillar interactions from backend-calculated interactions
// Backend returns interactions as a DICTIONARY (not array), with keys like "TYPE~Pattern~nodes"
const luckPillarInteractions = computed(() => {
 if (!chartData.value?.interactions || (!currentLuckPillar.value && !annualLuckPillar.value)) return []
 
 const interactionsDict = chartData.value.interactions
 const luckInteractions = []
 
 // Iterate through interaction dictionary keys
 for (const [key, interactionData] of Object.entries(interactionsDict)) {
  // Check if this interaction involves luck pillar nodes (10-year, annual, monthly, daily, hourly)
  const nodes = interactionData.nodes || []
  const hasLuckNode = nodes.some(nodeId => 
   nodeId === 'hs_10yl' || nodeId === 'eb_10yl' ||
   nodeId === 'hs_yl' || nodeId === 'eb_yl' ||
   nodeId === 'hs_ml' || nodeId === 'eb_ml' ||
   nodeId === 'hs_dl' || nodeId === 'eb_dl' ||
   nodeId === 'hs_hl' || nodeId === 'eb_hl'
  )
  
  if (hasLuckNode) {
   // Parse the key format: "TYPE~Pattern~nodes"
   const [type, pattern, nodesStr] = key.split('~')
   
   // Determine effect based on interaction type
   let effect = 'positive'
   if (type && (
    type.includes('CLASH') || 
    type.includes('HARM') || 
    type.includes('PUNISHMENT') ||
    type.includes('CONFLICT') ||
    type.includes('DESTRUCTION')
   )) {
    effect = 'negative'
   }
   
   // Get label from type
   const labelMap = {
    'SIX_HARMONIES': 'ÂÖ≠Âêà',
    'CLASHES': 'Áõ∏ÂÜ≤',
    'HARMS': 'Áõ∏ÂÆ≥',
    'PUNISHMENTS': 'Áõ∏Âàë',
    'STEM_COMBINATION': 'Â§©Âπ≤Âêà',
    'STEM_CONFLICT': 'Â§©Âπ≤Ê≤ñ',
    'THREE_COMBINATIONS': '‰∏âÂêà',
    'HALF_COMBINATION': 'ÂçäÂêà',
    'DESTRUCTION': 'Áõ∏Á†¥'
   }
   const label = labelMap[type] || type
   
   luckInteractions.push({
    type,
    label,
    description: interactionData.pattern || pattern || `${type} interaction`,
    branches: interactionData.branches || interactionData.stems || [],
    nodes,
    effect
   })
  }
 }
 
 return luckInteractions
})

// Methods
async function generateChart() {
 if (!birthDate.value) {
  if (typeof window !== 'undefined') {
   alert('Please fill in birth date')
  }
  return
 }
 
 // Use 'unknown' for birth_time when hour is unknown
 const timeParam = unknownHour.value ? 'unknown' : birthTime.value
 
 if (!timeParam && !unknownHour.value) {
  if (typeof window !== 'undefined') {
   alert('Please fill in birth time or mark as unknown')
  }
  return
 }
 
 isLoading.value = true
 try {
  // Build API URL with analyze_bazi endpoint (underscore, not hyphen)
  // Call via Vite proxy to avoid CORS issues
  let apiUrl = `/api/analyze_bazi?birth_date=${birthDate.value}&birth_time=${encodeURIComponent(timeParam)}&gender=${gender.value}`
  
  // Only add analysis parameters if time travel mode is enabled (üîÆ toggle is ON)
  if (showAnalysisPeriod.value) {
   // Add analysis_year to get luck pillars (default to current year if not specified)
   const yearToAnalyze = analysisYear.value || new Date().getFullYear()
   apiUrl += `&analysis_year=${yearToAnalyze}`
   
   // Add include_annual_luck parameter (controls whether annual luck affects calculations)
   apiUrl += `&include_annual_luck=${includeAnnualLuck.value}`
   
   // Only send month/day/time if toggles are enabled (respects checkbox state)
   if (analysisMonth.value && includeMonthlyLuck.value) {
    apiUrl += `&analysis_month=${analysisMonth.value}`
   }
   
   if (analysisDay.value && includeDailyLuck.value) {
    apiUrl += `&analysis_day=${analysisDay.value}`
   }
   
   if (analysisTime.value && includeHourlyLuck.value) {
    apiUrl += `&analysis_time=${encodeURIComponent(analysisTime.value)}`
   }
  }
  
  // Add talisman parameters if talismans are enabled (only send defined values)
  if (showTalismans.value) {
   // Year talisman
   if (talismanYearHS.value) apiUrl += `&talisman_year_hs=${talismanYearHS.value}`
   if (talismanYearEB.value) apiUrl += `&talisman_year_eb=${talismanYearEB.value}`
   
   // Month talisman
   if (talismanMonthHS.value) apiUrl += `&talisman_month_hs=${talismanMonthHS.value}`
   if (talismanMonthEB.value) apiUrl += `&talisman_month_eb=${talismanMonthEB.value}`
   
   // Day talisman
   if (talismanDayHS.value) apiUrl += `&talisman_day_hs=${talismanDayHS.value}`
   if (talismanDayEB.value) apiUrl += `&talisman_day_eb=${talismanDayEB.value}`
   
   // Hour talisman
   if (talismanHourHS.value) apiUrl += `&talisman_hour_hs=${talismanHourHS.value}`
   if (talismanHourEB.value) apiUrl += `&talisman_hour_eb=${talismanHourEB.value}`
  }
  
  // Add location parameter if location is enabled
  if (showLocation.value && locationType.value) {
   apiUrl += `&location=${locationType.value}`
  }
  
  console.log('Calling analyze_bazi endpoint:', apiUrl)
  
  // Call the backend endpoint via proxy
  const response = await fetch(apiUrl)
  
  if (!response.ok) throw new Error('Chart API request failed')
  
  const data = await response.json()
  console.log('Chart data from analyze_bazi received:', data)
  chartData.value = data
  
  // Extract 10-year luck pillar info from response (if has_luck_pillar flag is true)
  if (data.analysis_info?.has_luck_pillar && data.hs_10yl && data.eb_10yl) {
   const luckHs = data.hs_10yl.id
   const luckEb = data.eb_10yl.id
   
   if (luckHs && luckEb) {
    currentLuckPillar.value = {
     pillar: `${luckHs} ${luckEb}`,
     hs_element: data.mappings?.heavenly_stems?.[luckHs]?.english || 'Unknown',
     eb_animal: data.mappings?.earthly_branches?.[luckEb]?.animal || 'Unknown',
     ten_god_hs: data.hs_10yl?.base?.ten_god || 'Unknown',
     ten_god_hidden: {},
     timing: (() => {
      const misc = data.hs_10yl?.misc || data.eb_10yl?.misc
      if (misc && misc.start_date && misc.end_date) {
       // Extract years from date strings (format: "YYYY-MM-DD")
       const startYear = misc.start_date.split('-')[0]
       const endYear = misc.end_date.split('-')[0]
       return {
        start_year: parseInt(startYear),
        end_year: parseInt(endYear),
        start_age: misc.start_age || 0,
        end_age: misc.end_age || 10,
        start_date: misc.start_date,
        end_date: misc.end_date
       }
      }
      // Fallback if no misc data
      return {
       start_year: data.analysis_info?.year || new Date().getFullYear(),
       end_year: (data.analysis_info?.year || new Date().getFullYear()) + 10,
       start_age: 0,
       end_age: 10
      }
     })(),
     is_current: true
    }
    console.log('10-year luck pillar extracted:', currentLuckPillar.value)
   } else {
    currentLuckPillar.value = null
   }
  } else {
   currentLuckPillar.value = null
  }
  
  // Extract annual luck pillar info from response (if year is set, even if disabled)
  if (data.analysis_info?.year && data.hs_yl && data.eb_yl) {
   const annualHs = data.hs_yl.id
   const annualEb = data.eb_yl.id
   
   if (annualHs && annualEb) {
    annualLuckPillar.value = {
     pillar: `${annualHs} ${annualEb}`,
     hs_element: data.mappings?.heavenly_stems?.[annualHs]?.english || 'Unknown',
     eb_animal: data.mappings?.earthly_branches?.[annualEb]?.animal || 'Unknown',
     ten_god_hs: data.hs_yl?.base?.ten_god || 'Unknown',
     ten_god_hidden: {},
     year: data.analysis_info?.year,
     is_current: true,
     disabled: data.hs_yl.disabled || false // Track if it's disabled
    }
    console.log('Annual luck pillar extracted:', annualLuckPillar.value)
   } else {
    annualLuckPillar.value = null
   }
  } else {
   annualLuckPillar.value = null
  }
  
  console.log('chartData.value set with backend interactions, pillarsOrdered:', pillarsOrdered.value)
 } catch (error) {
  console.error('Error generating chart:', error)
  console.error('Error details:', {
   message: error.message,
   stack: error.stack,
   apiUrl: `/api/analyze_bazi?birth_date=${birthDate.value}&birth_time=${encodeURIComponent(birthTime.value || 'unknown')}&gender=${gender.value}`
  })
  if (typeof window !== 'undefined') {
   alert(`Failed to generate chart: ${error.message || 'Unknown error'}. Check console for details.`)
  }
 } finally {
  isLoading.value = false
  console.log('isLoading set to false')
 }
}

function getElementColor(element) {
 const colorMap = {
  'Wood': 'text-green-600',
  'Yang Wood': 'text-green-700',
  'Yin Wood': 'text-green-500',
  'Fire': 'text-red-600',
  'Yang Fire': 'text-red-700',
  'Yin Fire': 'text-red-500',
  'Earth': 'text-yellow-600',
  'Yang Earth': 'text-yellow-700',
  'Yin Earth': 'text-yellow-500',
  'Metal': 'text-gray-600',
  'Yang Metal': 'text-gray-700',
  'Yin Metal': 'text-gray-500',
  'Water': 'text-blue-600',
  'Yang Water': 'text-blue-700',
  'Yin Water': 'text-blue-500'
 }
 return colorMap[element] || 'text-gray-600'
}

// Removed cyber color functions - now using getElementColor

function getElementBgColor(element) {
 const colorMap = {
  'Wood': 'bg-green-500',
  'Fire': 'bg-red-500',
  'Earth': 'bg-yellow-500',
  'Metal': 'bg-gray-500',
  'Water': 'bg-blue-500'
 }
 return colorMap[element] || 'bg-gray-400'
}

// Get node background color using hex colors from API
function getNodeBgColor(elementWithPolarity, apiHexColor = null) {
 // If API provided a hex color, use it directly
 if (apiHexColor) {
  // Handle pure element colors (gradient object)
  if (typeof apiHexColor === 'object' && apiHexColor.bg) {
   // For pure elements, return a special gradient
   if (apiHexColor.bg.includes('gradient')) {
    return { 
     background: 'linear-gradient(to right, #ef4444, #a855f7, #ec4899)',
     border: '2px solid #9333ea'
    }
   }
  }
  
  // Use hex color directly from API
  if (typeof apiHexColor === 'string' && apiHexColor.startsWith('#')) {
   return { backgroundColor: apiHexColor }
  }
 }
 
 // Fallback to element-based colors
 const colorMap = {
  'Yang Wood': '#c2d4be',
  'Yin Wood': '#d6e2bb',
  'Yang Fire': '#f3adae',
  'Yin Fire': '#f5d3b0',
  'Yang Earth': '#e6ceb7',
  'Yin Earth': '#efe3cc',
  'Yang Metal': '#ccd8e6',
  'Yin Metal': '#e6e8f7',
  'Yang Water': '#b9cbff',
  'Yin Water': '#e0e9ff'
 }
 
 const bgColor = colorMap[elementWithPolarity] || '#f9fafb'
 return { backgroundColor: bgColor }
}

// Get element for a stem name
function getStemElement(stemName) {
 const stemElements = {
  'Jia': 'Yang Wood', 'Yi': 'Yin Wood',
  'Bing': 'Yang Fire', 'Ding': 'Yin Fire',
  'Wu': 'Yang Earth', 'Ji': 'Yin Earth',
  'Geng': 'Yang Metal', 'Xin': 'Yin Metal',
  'Ren': 'Yang Water', 'Gui': 'Yin Water'
 }
 return stemElements[stemName] || ''
}


// Get hidden stems with proportional weights based on qi scores
function getHiddenStemsWithWeights(pillar) {
 // Get the appropriate qi data based on view mode
 const ebNode = nodes.value?.[pillar.branchKey]
 
 // Use base_qi in base mode, post_interaction_qi in other modes
 let qiData = null
 if (viewMode.value === 'base' && ebNode?.base_qi) {
  // Use initial qi for base view
  qiData = ebNode.base_qi
 } else if (ebNode?.post_interaction_qi) {
  // Use post_interaction_qi for post-interaction and transformed views
  qiData = ebNode.post_interaction_qi
 } else if (ebNode?.base_qi) {
  // Fallback to base_qi if post_interaction_qi not available
  qiData = ebNode.base_qi
 } else if (pillar.hiddenQi) {
  // Fallback to pillar.hiddenQi (could be object or array)
  qiData = pillar.hiddenQi
 }
 
 // Handle both object format {Yi: 100.0, Jia: 20.0} and array format
 if (qiData) {
  // Convert object to array format if needed
  let qiArray = []
  if (Array.isArray(qiData)) {
   qiArray = qiData
  } else if (typeof qiData === 'object') {
   // Convert {Yi: 100.0, Jia: 20.0} to [{stem: 'Yi', score: 100.0}, ...]
   qiArray = Object.entries(qiData).map(([stem, score]) => ({
    stem,
    score,
    count: 1
   }))
  }
  
 if (qiArray && qiArray.length > 0) {
  const result = {}
  const totalScore = qiArray.reduce((sum, qi) => sum + qi.score, 0)
  
  for (const qi of qiArray) {
   const percentage = Math.round((qi.score / totalScore) * 100)
   // Get ten god for this stem if available
   // Handle both string format and object format
   const tenGodData = pillar.hiddenStems?.[qi.stem]
   const tenGod = typeof tenGodData === 'string' 
    ? tenGodData 
    : tenGodData?.abbreviation || tenGodData?.id || ''
   // Use hex color from API if available, fallback to color, then null
   const stemColor = qi.hex_color || qi.color || null
   result[qi.stem] = { 
    god: tenGod, 
    weight: percentage,
    score: qi.score,
    count: qi.count,
    color: stemColor
   }
  }
  return result
 }
 }
 
 // Fallback to old method using hiddenStems with hardcoded percentages
 if (!pillar.hiddenStems) return {}
 
 // Hardcoded hidden stem percentages based on BaZi traditional values
 // These match the backend's EARTHLY_BRANCH_HIDDEN_QI definitions
 const hiddenStemPercentages = {
  'Zi': { 'Gui': 100 },
  'Chou': { 'Ji': 60, 'Gui': 30, 'Xin': 10 },
  'Yin': { 'Jia': 60, 'Bing': 30, 'Wu': 10 },
  'Mao': { 'Yi': 100 },
  'Chen': { 'Wu': 60, 'Yi': 30, 'Gui': 10 },
  'Si': { 'Bing': 60, 'Wu': 30, 'Geng': 10 },
  'Wu': { 'Ding': 70, 'Ji': 30 },
  'Wei': { 'Ji': 60, 'Ding': 30, 'Yi': 10 },
  'Shen': { 'Geng': 60, 'Ren': 30, 'Wu': 10 },
  'You': { 'Xin': 100 },
  'Xu': { 'Wu': 60, 'Xin': 30, 'Ding': 10 },
  'Hai': { 'Ren': 70, 'Jia': 30 }
 }
 
 // Get the original branch name (before any transformation)
 const branchName = pillar.branchName
 const branchPercentages = hiddenStemPercentages[branchName]
 
 if (!branchPercentages) {
  // Fallback: distribute evenly if branch not found
  const stems = Object.entries(pillar.hiddenStems)
  const result = {}
  const evenWeight = Math.floor(100 / stems.length)
  for (const [stem, tenGod] of stems) {
   result[stem] = { god: tenGod, weight: evenWeight }
  }
  return result
 }
 
 // Use the hardcoded percentages
 const result = {}
 for (const [stem, tenGod] of Object.entries(pillar.hiddenStems)) {
  const percentage = branchPercentages[stem] || 33 // Default if not found
  result[stem] = { god: tenGod, weight: percentage }
 }
 
 return result
}

function getElementBorderColor(element) {
 const colorMap = {
  'Wood': 'border-green-500',
  'Fire': 'border-red-500',
  'Earth': 'border-yellow-500',
  'Metal': 'border-gray-500',
  'Water': 'border-blue-500'
 }
 return colorMap[element] || 'border-gray-400'
}

function getInteractionBorderColor(type) {
 if (type.includes('NATURAL')) return 'border-purple-400'
 if (type.includes('CONFLICT') || type.includes('CLASH') || type.includes('HARM') || type.includes('DESTRUCTION') || type.includes('PUNISHMENT')) return 'border-red-400'
 if (type.includes('COMBINATION') || type.includes('HARMONY')) return 'border-green-400'
 if (type.includes('MEETING')) return 'border-blue-400'
 return 'border-gray-400'
}

// Get subtle left border class for log entries
function getLogBorderClass(type) {
 if (type.includes('NATURAL')) return 'border-l-4 border-l-purple-300'
 if (type.includes('CONFLICT') || type.includes('CLASH') || type.includes('HARM') || type.includes('DESTRUCTION') || type.includes('PUNISHMENT')) return 'border-l-4 border-l-red-300'
 if (type.includes('COMBINATION') || type.includes('HARMONY')) return 'border-l-4 border-l-green-300'
 if (type.includes('MEETING')) return 'border-l-4 border-l-blue-300'
 return 'border-l-4 border-l-gray-300'
}

function getInteractionTextColor(type) {
 if (type.includes('NATURAL')) return 'text-purple-700'
 if (type.includes('CONFLICT') || type.includes('CLASH') || type.includes('HARM') || type.includes('DESTRUCTION') || type.includes('PUNISHMENT')) return 'text-red-700'
 if (type.includes('COMBINATION') || type.includes('HARMONY')) return 'text-green-700'
 if (type.includes('MEETING')) return 'text-blue-700'
 return 'text-gray-700'
}

function formatInteractionType(type) {
 const typeMap = {
  'THREE_MEETINGS': '‰∏âÊúÉ Three Meetings',
  'PUNISHMENTS': 'Áõ∏Âàë Punishments',
  'THREE_COMBINATIONS': '‰∏âÂêà Three Combinations',
  'SIX_HARMONIES': 'ÂÖ≠Âêà Six Harmonies',
  'HALF_COMBINATIONS': 'ÂçäÂêà Half Combinations',
  'HALF_COMBINATION': 'ÂçäÂêà Half Combination',
  'ARCHED_COMBINATIONS': 'Êã±Âêà Arched Combinations',
  'CLASHES': 'Ê≤ñ Clashes',
  'HARMS': 'ÂÆ≥ Harms',
  'DESTRUCTIONS': 'Á†¥ Destructions',
  'DESTRUCTION': 'Á†¥ Destruction',
  'HS_CONFLICT': 'Â§©Âπ≤Ê≤ñ Stem Conflicts',
  'STEM_CONFLICT': 'Â§©Âπ≤Ê≤ñ Stem Conflict',
  'HS_COMBINATION': 'Â§©Âπ≤Âêà Stem Combinations',
  'STEM_COMBINATION': 'Â§©Âπ≤Âêà Stem Combination',
  'NATURAL_GENERATING': 'Áîü Energy Flow (Generation)',
  'NATURAL_CONTROLLING': 'Ââã Energy Flow (Control)',
  'ENERGY_FLOW_GENERATING': 'Áîü Energy Flow (Generation)',
  'ENERGY_FLOW_CONTROLLING': 'Ââã Energy Flow (Control)',
  'ENERGY_FLOW': 'Ê∞£ Energy Flow',
  'SEASONAL_ADJUSTMENT': 'Â≠£ÁØÄË™øÊï¥ Seasonal Adjustment'
 }
 return typeMap[type] || type
}

function formatInteractionDescription(interaction) {
 if (interaction.description) return interaction.description
 
 if (interaction.type === 'HS_CONFLICT' && interaction.conflictor) {
  return `${interaction.conflictor.stem} (conflictor, -${interaction.conflictor.reduction}%) conflicts with ${interaction.conflicted.stem} (conflicted, -${interaction.conflicted.reduction}%)`
 }
 
 if (interaction.relationship) return interaction.relationship
 
 if (interaction.branches) {
  return `Branches: ${interaction.branches.join(', ')}`
 }
 
 if (interaction.stems) {
  return `Stems: ${interaction.stems.join(', ')}`
 }
 
 return ''
}

// Get pre/post element scores for an interaction
function getInteractionElementScores(interaction) {
 if (!chartData.value) return null
 
 // Get base (pre) and post element scores from chartData
 const baseScores = chartData.value.base_element_score || {}
 const postScores = chartData.value.post_element_score || {}
 
 // If no element changes in this interaction, return null
 if (!interaction.element_changes || Object.keys(interaction.element_changes).length === 0) {
  return null
 }
 
 // Build scores object for affected elements
 const scores = {}
 const fiveElements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 
 for (const element of fiveElements) {
  // Get all stems for this element from baseScores
  const stemIds = Object.keys(baseScores).filter(stemId => {
   const mapping = chartData.value.mappings?.heavenly_stems?.[stemId]
   if (!mapping) return false
   const stemElement = mapping.english || ''
   // Match "Yang Fire" or "Yin Fire" to "Fire"
   return stemElement.includes(element)
  })
  
  // Sum up scores for this element
  let preTotal = 0
  let postTotal = 0
  
  for (const stemId of stemIds) {
   preTotal += baseScores[stemId] || 0
   postTotal += postScores[stemId] || 0
  }
  
  // Only include if there's a change
  const change = postTotal - preTotal
  if (Math.abs(change) > 0.1) { // Small threshold to avoid floating point noise
   scores[element] = {
    pre: preTotal,
    post: postTotal,
    change: change
   }
  }
 }
 
 return Object.keys(scores).length > 0 ? scores : null
}

function formatNodeName(node) {
 const nodeMap = {
  'hs_y': 'Year Stem',
  'hs_m': 'Month Stem',
  'hs_d': 'Day Stem',
  'hs_h': 'Hour Stem',
  'hs_10yl': '10-Year Luck Stem',
  'hs_yl': 'Annual Luck Stem',
  'hs_ml': 'Monthly Luck Stem',
  'hs_dl': 'Daily Luck Stem',
  'hs_hl': 'Hourly Luck Stem',
  'eb_y': 'Year Branch',
  'eb_m': 'Month Branch',
  'eb_d': 'Day Branch',
  'eb_h': 'Hour Branch',
  'eb_10yl': '10-Year Luck Branch',
  'eb_yl': 'Annual Luck Branch',
  'eb_ml': 'Monthly Luck Branch',
  'eb_dl': 'Daily Luck Branch',
  'eb_hl': 'Hourly Luck Branch',
  'hs_o1': 'Overseas 1 Stem',
  'eb_o1': 'Overseas 1 Branch',
  'hs_o2': 'Overseas 2 Stem',
  'eb_o2': 'Overseas 2 Branch',
  'hs_b1': 'Birthplace 1 Stem',
  'eb_b1': 'Birthplace 1 Branch',
  'hs_b2': 'Birthplace 2 Stem',
  'eb_b2': 'Birthplace 2 Branch',
  'hs_b3': 'Birthplace 3 Stem',
  'eb_b3': 'Birthplace 3 Branch',
  'hs_b4': 'Birthplace 4 Stem',
  'eb_b4': 'Birthplace 4 Branch'
 }
 return nodeMap[node] || node
}

function getPillarPosition(position) {
 const positions = ['Year', 'Month', 'Day', 'Hour', '10-Year Luck', 'Annual Luck', 'Monthly Luck', 'Daily Luck', 'Hourly Luck']
 return positions[position] || position
}

function getTenGodLabel(element) {
 if (!chartData.value?.daymaster_analysis) return ''
 
 const daymaster = chartData.value.daymaster_analysis.daymaster
 const daymasterElement = daymaster.split(' ')[1] // Get element part
 const daymasterPolarity = daymaster.split(' ')[0] // Get polarity (Yang/Yin)
 const elementName = element.split(' ')[1] // Get element part
 const elementPolarity = element.split(' ')[0] // Get polarity
 
 // WuXing cycle: Wood -> Fire -> Earth -> Metal -> Water -> Wood
 const cycle = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 const dmIndex = cycle.indexOf(daymasterElement)
 const elIndex = cycle.indexOf(elementName)
 
 // Calculate relationship distance
 const distance = (elIndex - dmIndex + 5) % 5
 
 // Determine Ten God based on distance and polarity match
 const polarityMatch = daymasterPolarity === elementPolarity
 
 switch(distance) {
  case 0: // Same element
   return polarityMatch ? 'ÊØîËÇ© Friend' : 'Âä´Ë≤° Rob Wealth'
  case 1: // Element I generate (child)
   return polarityMatch ? 'È£üÁ•û Eating God' : 'ÂÇ∑ÂÆò Hurting Officer'
  case 2: // Element that generates my child (wealth)
   return polarityMatch ? 'ÂÅèË≤° Indirect Wealth' : 'Ê≠£Ë≤° Direct Wealth'
  case 3: // Element that controls me (officer)
   return polarityMatch ? 'ÂÅèÂÆò Seven Killings' : 'Ê≠£ÂÆò Direct Officer'
  case 4: // Element that generates me (resource)
   return polarityMatch ? 'ÂÅèÂç∞ Indirect Resource' : 'Ê≠£Âç∞ Direct Resource'
  default:
   return ''
 }
}

function getElementRelationship(daymasterElement, element) {
 // WuXing cycle relationships
 const cycle = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 const dmIndex = cycle.indexOf(daymasterElement)
 const elIndex = cycle.indexOf(element)
 
 const distance = (elIndex - dmIndex + 5) % 5
 
 switch(distance) {
  case 0:
   return 'Self/Companion'
  case 1:
   return 'Output/Expression'
  case 2:
   return 'Wealth'
  case 3:
   return 'Officer/Status'
  case 4:
   return 'Resource/Support'
  default:
   return ''
 }
}

// Interactive handlers
function handleNodeHover(nodeId, nodeKey) {
 hoveredNode.value = nodeId
 highlightedNodes.value = []
 
 // Find interactions involving this node
 const nodeInteractions = getNodeInteractions(nodeKey)
 
 // Highlight connected nodes
 nodeInteractions.forEach(interaction => {
  if (interaction.nodes) {
   interaction.nodes.forEach(node => {
    if (node !== nodeKey) {
     const nodeIndex = getNodeIndex(node)
     if (nodeIndex !== -1) {
      const nodeType = node.startsWith('hs') ? 'stem' : 'branch'
      highlightedNodes.value.push(`${nodeType}-${nodeIndex}`)
     }
    }
   })
  }
 })
 
 // Show tooltip
 if (nodeInteractions.length > 0) {
  const event = window.event
  tooltipContent.value = {
   title: `${nodeInteractions.length} Interactions`,
   description: nodeInteractions.map(i => formatShortInteraction(i)).join(', '),
   effect: nodeInteractions.some(i => i.effect === 'High') ? 'Strong influence' : 'Moderate influence'
  }
  tooltipPosition.value = {
   x: event.pageX + 10,
   y: event.pageY - 50
  }
 }
}

function handleNodeLeave() {
 hoveredNode.value = null
 highlightedNodes.value = []
 highlightContext.value = null // Clear context
 hoveredTransformationId.value = null // Clear transformation highlight
 tooltipContent.value = null
}

function handleInteractionHover(interaction) {
 hoveredInteraction.value = interaction.id
 highlightedNodes.value = []
 highlightContext.value = interaction // Set context for element-based coloring
 
 // Highlight nodes involved in this interaction
 if (interaction.nodes) {
  interaction.nodes.forEach(node => {
   const nodeIndex = getNodeIndex(node)
   if (nodeIndex !== -1) {
    const nodeType = node.startsWith('hs') ? 'stem' : 'branch'
    highlightedNodes.value.push(`${nodeType}-${nodeIndex}`)
   }
  })
 }
 
 // Show detailed tooltip
 const event = window.event
 tooltipContent.value = {
  title: formatInteractionType(interaction.type),
  description: formatInteractionDescription(interaction),
  effect: interaction.effect || 'Modifies element energies'
 }
 tooltipPosition.value = {
  x: event.pageX + 10,
  y: event.pageY - 50
 }
}

function getTransformBadgeDisplay(badge) {
 if (!badge) return ''
 
 // Map stem IDs to their Chinese characters
 const stemToChinese = {
  'Jia': 'Áî≤', 'Yi': '‰πô', 'Bing': '‰∏ô', 'Ding': '‰∏Å',
  'Wu': 'Êàä', 'Ji': 'Â∑±', 'Geng': 'Â∫ö', 'Xin': 'Ëæõ',
  'Ren': 'Â£¨', 'Gui': 'Áô∏'
 }
 
 // Map pure elements to their Chinese characters
 const elementToChinese = {
  'Wood': 'Êú®', 'Fire': 'ÁÅ´', 'Earth': 'Âúü',
  'Metal': 'Èáë', 'Water': 'Ê∞¥'
 }
 
 // Check if it's a stem ID
 if (stemToChinese[badge]) {
  return stemToChinese[badge]
 }
 
 // Check if it's a pure element
 if (elementToChinese[badge]) {
  return elementToChinese[badge]
 }
 
 // If it contains 'Yang' or 'Yin', extract the element part
 if (badge.includes('Yang') || badge.includes('Yin')) {
  const element = badge.replace('Yang ', '').replace('Yin ', '')
  return elementToChinese[element] || badge
 }
 
 // Default: return as is
 return badge
}

function getTransformBadgeStyle(badge) {
 if (!badge) return {}
 
 // Map stem IDs and elements to their hex colors from the mappings
 const badgeColors = {
  // Heavenly Stems colors
  'Jia': '#c2d4be',  // Yang Wood - Light sage green
  'Yi': '#d6e2bb',   // Yin Wood - Light lime green
  'Bing': '#f3adae',  // Yang Fire - Light coral red
  'Ding': '#f5d3b0',  // Yin Fire - Light peach
  'Wu': '#e6ceb7',   // Yang Earth - Light tan
  'Ji': '#efe3cc',   // Yin Earth - Light cream
  'Geng': '#ccd8e6',  // Yang Metal - Light steel blue
  'Xin': '#e6e8f7',  // Yin Metal - Light lavender
  'Ren': '#b9cbff',  // Yang Water - Light sky blue
  'Gui': '#e0e9ff',  // Yin Water - Light powder blue
  // Pure Elements
  'Wood': '#c9dcc4',  // Average of wood colors
  'Fire': '#f4c0af',  // Average of fire colors
  'Earth': '#ead9c2', // Average of earth colors
  'Metal': '#d9e0f2', // Average of metal colors
  'Water': '#cdd5ff', // Average of water colors
  // Yang/Yin Elements
  'Yang Wood': '#c2d4be',
  'Yin Wood': '#d6e2bb',
  'Yang Fire': '#f3adae',
  'Yin Fire': '#f5d3b0',
  'Yang Earth': '#e6ceb7',
  'Yin Earth': '#efe3cc',
  'Yang Metal': '#ccd8e6',
  'Yin Metal': '#e6e8f7',
  'Yang Water': '#b9cbff',
  'Yin Water': '#e0e9ff'
 }
 
 const bgColor = badgeColors[badge] || '#fbbf24' // Default to yellow if not found
 
 // Calculate a darker text color for contrast
 const textColor = getLightnessPercent(bgColor) > 70 ? '#1f2937' : '#ffffff'
 
 return {
  backgroundColor: bgColor,
  color: textColor,
  border: `2px solid ${adjustBrightness(bgColor, -20)}`,
  boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)'
 }
}

// Helper function to calculate lightness percentage
function getLightnessPercent(hexColor) {
 const hex = hexColor.replace('#', '')
 const r = parseInt(hex.substr(0, 2), 16)
 const g = parseInt(hex.substr(2, 2), 16)
 const b = parseInt(hex.substr(4, 2), 16)
 return (0.299 * r + 0.587 * g + 0.114 * b) / 255 * 100
}

// Helper function to adjust brightness
function adjustBrightness(hexColor, percent) {
 const hex = hexColor.replace('#', '')
 const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + percent * 2.55))
 const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + percent * 2.55))
 const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + percent * 2.55))
 return '#' + [r, g, b].map(x => Math.round(x).toString(16).padStart(2, '0')).join('')
}

// NEW: Multi-transformation badge functions with strength-based styling
function getTransformationBadgeStyles(transformation) {
 if (!transformation) return {}
 
 const { badge, strength, element } = transformation
 
 // Badge colors - same as backend mappings hex_color
 const badgeColors = {
  // Heavenly Stems (from backend mappings)
  'Jia': '#c2d4be',  // Yang Wood - Light sage green
  'Yi': '#d6e2bb',   // Yin Wood - Light lime green
  'Bing': '#f3adae',  // Yang Fire - Light coral red
  'Ding': '#f5d3b0',  // Yin Fire - Light peach
  'Wu': '#e6ceb7',   // Yang Earth - Light tan
  'Ji': '#efe3cc',   // Yin Earth - Light cream
  'Geng': '#ccd8e6',  // Yang Metal - Light steel blue
  'Xin': '#e6e8f7',  // Yin Metal - Light lavender
  'Ren': '#b9cbff',  // Yang Water - Light sky blue
  'Gui': '#e0e9ff',  // Yin Water - Light powder blue
  
  // Pure Elements (averaged colors for direct transformations)
  'Wood': '#c9dcc4',  // Average of wood colors
  'Fire': '#f4c0af',  // Average of fire colors
  'Earth': '#ead9c2', // Average of earth colors
  'Metal': '#d9e0f2', // Average of metal colors
  'Water': '#cdd5ff'  // Average of water colors
 }
 
 const baseBgColor = badgeColors[badge] || badgeColors[element] || '#fbbf24'
 const textColor = getLightnessPercent(baseBgColor) > 70 ? '#1f2937' : '#ffffff'
 const borderColor = adjustBrightness(baseBgColor, -20)
 
 // Strength differentiation: SIZE (via CSS class) + GLOW only
 const strengthStyles = {
  ultra_strong: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px solid ${borderColor}`,
   boxShadow: `0 0 10px ${baseBgColor}, 0 2px 4px rgba(0, 0, 0, 0.1)`, // Strong glow
   opacity: 1
  },
  strong: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px solid ${borderColor}`,
   boxShadow: `0 0 6px ${baseBgColor}, 0 2px 4px rgba(0, 0, 0, 0.1)`, // Medium glow
   opacity: 1
  },
  normal: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px solid ${borderColor}`,
   boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)', // Subtle shadow only
   opacity: 1
  },
  weak: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px solid ${borderColor}`,
   boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)',
   opacity: 0.7
  }
 }
 
 const style = strengthStyles[strength] || strengthStyles.normal
 
 return {
  backgroundColor: style.bgColor,
  color: style.textColor,
  border: style.border,
  boxShadow: style.boxShadow,
  opacity: style.opacity
 }
}

function getTransformationSizeClass(strength) {
 const sizeClasses = {
  ultra_strong: 'w-8 h-8 text-xs',   // 32px
  strong: 'w-7 h-7 text-[11px]',    // 28px
  normal: 'w-6 h-6 text-[10px]',    // 24px (current default)
  weak: 'w-5 h-5 text-[9px]'      // 20px
 }
 return sizeClasses[strength] || sizeClasses.normal
}

function getStrengthIndicator(strength) {
 const indicators = {
  ultra_strong: '‚òÖ‚òÖ', // 2 stars
  strong: '‚òÖ',     // 1 star
  normal: '‚óè',     // Filled dot
  weak: '‚óã'      // Hollow dot
 }
 return indicators[strength] || indicators.normal
}

// Combination badge size classes
function getCombinationBadgeSizeClass(strength) {
 const sizeClasses = {
  ultra_strong: 'w-6 h-6 text-xs',      // 24px
  strong: 'w-5 h-5 text-[10px]',        // 20px
  normal: 'w-4 h-4 text-[8px]',         // 16px (default)
  weak: 'w-3 h-3 text-[7px]'            // 12px
 }
 return sizeClasses[strength] || sizeClasses.normal
}

// Combination badge styling
function getCombinationBadgeStyle(combination) {
 if (!combination) return {}
 
 const { badge, element } = combination
 
 // Use same base colors with subtle styling for combinations
 const badgeColors = {
  'Jia': '#c2d4be', 'Yi': '#d6e2bb', 'Bing': '#f3adae', 'Ding': '#f5d3b0',
  'Wu': '#e6ceb7', 'Ji': '#efe3cc', 'Geng': '#ccd8e6', 'Xin': '#e6e8f7',
  'Ren': '#b9cbff', 'Gui': '#e0e9ff',
  'Wood': '#c9dcc4', 'Fire': '#f4c0af', 'Earth': '#ead9c2',
  'Metal': '#d9e0f2', 'Water': '#cdd5ff'
 }
 
 const baseBgColor = badgeColors[badge] || badgeColors[element] || '#e5e7eb'
 const textColor = '#6b7280' // Gray-500 for subtle effect
 
 return {
  backgroundColor: baseBgColor,
  color: textColor,
  border: `1.5px dashed ${adjustBrightness(baseBgColor, -30)}`,
  boxShadow: 'none',
  opacity: 0.6,
  background: `repeating-linear-gradient(45deg, ${baseBgColor}, ${baseBgColor} 2px, ${adjustBrightness(baseBgColor, -5)} 2px, ${adjustBrightness(baseBgColor, -5)} 4px)`
 }
}

function getCombinationTooltip(combination) {
 if (!combination) return ''
 
 // Get full interaction data from chartData using interaction_id
 const fullInteraction = getFullInteractionData(combination)
 
 const typeLabels = {
  THREE_MEETINGS: '‰∏âÊúÉ (Three Meetings)',
  THREE_COMBINATIONS: '‰∏âÂêà (Three Combinations)',
  SIX_HARMONIES: 'ÂÖ≠Âêà (Six Harmonies)',
  HALF_COMBINATIONS: 'ÂçäÂêà (Half Combinations)',
  ARCHED_COMBINATIONS: 'Êã±Âêà (Arched Combinations)',
  STEM_COMBINATION: 'Â§©Âπ≤Âêà (Stem Combination)'
 }
 
 let tooltip = `${typeLabels[combination.type] || combination.type}\n` +
     `Pattern: ${combination.pattern || fullInteraction.pattern || 'N/A'}\n` +
     `‚Üí ${combination.element || fullInteraction.element || 'Partial transformation'}`
 
 // Add detailed debugging information from full interaction data
 if (fullInteraction) {
  tooltip += `\n\n‚îÅ‚îÅ‚îÅ Debug Info ‚îÅ‚îÅ‚îÅ`
  
  // Interaction ID first
  if (combination.interaction_id) {
   tooltip += `\nInteraction ID: ${combination.interaction_id}`
  }
  
  if (fullInteraction.nodes && fullInteraction.nodes.length > 0) {
   tooltip += `\nNodes: ${fullInteraction.nodes.join(', ')}`
  }
  
  if (fullInteraction.distance !== undefined) {
   tooltip += `\nDistance: ${fullInteraction.distance}`
  }
  
  if (fullInteraction.transformed !== undefined) {
   tooltip += `\nTransformed: ${fullInteraction.transformed ? 'Yes' : 'No'}`
  }
  
  if (fullInteraction.branches && fullInteraction.branches.length > 0) {
   tooltip += `\nBranches: ${fullInteraction.branches.join(', ')}`
  }
  
  if (fullInteraction.stems && fullInteraction.stems.length > 0) {
   tooltip += `\nStems: ${fullInteraction.stems.join(', ')}`
  }
  
  // Show any additional fields that might exist
  const knownFields = ['type', 'pattern', 'nodes', 'positions', 'transformed', 'element', 'distance', 'branches', 'stems', 'stage', 'effect', 'description']
  Object.keys(fullInteraction).forEach(key => {
   if (!knownFields.includes(key) && fullInteraction[key] !== undefined && fullInteraction[key] !== null) {
    tooltip += `\n${key}: ${JSON.stringify(fullInteraction[key])}`
   }
  })
 }
 
 return tooltip
}

// Negative badge functions - same as transformations, just display the badge character
// Helper to get Chinese character for stem name (for hidden stems display)
function getStemChinese(stemName) {
 const stemToChinese = {
  'Jia': 'Áî≤', 'Yi': '‰πô', 'Bing': '‰∏ô', 'Ding': '‰∏Å',
  'Wu': 'Êàä', 'Ji': 'Â∑±', 'Geng': 'Â∫ö', 'Xin': 'Ëæõ',
  'Ren': 'Â£¨', 'Gui': 'Áô∏'
 }
 return stemToChinese[stemName] || ''
}

function getNegativeBadgeSymbol(negative) {
 if (!negative || !negative.badge) return '‚óè'
 
 // Map stem IDs to their Chinese characters (same as getTransformBadgeDisplay)
 const stemToChinese = {
  'Jia': 'Áî≤', 'Yi': '‰πô', 'Bing': '‰∏ô', 'Ding': '‰∏Å',
  'Wu': 'Êàä', 'Ji': 'Â∑±', 'Geng': 'Â∫ö', 'Xin': 'Ëæõ',
  'Ren': 'Â£¨', 'Gui': 'Áô∏'
 }
 
 // Map branch IDs to their Chinese characters
 const branchToChinese = {
  'Zi': 'Â≠ê', 'Chou': '‰∏ë', 'Yin': 'ÂØÖ', 'Mao': 'ÂçØ',
  'Chen': 'Ëæ∞', 'Si': 'Â∑≥', 'Wu': 'Âçà', 'Wei': 'Êú™',
  'Shen': 'Áî≥', 'You': 'ÈÖâ', 'Xu': 'Êàå', 'Hai': '‰∫•'
 }
 
 // Map pure elements to their Chinese characters
 const elementToChinese = {
  'Wood': 'Êú®', 'Fire': 'ÁÅ´', 'Earth': 'Âúü',
  'Metal': 'Èáë', 'Water': 'Ê∞¥'
 }
 
 // Map special negative interaction symbols
 const specialSymbols = {
  'KE': 'Ââã'  // Stem conflict control/restrain symbol
 }
 
 return stemToChinese[negative.badge] || 
        branchToChinese[negative.badge] || 
        elementToChinese[negative.badge] || 
        specialSymbols[negative.badge] ||
        negative.badge
}

function getNegativeBadgeSizeClass(strength) {
 const sizeClasses = {
  ultra_strong: 'w-6 h-6 text-[10px]',      // 24px container, smaller text
  strong: 'w-5 h-5 text-[8px]',            // 20px container, smaller text
  normal: 'w-4 h-4 text-[7px]',            // 16px container, smaller text
  weak: 'w-3 h-3 text-[6px]'               // 12px container, smaller text
 }
 return sizeClasses[strength] || sizeClasses.normal
}

function getNegativeBadgeStyle(negative) {
 if (!negative) return {}
 
 const { badge, type, strength } = negative
 
 // Use the same color mapping as transformations - exact hex from mappings
 const badgeColors = {
  // Heavenly Stems (from backend mappings)
  'Jia': '#c2d4be',  'Yi': '#d6e2bb',
  'Bing': '#f3adae', 'Ding': '#f5d3b0',
  'Wu': '#e6ceb7',   'Ji': '#efe3cc',
  'Geng': '#ccd8e6', 'Xin': '#e6e8f7',
  'Ren': '#b9cbff',  'Gui': '#e0e9ff',
  
  // Earthly Branches
  'Zi': '#b9cbff',   'Chou': '#e6ceb7',
  'Yin': '#c2d4be',  'Mao': '#d6e2bb',
  'Chen': '#e6ceb7', 'Si': '#f3adae',
  'Wu': '#f3adae',   'Wei': '#efe3cc',
  'Shen': '#ccd8e6', 'You': '#e6e8f7',
  'Xu': '#e6ceb7',   'Hai': '#e0e9ff',
  
  // Pure Elements (fallback)
  'Wood': '#c9dcc4', 'Fire': '#f4c0af', 'Earth': '#ead9c2',
  'Metal': '#d9e0f2', 'Water': '#cdd5ff',
  
  // Special negative interaction symbols
  'KE': 'transparent'  // Stem conflict - neutral transparent for control/restrain
 }
 
 const baseBgColor = badgeColors[badge] || badgeColors['Earth'] || '#fbbf24'
 // Special handling for transparent KE badge - use black text
 const textColor = badge === 'KE' ? '#000000' : (getLightnessPercent(baseBgColor) > 70 ? '#1f2937' : '#ffffff')
 const borderColor = badge === 'KE' ? '#000000' : adjustBrightness(baseBgColor, -20)
 
 // Type-based border styling (different visual flair for each type)
 const typeStyles = {
  'clash': {
   borderStyle: 'solid',
   borderWidth: '3px',
   shape: 'square'  // Square with sharp corners
  },
  'harm': {
   borderStyle: 'dashed',
   borderWidth: '2.5px',
   shape: 'square'
  },
  'punishment': {
   borderStyle: 'double',
   borderWidth: '3px',
   shape: 'square'
  },
  'destruction': {
   borderStyle: 'dotted',
   borderWidth: '3px',
   shape: 'square'
  },
  'stem_conflict': {
   borderStyle: 'solid',
   borderWidth: '3px',
   shape: 'square'  // Stem conflict (Â§©Âπ≤Ê≤ñ)
  }
 }
 
 const typeStyle = typeStyles[type] || typeStyles.clash
 
 // Strength-based glow intensity (similar to transformations)
 const strengthStyles = {
  ultra_strong: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `${typeStyle.borderWidth} ${typeStyle.borderStyle} ${borderColor}`,
   boxShadow: `0 0 12px ${baseBgColor}, 0 4px 6px rgba(0, 0, 0, 0.2)`,
   opacity: 1
  },
  strong: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `${typeStyle.borderWidth} ${typeStyle.borderStyle} ${borderColor}`,
   boxShadow: `0 0 8px ${baseBgColor}, 0 2px 4px rgba(0, 0, 0, 0.15)`,
   opacity: 1
  },
  normal: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px ${typeStyle.borderStyle} ${borderColor}`,
   boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
   opacity: 1
  },
  weak: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px ${typeStyle.borderStyle} ${borderColor}`,
   boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)',
   opacity: 0.8
  }
 }
 
 const style = strengthStyles[strength] || strengthStyles.normal
 
 return {
  backgroundColor: style.bgColor,
  color: style.textColor,
  border: style.border,
  boxShadow: style.boxShadow,
  opacity: style.opacity,
  borderRadius: '0'  // Square with sharp edges
 }
}

// Helper function to fetch full interaction data from chartData using interaction_id
function getFullInteractionData(badge) {
 if (!badge || !badge.interaction_id || !chartData.value?.interactions) {
  return {}
 }
 
 // Try direct lookup first
 let interaction = chartData.value.interactions[badge.interaction_id]
 if (interaction) return interaction
 
 // If not found, try normalizing the interaction_id
 // Badge format examples: HS_COMBINATION_Ding-Ren_hs_h-hs_y, SIX_HARMONIES_Si-Shen_eb_h-eb_y
 // Interaction key examples: STEM_COMBINATION~Ding-Ren~hs_h-hs_y, SIX_HARMONIES~Si-Shen~eb_h-eb_y
 
 let normalizedId = badge.interaction_id
 
 // Replace HS_COMBINATION with STEM_COMBINATION
 normalizedId = normalizedId.replace('HS_COMBINATION', 'STEM_COMBINATION')
 
 // Try replacing underscores with tildes for the key format
 const parts = normalizedId.split('_')
 if (parts.length >= 3) {
  // Find where the pattern starts (after type, before nodes)
  const type = parts[0]
  
  // Check if it's a compound type like THREE_MEETINGS, STEM_COMBINATION, etc.
  let typeEndIndex = 1
  const compoundTypes = ['THREE_MEETINGS', 'THREE_COMBINATIONS', 'SIX_HARMONIES', 'HALF_COMBINATIONS', 
              'ARCHED_COMBINATIONS', 'STEM_COMBINATION', 'STEM_CONFLICT']
  
  for (const compoundType of compoundTypes) {
   if (normalizedId.startsWith(compoundType)) {
    typeEndIndex = compoundType.split('_').length
    break
   }
  }
  
  const typeParts = parts.slice(0, typeEndIndex)
  const restParts = parts.slice(typeEndIndex)
  
  // Find where pattern ends (look for node pattern like hs_ or eb_)
  let patternEndIndex = 0
  for (let i = 0; i < restParts.length; i++) {
   if (restParts[i].match(/^(hs|eb)$/)) {
    patternEndIndex = i
    break
   }
  }
  
  if (patternEndIndex > 0) {
   const pattern = restParts.slice(0, patternEndIndex).join('-')
   const nodes = restParts.slice(patternEndIndex).join('_')
   normalizedId = `${typeParts.join('_')}~${pattern}~${nodes}`
  }
 }
 
 // Try the normalized lookup
 interaction = chartData.value.interactions[normalizedId]
 if (interaction) return interaction
 
 // If still not found, try iterating through all interactions to find a match
 for (const [key, value] of Object.entries(chartData.value.interactions)) {
  if (key.includes(badge.pattern) || badge.interaction_id.includes(key)) {
   // Check if nodes match
   if (value.nodes && badge.interaction_id) {
    const badgeNodes = badge.interaction_id.match(/(hs|eb)_[a-z0-9]+/g) || []
    const matchingNodes = badgeNodes.filter(node => value.nodes.includes(node))
    if (matchingNodes.length >= 2) {
     return value
    }
   }
  }
 }
 
 return {}
}

function getNegativeBadgeTooltip(negative) {
 if (!negative) return ''
 
 // Get full interaction data from chartData using interaction_id
 const fullInteraction = getFullInteractionData(negative)
 
 const typeLabels = {
  'clash': 'Ê≤ñ (Clash)',
  'harm': 'ÂÆ≥ (Harm)',
  'punishment': 'Âàë (Punishment)',
  'destruction': 'Á†¥ (Destruction)',
  'stem_conflict': 'Ââã (Stem Conflict)',
  'CLASHES': 'Ê≤ñ (Clash)',
  'HARMS': 'ÂÆ≥ (Harm)',
  'PUNISHMENTS': 'Âàë (Punishment)',
  'DESTRUCTIONS': 'Á†¥ (Destruction)',
  'STEM_CONFLICT': 'Â§©Âπ≤Ê≤ñ (Stem Conflict)'
 }
 
 const strengthLabels = {
  ultra_strong: 'Severe',
  strong: 'Strong',
  normal: 'Moderate',
  weak: 'Weak'
 }
 
 let tooltip = `‚ö†Ô∏è ${typeLabels[negative.type] || negative.type}\n` +
     `Pattern: ${negative.pattern || fullInteraction.pattern || 'N/A'}\n` +
     `Severity: ${strengthLabels[negative.strength] || negative.strength}\n` +
     `Negative influence on energies`
 
 // Add detailed debugging information from full interaction data
 if (fullInteraction && Object.keys(fullInteraction).length > 0) {
  tooltip += `\n\n‚îÅ‚îÅ‚îÅ Debug Info ‚îÅ‚îÅ‚îÅ`
  
  // Interaction ID first
  if (negative.interaction_id) {
   tooltip += `\nInteraction ID: ${negative.interaction_id}`
  }
  
  if (fullInteraction.nodes && fullInteraction.nodes.length > 0) {
   tooltip += `\nNodes: ${fullInteraction.nodes.join(', ')}`
  }
  
  if (fullInteraction.distance !== undefined) {
   tooltip += `\nDistance: ${fullInteraction.distance}`
  }
  
  if (fullInteraction.element !== undefined) {
   tooltip += `\nElement: ${fullInteraction.element}`
  }
  
  if (fullInteraction.branches && fullInteraction.branches.length > 0) {
   tooltip += `\nBranches: ${fullInteraction.branches.join(', ')}`
  }
  
  if (fullInteraction.stems && fullInteraction.stems.length > 0) {
   tooltip += `\nStems: ${fullInteraction.stems.join(', ')}`
  }
  
  if (fullInteraction.reduction_percentage !== undefined) {
   tooltip += `\nReduction: ${fullInteraction.reduction_percentage}%`
  }
  
  // Show any additional fields that might exist
  const knownFields = ['type', 'pattern', 'nodes', 'positions', 'element', 'distance', 'branches', 'stems', 'stage', 'effect', 'description', 'reduction_percentage', 'transformed']
  Object.keys(fullInteraction).forEach(key => {
   if (!knownFields.includes(key) && fullInteraction[key] !== undefined && fullInteraction[key] !== null) {
    tooltip += `\n${key}: ${JSON.stringify(fullInteraction[key])}`
   }
  })
 }
 
 return tooltip
}

function getTransformationTooltip(transformation) {
 if (!transformation) return ''
 
 // Get full interaction data from chartData using interaction_id
 const fullInteraction = getFullInteractionData(transformation)
 
 const typeLabels = {
  THREE_MEETINGS: '‰∏âÊúÉ (Three Meetings)',
  THREE_COMBINATIONS: '‰∏âÂêà (Three Combinations)',
  SIX_HARMONIES: 'ÂÖ≠Âêà (Six Harmonies)',
  HALF_COMBINATIONS: 'ÂçäÂêà (Half Combinations)',
  ARCHED_COMBINATIONS: 'Êã±Âêà (Arched Combinations)',
  STEM_COMBINATION: 'Â§©Âπ≤Âêà (Stem Combination)'
 }
 
 const strengthLabels = {
  ultra_strong: 'Ultra Strong - Seasonal Directional',
  strong: 'Strong - Triangular Combo',
  normal: 'Normal - Pair Combo',
  weak: 'Weak - Partial Combo'
 }
 
 let tooltip = `${typeLabels[transformation.type] || transformation.type}\n` +
     `Pattern: ${transformation.pattern || fullInteraction.pattern || 'N/A'}\n` +
     `‚Üí ${transformation.element || fullInteraction.element || 'N/A'}\n` +
     `Strength: ${strengthLabels[transformation.strength] || transformation.strength}`
 
 // Add detailed debugging information from full interaction data
 if (fullInteraction) {
  tooltip += `\n\n‚îÅ‚îÅ‚îÅ Debug Info ‚îÅ‚îÅ‚îÅ`
  
  // Interaction ID first
  if (transformation.interaction_id) {
   tooltip += `\nInteraction ID: ${transformation.interaction_id}`
  }
  
  if (fullInteraction.nodes && fullInteraction.nodes.length > 0) {
   tooltip += `\nNodes: ${fullInteraction.nodes.join(', ')}`
  }
  
  if (fullInteraction.distance !== undefined) {
   tooltip += `\nDistance: ${fullInteraction.distance}`
  }
  
  if (fullInteraction.transformed !== undefined) {
   tooltip += `\nTransformed: ${fullInteraction.transformed ? 'Yes' : 'No'}`
  }
  
  if (fullInteraction.branches && fullInteraction.branches.length > 0) {
   tooltip += `\nBranches: ${fullInteraction.branches.join(', ')}`
  }
  
  if (fullInteraction.stems && fullInteraction.stems.length > 0) {
   tooltip += `\nStems: ${fullInteraction.stems.join(', ')}`
  }
  
  // Show any additional fields that might exist
  const knownFields = ['type', 'pattern', 'nodes', 'positions', 'transformed', 'element', 'distance', 'branches', 'stems', 'stage', 'effect', 'description']
  Object.keys(fullInteraction).forEach(key => {
   if (!knownFields.includes(key) && fullInteraction[key] !== undefined && fullInteraction[key] !== null) {
    tooltip += `\n${key}: ${JSON.stringify(fullInteraction[key])}`
   }
  })
 }
 
 return tooltip
}

// NEW: Get highlight ring class based on interaction context
function getNodeHighlightClass(nodeId) {
 if (!highlightedNodes.value.includes(nodeId)) return ''
 
 const context = highlightContext.value
 if (!context) return 'ring-1 ring-blue-400' // Default subtle blue
 
 // Check if negative interaction (exact type match to avoid false positives)
 const isNegative = context.type && (
  context.type === 'CLASHES' ||
  context.type === 'HARMS' ||
  context.type === 'DESTRUCTION' ||
  context.type === 'DESTRUCTIONS' ||
  context.type === 'PUNISHMENTS' ||
  context.type === 'STEM_CONFLICT' ||
  context.type === 'clash' ||
  context.type === 'harm' ||
  context.type === 'destruction' ||
  context.type === 'punishment'
 )
 
 if (isNegative) {
  // White border for negative interactions
  return 'ring-1 ring-white'
 }
 
 // Element-based colors for positive interactions (transformations/combinations)
 const element = context.element || context.pattern?.split('-').pop() // Try to extract element
 
 // Get polarity - check if node is Yang or Yin based on node ID
 const isYangNode = nodeId.includes('stem') ? 
  isYangStem(nodeId) : isYangBranch(nodeId)
 
 // Element color mapping with polarity
 const elementColors = {
  'Fire': isYangNode ? 'ring-red-500' : 'ring-orange-400',
  'Water': isYangNode ? 'ring-blue-600' : 'ring-blue-300',
  'Wood': isYangNode ? 'ring-green-600' : 'ring-green-300',
  'Metal': isYangNode ? 'ring-gray-500' : 'ring-gray-300',
  'Earth': isYangNode ? 'ring-yellow-700' : 'ring-yellow-400'
 }
 
 const ringColor = elementColors[element] || 'ring-blue-400'
 return `ring-1 ${ringColor}`
}

// Helper: Check if stem is Yang
function isYangStem(nodeId) {
 const yangStems = ['Jia', 'Bing', 'Wu', 'Geng', 'Ren']
 // Extract stem name from pillar data
 const index = parseInt(nodeId.split('-')[1])
 if (isNaN(index) || !pillarsOrdered.value || index >= pillarsOrdered.value.length) return true
 const stemName = pillarsOrdered.value[index]?.stemName || ''
 return yangStems.includes(stemName)
}

// Helper: Check if branch is Yang
function isYangBranch(nodeId) {
 const yangBranches = ['Zi', 'Yin', 'Chen', 'Wu', 'Shen', 'Xu']
 // Extract branch name from pillar data
 const index = parseInt(nodeId.split('-')[1])
 if (isNaN(index) || !pillarsOrdered.value || index >= pillarsOrdered.value.length) return true
 const branchName = pillarsOrdered.value[index]?.branchName || ''
 return yangBranches.includes(branchName)
}

// Handle badge hover - highlight involved nodes and related badges
function handleBadgeHover(badge) {
 if (!badge || !badge.interaction_id) return
 
 // Set context for element-based coloring
 highlightContext.value = badge
 hoveredTransformationId.value = badge.interaction_id // Track which badge is hovered
 highlightedNodes.value = []
 
 // Extract node IDs from interaction_id using regex
 // Matches patterns like: hs_y, eb_m, hs_10yl, eb_yl, etc.
 const nodeIdPattern = /(hs|eb)_[a-z0-9]+/g
 const matches = badge.interaction_id.match(nodeIdPattern)
 
 if (!matches) return
 
 // Convert to display format and highlight
 matches.forEach(nodeId => {
  const nodeIndex = getNodeIndex(nodeId)
  if (nodeIndex !== -1) {
   const nodeType = nodeId.startsWith('hs') ? 'stem' : 'branch'
   highlightedNodes.value.push(`${nodeType}-${nodeIndex}`)
  }
 })
}

// Check if a badge should be highlighted (same transformation group)
function isBadgeHighlighted(transformation) {
 if (!transformation || !hoveredTransformationId.value) return false
 return transformation.interaction_id === hoveredTransformationId.value
}

function handleInteractionLeave() {
 hoveredInteraction.value = null
 highlightedNodes.value = []
 highlightContext.value = null // Clear context
 hoveredTransformationId.value = null // Clear transformation highlight
 tooltipContent.value = null
}

function getNodeInteractions(nodeKey) {
 if (!interactions.value) return []
 return interactions.value.filter(i => i.nodes && i.nodes.includes(nodeKey))
}

function getNonNaturalInteractions(nodeKey) {
 if (!interactions.value) return []
 return interactions.value.filter(i => {
  if (!i.nodes || !i.nodes.includes(nodeKey)) return false
  return !i.type.includes('NATURAL')
 })
}

// Removed unused functions: getPillarInteractions, getPillarInteractionData, getPillarInteractionText

function getEnergyFlowBetweenNodes(node1, node2, isHeavenlyStem = false) {
 if (!interactions.value || !node1 || !node2) return null
 
 // Look for ENERGY_FLOW interactions that involve these nodes
 for (const interaction of interactions.value) {
  if (!interaction.type?.includes('ENERGY_FLOW')) continue
  
  const desc = interaction.description || ''
  
  // Check if this interaction involves our nodes
  if (desc.includes(node1) && desc.includes(node2)) {
   if (interaction.type === 'ENERGY_FLOW_GENERATING') {
    // Check direction from description
    if (desc.includes(`${node1} exhausts`) || desc.includes(`${node1} uses`)) {
     return '‚Üí' // node1 generates for node2
    } else if (desc.includes(`${node2} exhausts`) || desc.includes(`${node2} uses`)) {
     return '‚Üê' // node2 generates for node1
    }
   } else if (interaction.type === 'ENERGY_FLOW_CONTROLLING') {
    // Check direction from description
    if (desc.includes(`${node1} uses energy`) && desc.includes(`control ${node2}`)) {
     return '‚á¢' // node1 controls node2
    } else if (desc.includes(`${node2} uses energy`) && desc.includes(`control ${node1}`)) {
     return '‚á†' // node2 controls node1
    }
   }
  }
 }
 
 return null
}

function getWuXingRelation(element1, element2) {
 // Extract base element names (remove Yang/Yin)
 const elem1 = element1.split(' ').pop()
 const elem2 = element2.split(' ').pop()
 
 const cycle = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 const idx1 = cycle.indexOf(elem1)
 const idx2 = cycle.indexOf(elem2)
 
 if (idx1 === -1 || idx2 === -1) return null
 
 // Check if elem1 generates elem2
 if ((idx1 + 1) % 5 === idx2) {
  return '‚Üí' // Generation arrow
 }
 
 // Check if elem1 controls elem2
 if ((idx1 + 2) % 5 === idx2) {
  return '‚á¢' // Control arrow pointing right
 }
 
 // Check if elem2 generates elem1
 if ((idx2 + 1) % 5 === idx1) {
  return '‚Üê' // Being generated (reverse arrow)
 }
 
 // Check if elem2 controls elem1
 if ((idx2 + 2) % 5 === idx1) {
  return '‚á†' // Being controlled arrow pointing left
 }
 
 return null
}

function getWuXingRelationClass(element1, element2) {
 const relation = getWuXingRelation(element1, element2)
 
 switch(relation) {
  case '‚Üí': // Generation forward
  case '‚Üê': // Generation backward
   return 'text-green-600'
  case '‚á¢': // Control right
  case '‚á†': // Control left
   return 'text-red-600'
  default:
   return 'text-gray-600'
 }
}


function getVerticalWuXingRelation(stemElement, branchElement) {
 // Extract base element names (remove Yang/Yin)
 const stem = stemElement.split(' ').pop()
 const branch = branchElement.split(' ').pop()
 
 const cycle = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 const stemIdx = cycle.indexOf(stem)
 const branchIdx = cycle.indexOf(branch)
 
 if (stemIdx === -1 || branchIdx === -1) return null
 
 // Check if stem generates branch (energy flows down)
 if ((stemIdx + 1) % 5 === branchIdx) {
  return '‚Üì' // Down arrow - stem generating branch
 }
 
 // Check if stem controls branch (energy suppresses down)
 if ((stemIdx + 2) % 5 === branchIdx) {
  return '‚á£' // Control arrow pointing down
 }
 
 // Check if branch generates stem (energy flows up)
 if ((branchIdx + 1) % 5 === stemIdx) {
  return '‚Üë' // Up arrow - branch generating stem
 }
 
 // Check if branch controls stem (energy suppresses up)
 if ((branchIdx + 2) % 5 === stemIdx) {
  return '‚á°' // Control arrow pointing up
 }
 
 return null
}

function getVerticalWuXingClass(stemElement, branchElement) {
 const relation = getVerticalWuXingRelation(stemElement, branchElement)
 
 switch(relation) {
  case '‚Üì': // Stem generating branch (down)
  case '‚Üë': // Branch generating stem (up)
   return 'text-green-600'
  case '‚á£': // Control down
  case '‚á°': // Control up
   return 'text-red-600'
  default:
   return 'text-gray-600'
 }
}

function getNodeIndex(nodeKey) {
 // Map to display order: Hour, Day, Month, Year, 10Y Luck, Annual, Monthly, Daily, Hourly (left to right)
 const pillarMap = { 'h': 0, 'd': 1, 'm': 2, 'y': 3, '10yl': 4, 'yl': 5, 'ml': 6, 'dl': 7, 'hl': 8 }
 
 // Extract pillar type from node ID (e.g., "hs_h" -> "h", "eb_10yl" -> "10yl", "hs_yl" -> "yl", "hs_ml" -> "ml")
 const parts = nodeKey.split('_')
 const pillarType = parts.length > 2 ? parts.slice(1).join('_') : parts[1]
 
 return pillarMap[pillarType] ?? -1
}

function formatShortInteraction(interaction) {
 const typeMap = {
  'THREE_MEETINGS': '‰∏âÊúÉ',
  'PUNISHMENTS': 'Âàë',
  'THREE_COMBINATIONS': '‰∏âÂêà',
  'SIX_HARMONIES': 'ÂÖ≠Âêà',
  'HALF_COMBINATIONS': 'ÂçäÂêà',
  'ARCHED_COMBINATIONS': 'Êã±Âêà',
  'CLASHES': 'Ê≤ñ',
  'HARMS': 'ÂÆ≥',
  'DESTRUCTIONS': 'Á†¥',
  'HS_CONFLICT': 'Â§©Âπ≤Ê≤ñ',
  'HS_COMBINATION': 'Â§©Âπ≤Âêà',
  'NATURAL_GENERATING': 'Áîü',
  'NATURAL_CONTROLLING': 'Ââã'
 }
 return typeMap[interaction.type] || interaction.type
}

// Interaction highlighting functions
function highlightInteraction(interaction) {
 highlightedInteraction.value = interaction
 highlightedNodes.value = []
 highlightContext.value = interaction // Set context for element-based coloring
 
 // Highlight nodes in the chart based on interaction
 if (interaction.type === 'HS_CONFLICT') {
  // For HS_CONFLICT, add both conflictor and conflicted nodes
  if (interaction.conflictor?.node) {
   const nodeIndex = getNodeIndex(interaction.conflictor.node)
   if (nodeIndex !== -1) {
    highlightedNodes.value.push(`stem-${nodeIndex}`)
   }
  }
  if (interaction.conflicted?.node) {
   const nodeIndex = getNodeIndex(interaction.conflicted.node)
   if (nodeIndex !== -1) {
    highlightedNodes.value.push(`stem-${nodeIndex}`)
   }
  }
 } else if (interaction.nodes) {
  // For other interactions, use the nodes array
  interaction.nodes.forEach(node => {
   const nodeIndex = getNodeIndex(node)
   if (nodeIndex !== -1) {
    const nodeType = node.startsWith('hs') ? 'stem' : 'branch'
    highlightedNodes.value.push(`${nodeType}-${nodeIndex}`)
   }
  })
 }
}

function clearHighlight() {
 highlightedInteraction.value = null
 highlightedNodes.value = []
 highlightContext.value = null // Clear context
 hoveredTransformationId.value = null // Clear transformation highlight
}



function isInteractionHighlighted(interaction) {
 // Check if this interaction is highlighted
 const current = highlightedInteraction.value
 if (!current) return false
 
 // Direct reference match
 if (current === interaction) return true
 
 // Special handling for HS_CONFLICT - match if same stems are involved
 if (current.type === 'HS_CONFLICT' && interaction.type === 'HS_CONFLICT') {
  // Get the stems involved in both interactions
  const currentStems = []
  if (current.conflictor?.node) currentStems.push(current.conflictor.node)
  if (current.conflicted?.node) currentStems.push(current.conflicted.node)
  
  const interactionStems = []
  if (interaction.conflictor?.node) interactionStems.push(interaction.conflictor.node)
  if (interaction.conflicted?.node) interactionStems.push(interaction.conflicted.node)
  
  // Check if they involve the same stems (regardless of order)
  const currentSorted = currentStems.sort().join(',')
  const interactionSorted = interactionStems.sort().join(',')
  return currentSorted === interactionSorted
 }
 
 // Check if they have the same nodes (for highlighting related boxes)
 if (current.nodes && interaction.nodes) {
  const currentNodes = current.nodes.sort().join(',')
  const interactionNodes = interaction.nodes.sort().join(',')
  return currentNodes === interactionNodes
 }
 
 return false
}
</script>