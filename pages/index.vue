<template>
 <div class="min-h-screen bg-gray-50">
  
  <!-- Header -->
  <header class="bg-white border-b border-gray-200">
   <div class="max-w-7xl mx-auto px-4 py-4 flex items-center gap-4">
    <img 
     src="/bazingse-logo.png" 
     alt="BaZingSe Logo" 
     class="w-12 h-12 object-contain"
    />
    <div>
     <h1 class="text-2xl font-bold text-gray-800">
      BaZingSe
     </h1>
    </div>
   </div>
  </header>

  <!-- Main Content -->
  <main class="mx-auto px-4 py-8">
   <!-- Flex Container: Chart (left) + Trace Panel (right) -->
   <div class="flex gap-4 relative">
    <!-- Left: BaZi Chart Section (flexible) -->
    <div class="flex-1 min-w-0" :class="showInteractionLog ? 'max-w-[calc(100%-450px)]' : 'max-w-7xl mx-auto'">
     
     <!-- Quick Test Presets -->
     <div class="bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-200 rounded-lg p-3 mb-4">
      <div class="flex items-center gap-2 mb-2">
       <span class="text-xs font-semibold text-gray-700">⚡ Quick Test:</span>
      </div>
      <div class="flex flex-wrap gap-2">
       <button
        v-for="(preset, idx) in testPresets"
        :key="idx"
        @click="loadPreset(preset)"
        class="px-3 py-1.5 text-xs font-medium rounded-md border transition-all hover:scale-105"
        :class="preset.gender === 'female' 
         ? 'bg-pink-50 border-pink-300 text-pink-700 hover:bg-pink-100' 
         : 'bg-blue-50 border-blue-300 text-blue-700 hover:bg-blue-100'"
       >
        <span class="font-mono">{{ preset.date }}</span>
        <span class="mx-1">{{ preset.time }}</span>
        <span>{{ preset.gender === 'female' ? '♀' : '♂' }}</span>
       </button>
      </div>
     </div>
     
     <!-- BaZi Chart with Integrated Input -->
     <div class="bg-white shadow-md p-6">
    <!-- Chart Grid with Input Fields -->
    <div class="w-full">
     <!-- Controls Row: Gender + Time Travel aligned with columns -->
     <div class="flex gap-1 mb-2 overflow-x-auto">
      <!-- Spacer for Hour column -->
      <div class="w-28 flex-shrink-0"></div>
      
      <!-- Gender in Day column position -->
      <div class="w-28 flex-shrink-0">
       <div class="flex justify-center gap-3">
        <label class="cursor-pointer flex items-center gap-0.5">
         <input
          type="radio"
          v-model="gender"
          value="male"
          class="w-3 h-3 text-blue-600 focus:ring-blue-500"
          @change="handleInputChange"
         />
         <span class="text-sm">♂</span>
        </label>
        <label class="cursor-pointer flex items-center gap-0.5">
         <input
          type="radio"
          v-model="gender"
          value="female"
          class="w-3 h-3 text-pink-600 focus:ring-pink-500"
          @change="handleInputChange"
         />
         <span class="text-sm">♀</span>
        </label>
       </div>
      </div>
      
      <!-- Spacers for Month and Year columns -->
      <div class="w-28 flex-shrink-0"></div>
      <div class="w-28 flex-shrink-0"></div>
      
      <!-- Time Travel checkbox (always visible) -->
      <div class="w-28 flex-shrink-0">
       <div class="flex justify-center">
        <label class="cursor-pointer flex items-center gap-1">
         <input 
          type="checkbox" 
          v-model="showAnalysisPeriod" 
          class="w-3 h-3 text-indigo-600 focus:ring-indigo-500"
          @change="handleAnalysisModeToggle"
         />
         <span class="text-xs font-medium text-indigo-700">🔮</span>
        </label>
       </div>
      </div>
     </div>
     
     <!-- Column Headers: Each input aligned with pillar below (9 columns max) -->
     <div class="flex gap-1 mb-2 overflow-x-auto items-center">
      
      <!-- Column 1: Hour (Natal) -->
      <div class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-gray-700 mb-1 text-center">時 Hour</label>
       <div class="relative">
        <input
         v-if="!unknownHour"
         v-model="birthTime"
         type="time"
         class="w-full pl-1 pr-6 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-center hour-input-no-icon"
         @change="handleInputChange"
        />
        <input
         v-else
         value="?"
         disabled
         class="w-full px-1 py-1.5 text-xs border border-gray-300 bg-gray-100 text-center text-gray-500"
        />
        <button
         @click="unknownHour = !unknownHour; handleUnknownHourChange()"
         :class="[
          'absolute right-0.5 top-1/2 -translate-y-1/2 px-1 py-0.5 text-[10px] border transition-colors',
          unknownHour 
           ? 'bg-blue-500 text-white border-blue-500'
           : 'bg-white text-gray-600 border-gray-300'
         ]"
         title="Toggle unknown hour"
        >
         ?
        </button>
       </div>
      </div>
      
      <!-- Column 2: Day (Natal) -->
      <div class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-gray-700 mb-1 text-center">日 Day</label>
       <input
        v-model="dayInput"
        type="number"
        min="1"
        max="31"
        placeholder="DD"
        class="w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-center"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 3: Month (Natal) -->
      <div class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-gray-700 mb-1 text-center">月 Month</label>
       <input
        v-model="monthInput"
        type="number"
        min="1"
        max="12"
        placeholder="MM"
        class="w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-center"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 4: Year (Natal) -->
      <div class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-gray-700 mb-1 text-center">年 Year</label>
       <input
        v-model="yearInput"
        type="number"
        min="1900"
        max="2100"
        placeholder="YYYY"
        class="w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-center"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Left Partition Divider (before 10Y Luck) -->
      <div v-if="chartData?.analysis_info?.has_luck_pillar" 
         class="relative flex-shrink-0 mx-3 self-stretch" 
         style="width: 2px; min-height: 60px;">
       <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
      </div>
      
      <!-- Column 5: 10-Year Luck (Label) -->
      <div v-if="chartData?.analysis_info?.has_luck_pillar" class="w-28 flex-shrink-0">
       <label class="block text-[10px] font-semibold text-purple-700 mb-1 text-center">運 10Y Luck</label>
       <div class="px-1 py-1.5 text-xs bg-purple-50 border border-purple-300 text-center">
        <div class="text-[10px] font-bold text-purple-700 leading-tight">
         {{ currentLuckPillar?.timing?.start_year || '?' }} - {{ currentLuckPillar?.timing?.end_year || '?' }}
        </div>
       </div>
      </div>
      
      <!-- Right Partition Divider (after 10Y Luck) -->
      <div v-if="chartData?.analysis_info?.has_luck_pillar" 
         class="relative flex-shrink-0 mx-3 self-stretch" 
         style="width: 2px; min-height: 60px;">
       <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
      </div>
      
      <!-- Column 6: Annual (Analysis Year) - Always show when time travel mode is ON -->
      <div v-if="showAnalysisPeriod" class="w-28 flex-shrink-0">
       <div class="flex items-center justify-center gap-1 mb-1">
        <input 
         type="checkbox" 
         v-model="includeAnnualLuck" 
         class="w-2.5 h-2.5 cursor-pointer"
         style="accent-color: #C9B037;"
         @change="handleInputChange"
         title="Include Annual Luck in calculations"
        />
        <label class="text-[10px] font-semibold text-center cursor-pointer" 
            :style="includeAnnualLuck ? 'color: #8B7355;' : 'color: #9CA3AF;'"
            @click="includeAnnualLuck = !includeAnnualLuck; handleInputChange()"
            title="Click to toggle Annual Luck inclusion">
         年運 Annual
        </label>
       </div>
       <input
        v-model.number="analysisYear"
        type="number"
        min="1900"
        max="2100"
        placeholder="YYYY"
        :class="includeAnnualLuck 
         ? 'w-full px-1 py-1.5 text-xs border focus:outline-none text-center'
         : 'w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-gray-400 focus:ring-1 focus:ring-gray-400 text-center bg-gray-50 opacity-60'"
        :style="includeAnnualLuck ? 'background: #F5F1E8; border-color: #C9B037; color: #8B7355;' : ''"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 7: Monthly (Analysis Month) - Only show if Annual is enabled -->
      <div v-if="showAnalysisPeriod && analysisYear && includeAnnualLuck" class="w-28 flex-shrink-0">
       <div class="flex items-center justify-center gap-1 mb-1">
        <input 
         type="checkbox" 
         v-model="includeMonthlyLuck" 
         class="w-2.5 h-2.5 cursor-pointer"
         style="accent-color: #C9B037;"
         @change="handleInputChange"
         title="Include Monthly Luck in calculations"
        />
        <label class="text-[10px] font-semibold text-center cursor-pointer" 
            :style="includeMonthlyLuck ? 'color: #8B7355;' : 'color: #9CA3AF;'"
            @click="includeMonthlyLuck = !includeMonthlyLuck; handleInputChange()"
            title="Click to toggle Monthly Luck inclusion">
         月運 Monthly
        </label>
       </div>
       <input
        v-model.number="analysisMonth"
        type="number"
        min="1"
        max="12"
        placeholder="MM"
        :class="includeMonthlyLuck 
         ? 'w-full px-1 py-1.5 text-xs border focus:outline-none text-center'
         : 'w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-gray-400 focus:ring-1 focus:ring-gray-400 text-center bg-gray-50 opacity-60'"
        :style="includeMonthlyLuck ? 'background: #F5F1E8; border-color: #C9B037; color: #8B7355;' : ''"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 8: Daily (Analysis Day) - Only show if Monthly is enabled -->
      <div v-if="showAnalysisPeriod && analysisMonth && includeMonthlyLuck" class="w-28 flex-shrink-0">
       <div class="flex items-center justify-center gap-1 mb-1">
        <input 
         type="checkbox" 
         v-model="includeDailyLuck" 
         class="w-2.5 h-2.5 cursor-pointer"
         style="accent-color: #C9B037;"
         @change="handleInputChange"
         title="Include Daily Luck in calculations"
        />
        <label class="text-[10px] font-semibold text-center cursor-pointer" 
            :style="includeDailyLuck ? 'color: #8B7355;' : 'color: #9CA3AF;'"
            @click="includeDailyLuck = !includeDailyLuck; handleInputChange()"
            title="Click to toggle Daily Luck inclusion">
         日運 Daily
        </label>
       </div>
       <input
        v-model.number="analysisDay"
        type="number"
        min="1"
        max="31"
        placeholder="DD"
        :class="includeDailyLuck 
         ? 'w-full px-1 py-1.5 text-xs border focus:outline-none text-center'
         : 'w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-gray-400 focus:ring-1 focus:ring-gray-400 text-center bg-gray-50 opacity-60'"
        :style="includeDailyLuck ? 'background: #F5F1E8; border-color: #C9B037; color: #8B7355;' : ''"
        @change="handleInputChange"
       />
      </div>
      
      <!-- Column 9: Hourly (Analysis Time) - Only show if Daily is enabled -->
      <div v-if="showAnalysisPeriod && analysisDay && includeDailyLuck" class="w-28 flex-shrink-0">
       <div class="flex items-center justify-center gap-1 mb-1">
        <input 
         type="checkbox" 
         v-model="includeHourlyLuck" 
         class="w-2.5 h-2.5 cursor-pointer"
         style="accent-color: #C9B037;"
         @change="handleInputChange"
         title="Include Hourly Luck in calculations"
        />
        <label class="text-[10px] font-semibold text-center cursor-pointer" 
            :style="includeHourlyLuck ? 'color: #8B7355;' : 'color: #9CA3AF;'"
            @click="includeHourlyLuck = !includeHourlyLuck; handleInputChange()"
            title="Click to toggle Hourly Luck inclusion">
         時運 Hourly
        </label>
       </div>
       <input
        v-model="analysisTime"
        type="time"
        placeholder="HH:MM"
        :class="includeHourlyLuck 
         ? 'w-full px-1 py-1.5 text-xs border focus:outline-none text-center'
         : 'w-full px-1 py-1.5 text-xs border border-gray-300 focus:outline-none focus:border-gray-400 focus:ring-1 focus:ring-gray-400 text-center bg-gray-50 opacity-60'"
        :style="includeHourlyLuck ? 'background: #F5F1E8; border-color: #C9B037; color: #8B7355;' : ''"
        @change="handleInputChange"
       />
      </div>
      

      
     </div>

     <!-- Loading Indicator -->
     <div v-if="isLoading" class="text-center py-4">
      <div class="inline-flex items-center gap-2">
       <svg class="animate-spin h-5 w-5 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
       </svg>
       <span class="text-sm text-gray-600">Calculating...</span>
      </div>
     </div>

     <!-- BaZi Chart Display -->
     <div v-if="pillarsOrdered && !isLoading" class="relative">
      <!-- Traditional 6-Column Grid (4 natal + 2 luck pillars) -->
      <div class="relative overflow-x-auto" :class="totalPillarCount > 4 ? 'max-w-full' : 'max-w-lg'">
       
       <!-- Heavenly Stems Row -->
       <div class="flex gap-1 items-center">
        <!-- Natal Pillars (0-3) -->
        <template v-for="(pillar, index) in pillarsOrdered" :key="`stem-${index}`">
         <!-- Left Partition: Before 10-year luck pillar (position 4) -->
         <div v-if="index === 4 && pillarsOrdered.length > 4" 
            class="relative flex-shrink-0 mx-3 self-stretch"
            style="width: 2px;">
          <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
         </div>
         
         <!-- Pillar Content -->
        <div class="relative w-28 flex-shrink-0">
         <div 
          :id="`stem-${index}`"
          class="aspect-square p-3 transition-all duration-300 relative flex flex-col items-center justify-center"
          :class="[
           hoveredNode === `stem-${index}` ? 'shadow-lg scale-105' : 'border border-gray-300',
           getNodeHighlightClass(`stem-${index}`),
           highlightedNodes.includes(`stem-${index}`) ? 'z-50' : '',
           index === 1 ? 'border-2 border-blue-500' : '',
           pillar.is10YearLuck ? 'border-2 border-purple-500' : '',
           pillar.isAnnualLuck && !includeAnnualLuck ? 'opacity-40 grayscale' : '',
           pillar.isMonthlyLuck && !includeMonthlyLuck ? 'opacity-40 grayscale' : '',
           pillar.isDailyLuck && !includeDailyLuck ? 'opacity-40 grayscale' : '',
           pillar.isHourlyLuck && !includeHourlyLuck ? 'opacity-40 grayscale' : '',
           pillar.isUnknown ? 'bg-gray-100 border-dashed opacity-60' : ''
          ]"
          :style="pillar.isUnknown ? {} : getNodeBgColor(pillar.stem.element, pillar.stem.color)"
         >
          <!-- Negative Badges (top-left corner, stacked vertically) -->
          <div v-if="pillar.stemNegatives && pillar.stemNegatives.length > 0" 
             class="absolute top-1 left-1 gap-0.5 z-20"
             :class="pillar.stemNegatives.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-start'">
           <div v-for="(neg, idx) in pillar.stemNegatives" 
              :key="`stem-neg-${index}-${idx}`"
              class="flex items-center justify-center font-bold transition-transform cursor-help"
              :class="[
               getNegativeBadgeSizeClass(neg.strength),
               isBadgeHighlighted(neg) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getNegativeBadgeStyle(neg)"
              :title="getNegativeBadgeTooltip(neg)"
              @mouseenter="handleBadgeHover(neg)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getNegativeBadgeSymbol(neg) }}</span>
           </div>
          </div>
          
          <!-- Transformation Badges (top-right corner, stacked vertically) -->
          <div v-if="pillar.stemTransformations && pillar.stemTransformations.length > 0" 
             class="absolute top-1 right-1 gap-0.5"
             :class="pillar.stemTransformations.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-end'">
           <div v-for="(trans, idx) in pillar.stemTransformations" 
              :key="`stem-trans-${index}-${idx}`"
              class="flex items-center justify-center font-bold rounded-full shadow-md transition-transform cursor-help"
              :class="[
               getTransformationSizeClass(trans.strength),
               isBadgeHighlighted(trans) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getTransformationBadgeStyles(trans)"
              :title="getTransformationTooltip(trans)"
              @mouseenter="handleBadgeHover(trans)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getTransformBadgeDisplay(trans.badge) }}</span>
           </div>
          </div>
          
          <!-- Pinyin name at top -->
          <div v-if="!pillar.isUnknown" class="text-xs text-gray-700 mb-1">{{ pillar.stemName }}</div>
          <!-- Chinese character (always show original from base) -->
          <div class="text-2xl font-bold text-black">
           {{ pillar.stem.chinese }}
          </div>
          <!-- Element type -->
          <div v-if="!pillar.isUnknown" class="text-xs text-gray-700">
           <template v-if="showTransformed && pillar.stem.transformedElement">
            {{ pillar.stem.transformedElement.replace('Yang ', '').replace('Yin ', '') }}
           </template>
           <template v-else>
            {{ pillar.stem.element.replace('Yang ', '').replace('Yin ', '') }} {{ pillar.stem.element.includes('Yang') ? '+' : '-' }}
           </template>
          </div>
          <!-- Ten God or Day Master -->
          <div v-if="!pillar.isUnknown" class="text-xs mt-1 text-gray-900">
           {{ index === 1 ? 'Day master' : (pillar.tenGod || '') }}
          </div>
          
          <!-- Combination Badges (bottom-right corner) -->
          <div v-if="pillar.stemCombinations && pillar.stemCombinations.length > 0" 
             class="absolute bottom-1 right-1 gap-0.5 flex items-start content-start"
             :class="pillar.stemCombinations.length >= 3 ? 'flex-wrap-reverse flex-row justify-end' : 'flex-row items-end'"
             :style="pillar.stemCombinations.length >= 3 ? 'max-width: 40px;' : ''">
           <div v-for="(comb, idx) in pillar.stemCombinations" 
              :key="`stem-comb-${index}-${idx}`"
              class="flex items-center justify-center font-bold rounded-full transition-transform cursor-help"
              :class="[
               getCombinationBadgeSizeClass(comb.strength),
               isBadgeHighlighted(comb) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getCombinationBadgeStyle(comb)"
              :title="getCombinationTooltip(comb)"
              @mouseenter="handleBadgeHover(comb)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getTransformBadgeDisplay(comb.badge) }}</span>
           </div>
          </div>
          
          
          
          <!-- Horizontal WuXing Flow to Next Stem (only in post/transformed view) -->
          <div v-if="viewMode !== 'base' && !pillar.isUnknown && index < pillarsOrdered.length - 1 && !pillarsOrdered[index + 1].isUnknown && getWuXingRelation(pillar.stem.element, pillarsOrdered[index + 1].stem.element)"
             class="absolute -right-3 top-1/2 -translate-y-1/2 text-lg font-bold z-30"
             :class="getWuXingRelationClass(pillar.stem.element, pillarsOrdered[index + 1].stem.element)"
             :title="`${pillar.stem.element} to ${pillarsOrdered[index + 1].stem.element}`">
           {{ getWuXingRelation(pillar.stem.element, pillarsOrdered[index + 1].stem.element) }}
          </div>
         </div>
        </div>
        
         <!-- Right Partition: After 10-year luck pillar (position 4 only) -->
         <div v-if="index === 4 && pillarsOrdered.length > 4" 
            class="relative flex-shrink-0 mx-3 self-stretch"
            style="width: 2px;">
          <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
         </div>
        </template>
       </div>
       
       <!-- Vertical WuXing Flow Indicators - Always present to maintain consistent spacing -->
       <div class="flex gap-1 -mt-1.5 -mb-1.5 relative z-40 items-center">
        <template v-for="(pillar, index) in pillarsOrdered" :key="`flow-${index}`">
         <!-- Left Partition spacer: Before 10-year luck pillar -->
         <div v-if="index === 4 && pillarsOrdered.length > 4" 
            class="flex-shrink-0 mx-3" style="width: 2px;"></div>
         
        <div class="flex justify-center items-center h-5 w-28 flex-shrink-0">
         <div v-if="viewMode !== 'base' && !pillar.isUnknown && getVerticalWuXingRelation(pillar.stem.element, pillar.branch.element)"
            class="text-lg font-bold"
            :class="getVerticalWuXingClass(pillar.stem.element, pillar.branch.element)"
            :title="`${pillar.stem.element} to ${pillar.branch.element}`">
          {{ getVerticalWuXingRelation(pillar.stem.element, pillar.branch.element) }}
         </div>
        </div>
        
         <!-- Right Partition spacer: After 10-year luck pillar -->
         <div v-if="index === 4 && pillarsOrdered.length > 4" 
            class="flex-shrink-0 mx-3" style="width: 2px;"></div>
        </template>
       </div>
       
       <!-- Earthly Branches Row -->
       <div class="flex gap-1 overflow-visible items-stretch">
        <template v-for="(pillar, index) in pillarsOrdered" :key="`branch-${index}`">
         <!-- Left Partition: Before 10-year luck pillar -->
         <div v-if="index === 4 && pillarsOrdered.length > 4" 
            class="relative flex-shrink-0 mx-3 self-stretch"
            style="width: 2px;">
          <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
         </div>
         
         <!-- Pillar Content -->
        <div class="relative w-28 flex-shrink-0">
         <div 
          :id="`branch-${index}`"
          class="pb-0 pt-2 px-3 transition-all duration-300 relative flex flex-col items-center justify-start"
          :class="[
           hoveredNode === `branch-${index}` ? 'shadow-lg scale-105' : 'border border-gray-300',
           getNodeHighlightClass(`branch-${index}`),
           highlightedNodes.includes(`branch-${index}`) ? 'z-50' : '',
           index === 1 ? 'border-2 border-blue-500' : '',
           pillar.is10YearLuck ? 'border-2 border-purple-500' : '',
           pillar.isAnnualLuck && !includeAnnualLuck ? 'opacity-40 grayscale' : '',
           pillar.isMonthlyLuck && !includeMonthlyLuck ? 'opacity-40 grayscale' : '',
           pillar.isDailyLuck && !includeDailyLuck ? 'opacity-40 grayscale' : '',
           pillar.isHourlyLuck && !includeHourlyLuck ? 'opacity-40 grayscale' : '',
           pillar.isUnknown ? 'bg-gray-100 border-dashed opacity-60' : ''
          ]"
          :style="pillar.isUnknown ? { aspectRatio: '1/1.2' } : {
           ...getNodeBgColor(pillar.branch.element, pillar.branch.color),
           aspectRatio: '1/1.2' // 20% taller than square
          }"
         >
          <!-- Negative Badges (top-left corner, stacked vertically) -->
          <div v-if="pillar.branchNegatives && pillar.branchNegatives.length > 0" 
             class="absolute top-1 left-1 gap-0.5 z-20"
             :class="pillar.branchNegatives.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-start'">
           <div v-for="(neg, idx) in pillar.branchNegatives" 
              :key="`branch-neg-${index}-${idx}`"
              class="flex items-center justify-center font-bold transition-transform cursor-help"
              :class="[
               getNegativeBadgeSizeClass(neg.strength),
               isBadgeHighlighted(neg) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getNegativeBadgeStyle(neg)"
              :title="getNegativeBadgeTooltip(neg)"
              @mouseenter="handleBadgeHover(neg)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getNegativeBadgeSymbol(neg) }}</span>
           </div>
          </div>
          
          <!-- Transformation Badges (top-right corner, stacked vertically) -->
          <div v-if="pillar.branchTransformations && pillar.branchTransformations.length > 0" 
             class="absolute top-1 right-1 gap-0.5 z-10"
             :class="pillar.branchTransformations.length >= 3 ? 'grid grid-cols-2 items-start' : 'flex flex-col items-end'">
           <div v-for="(trans, idx) in pillar.branchTransformations" 
              :key="`branch-trans-${index}-${idx}`"
              class="flex items-center justify-center font-bold rounded-full shadow-md transition-transform cursor-help"
              :class="[
               getTransformationSizeClass(trans.strength),
               isBadgeHighlighted(trans) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getTransformationBadgeStyles(trans)"
              :title="getTransformationTooltip(trans)"
              @mouseenter="handleBadgeHover(trans)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getTransformBadgeDisplay(trans.badge) }}</span>
           </div>
          </div>
          
          <!-- Main content with proper spacing from bottom -->
          <div class="flex-1 flex flex-col items-center justify-center pb-10">
           <!-- Branch pinyin name (always show original) -->
           <div v-if="!pillar.isUnknown" class="text-xs text-gray-700 mb-1">
            {{ pillar.branchName }}
           </div>
           <!-- Chinese character (always show original from base) -->
           <div class="text-2xl font-bold text-black">
            {{ pillar.branch.chinese }}
           </div>
           <!-- Animal name (only show if not a pure element transformation) -->
           <div v-if="!pillar.isUnknown && !['Fire', 'Water', 'Metal', 'Wood', 'Earth'].includes(pillar.branch.animal)" class="text-xs text-gray-800">{{ pillar.branch.animal }}</div>
          </div>
          
          <!-- Combination Badges (bottom-right corner, above hidden stems) -->
          <div v-if="pillar.branchCombinations && pillar.branchCombinations.length > 0" 
             class="absolute bottom-11 right-1 gap-0.5 z-20 flex items-start content-start"
             :class="pillar.branchCombinations.length >= 3 ? 'flex-wrap-reverse flex-row justify-end' : 'flex-row items-end'"
             :style="pillar.branchCombinations.length >= 3 ? 'max-width: 40px;' : ''">
           <div v-for="(comb, idx) in pillar.branchCombinations" 
              :key="`branch-comb-${index}-${idx}`"
              class="flex items-center justify-center font-bold rounded-full transition-transform cursor-help"
              :class="[
               getCombinationBadgeSizeClass(comb.strength),
               isBadgeHighlighted(comb) ? 'scale-125 shadow-lg' : 'hover:scale-110'
              ]"
              :style="getCombinationBadgeStyle(comb)"
              :title="getCombinationTooltip(comb)"
              @mouseenter="handleBadgeHover(comb)"
              @mouseleave="clearHighlight()">
            <span class="leading-none">{{ getTransformBadgeDisplay(comb.badge) }}</span>
           </div>
          </div>
          
          <!-- Hidden Heavenly Stems - Anchored to bottom -->
          <div v-if="pillar.hiddenStems || pillar.hiddenQi" class="absolute bottom-0 left-0 right-0 flex overflow-hidden h-10">
           <div 
            v-for="(qiData, stem) in getHiddenStemsWithWeights(pillar)" 
            :key="stem"
            class="flex flex-col items-center justify-start text-black overflow-hidden pt-1 pb-0.5 h-full"
            :style="{
             ...getNodeBgColor(getStemElement(stem), qiData.color),
             width: `${qiData.weight}%`
            }"
            :title="`${stem}: ${qiData.god ? qiData.god + ' - ' : ''}Score: ${qiData.score || 'N/A'} (${qiData.weight}%)`"
           >
            <!-- Vertical layout: pinyin, char, ten god -->
            <div class="text-[8px] text-gray-600 leading-tight">{{ stem }}</div>
            <div class="text-[10px] text-black leading-tight">{{ stemMappings[stem] || stem }}</div>
            <div class="text-[8px] text-gray-800 font-medium leading-tight">{{ qiData.god || '' }}</div>
           </div>
          </div>
          
          
          <!-- Horizontal WuXing Flow to Next Branch (only in post/transformed view) -->
          <div v-if="viewMode !== 'base' && !pillar.isUnknown && index < pillarsOrdered.length - 1 && !pillarsOrdered[index + 1].isUnknown && getWuXingRelation(pillar.branch.element, pillarsOrdered[index + 1].branch.element)"
             class="absolute -right-3 top-1/3 -translate-y-1/2 text-lg font-bold z-50"
             :class="getWuXingRelationClass(pillar.branch.element, pillarsOrdered[index + 1].branch.element)"
             :title="`${pillar.branch.element} to ${pillarsOrdered[index + 1].branch.element}`">
           {{ getWuXingRelation(pillar.branch.element, pillarsOrdered[index + 1].branch.element) }}
          </div>
         </div>
        </div>
        
         <!-- Right Partition: After 10-year luck pillar -->
         <div v-if="index === 4 && pillarsOrdered.length > 4" 
            class="relative flex-shrink-0 mx-3 self-stretch"
            style="width: 2px;">
          <div class="absolute inset-0 bg-gradient-to-b from-transparent via-purple-500 to-transparent opacity-70"></div>
         </div>
        </template>
       </div>
       
       <!-- View Mode Toggle - Base, Post Interaction -->
       <div class="mt-4 mb-2 max-w-lg">
        <div class="flex items-center gap-2">
         <span class="text-xs text-gray-600">View:</span>
         <div class="flex bg-gray-100 p-0.5">
          <button
           @click="viewMode = 'base'"
           :class="[
            'px-3 py-1 text-xs transition-all',
            viewMode === 'base' 
             ? 'bg-white text-gray-900 shadow-sm' 
             : 'text-gray-600 hover:text-gray-900'
           ]"
          >
           Base
          </button>
          <button
           @click="viewMode = 'post'"
           :class="[
            'px-3 py-1 text-xs transition-all',
            viewMode === 'post' 
             ? 'bg-white text-gray-900 shadow-sm' 
             : 'text-gray-600 hover:text-gray-900'
           ]"
          >
           Post Interaction
          </button>
         </div>
        </div>
       </div>
       
      </div>
      
      <!-- Interaction Tooltip -->
      <div 
       v-if="tooltipContent"
       class="absolute bg-gray-900 text-white text-xs p-3 shadow-xl z-50 max-w-xs pointer-events-none"
       :style="{ left: tooltipPosition.x + 'px', top: tooltipPosition.y + 'px' }"
      >
       <div class="font-semibold mb-1">{{ tooltipContent.title }}</div>
       <div class="text-gray-300">{{ tooltipContent.description }}</div>
       <div v-if="tooltipContent.effect" class="mt-1 text-yellow-300">
        Effect: {{ tooltipContent.effect }}
       </div>
      </div>
     </div>
     
     <!-- Element Scores Comparison (Wu Xing) -->
     <div v-if="chartData?.daymaster_analysis" class="mt-2 p-2 bg-white shadow-sm border border-gray-200 max-w-2xl">
      <div class="flex items-center justify-between mb-1.5">
       <h3 class="text-xs font-semibold text-gray-800">五行 Wu Xing Elements</h3>
       <div class="text-[9px] text-gray-500">
        Linked to: <span class="font-medium">{{ viewMode === 'base' ? 'Base' : 'Post Interaction' }}</span>
       </div>
      </div>
      <div class="text-[9px] text-gray-500 mb-1">Total: {{ Math.round(viewMode === 'base' ? naiveTotal : finalTotal) }} pts</div>
      <div class="space-y-1">
       <div v-for="element in fiveElementsWithRelations" :key="element.name">
        <div class="flex justify-between items-center text-[10px] mb-0.5">
         <div class="flex items-center gap-1">
          <span :class="getElementColor(element.name)" class="font-medium">{{ element.name }}</span>
          <span v-if="element.relationship" class="text-[8px] px-0.5 py-0 bg-gray-100 text-gray-600">{{ element.relationship }}</span>
          <span v-if="viewMode === 'post' && element.change > 0" class="text-[8px] px-0.5 py-0 bg-green-50 text-green-600 opacity-80">↑</span>
          <span v-else-if="viewMode === 'post' && element.change < 0" class="text-[8px] px-0.5 py-0 bg-red-50 text-red-600 opacity-80">↓</span>
         </div>
         <span class="text-gray-600 text-[9px]">
          <template v-if="viewMode === 'base'">{{ Math.round(element.naive) }}</template>
          <template v-else>{{ Math.round(element.naive) }} → {{ Math.round(element.final) }}<span :class="element.change > 0 ? 'text-green-600 font-medium' : element.change < 0 ? 'text-red-600 font-medium' : 'text-gray-400'">({{ element.change > 0 ? '+' : '' }}{{ Math.round(element.change) }})</span></template>
         </span>
        </div>
        <div class="relative h-4 bg-gray-100 overflow-hidden">
         <div class="absolute inset-0 flex"><div class="w-1/5 border-r border-gray-200"></div><div class="w-1/5 border-r border-gray-200"></div><div class="w-1/5 border-r border-gray-200"></div><div class="w-1/5 border-r border-gray-200"></div><div class="w-1/5"></div></div>
         <template v-if="viewMode === 'base'">
          <div class="absolute top-0 left-0 h-full transition-all duration-500" :class="getElementBgColor(element.name)" :style="`width: ${Math.min((element.naive / maxElementScore) * 100, 100)}%`"></div>
          <div class="absolute top-0 h-full flex items-center transition-all duration-500" :style="`left: ${Math.min((element.naive / maxElementScore) * 100, 100)}%`"><span class="ml-1 text-[8px] font-medium text-gray-700">{{ Math.round((element.naive / maxElementScore) * 100) }}%</span></div>
         </template>
         <template v-else>
          <template v-if="element.change > 0">
           <div class="absolute top-0 left-0 h-full rounded-l transition-all duration-500" :class="getElementBgColor(element.name)" :style="`width: ${Math.min((element.naive / maxElementScore) * 100, 100)}%`"></div>
           <div class="absolute top-0 h-full rounded-r transition-all duration-500" :class="getElementBgColor(element.name)" :style="`left: ${Math.min((element.naive / maxElementScore) * 100, 100)}%; width: ${Math.min(((element.final - element.naive) / maxElementScore) * 100, 100 - (element.naive / maxElementScore) * 100)}%; background-image: repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(255,255,255,0.2) 2px, rgba(255,255,255,0.2) 4px);`"></div>
          </template>
          <template v-else>
           <div class="absolute top-0 left-0 h-full transition-all duration-500" :class="[element.change < 0 ? 'border border-dotted' : 'border', getElementBorderColor(element.name)]" :style="`width: ${Math.min((element.naive / maxElementScore) * 100, 100)}%; background-color: transparent;`"></div>
           <div class="absolute top-0 left-0 h-full transition-all duration-700" :class="[getElementBgColor(element.name), element.change < 0 ? 'opacity-80' : '']" :style="`width: ${Math.min((element.final / maxElementScore) * 100, 100)}%`"></div>
          </template>
          <div class="absolute top-0 h-full flex items-center transition-all duration-500" :style="`left: ${Math.min((element.final / maxElementScore) * 100, 100)}%`"><span class="ml-1 text-[8px] font-medium text-gray-700">{{ Math.round((element.final / maxElementScore) * 100) }}%</span></div>
         </template>
        </div>
       </div>
      </div>
     </div>
     
     <!-- Day Master Analysis -->
     <div v-if="chartData?.daymaster_analysis" class="mt-2 p-2 bg-blue-50 max-w-2xl">
      <div class="text-[10px]">
       <span class="font-semibold">Day Master:</span> 
       {{ chartData?.daymaster_analysis?.daymaster }} 
       ({{ chartData?.daymaster_analysis?.daymaster_strength }} - {{ Math.round(chartData?.daymaster_analysis?.daymaster_percentage) }}%)
      </div>
      <div class="text-[10px] mt-1">
       <span class="font-semibold text-green-700">Favorable:</span> 
       {{ chartData?.daymaster_analysis?.favorable_elements?.join(', ') }}
      </div>
      <div class="text-[10px]">
       <span class="font-semibold text-red-700">Unfav:</span> 
       {{ chartData?.daymaster_analysis?.unfavorable_elements?.join(', ') }}
      </div>
     </div>
     
     <!-- Analysis Period Info -->
     <div v-if="chartData?.analysis_info && (chartData.analysis_info.has_luck_pillar || chartData.analysis_info.has_annual || chartData.analysis_info.has_monthly || chartData.analysis_info.has_daily || chartData.analysis_info.has_hourly)" class="mt-2 p-2 bg-gradient-to-r from-indigo-50 to-purple-50 border border-indigo-200 max-w-2xl">
      <div class="text-[10px] font-semibold text-indigo-900 mb-1">📅 Analysis Period</div>
      <div class="grid grid-cols-2 gap-1 text-[9px]">
       <div v-if="chartData.analysis_info.year">
        <span class="font-medium text-indigo-700">Year:</span> 
        <span class="text-gray-700">{{ chartData.analysis_info.year }}</span>
       </div>
       <div v-if="chartData.analysis_info.month">
        <span class="font-medium text-indigo-700">Month:</span> 
        <span class="text-gray-700">{{ chartData.analysis_info.month }}</span>
       </div>
       <div v-if="chartData.analysis_info.day">
        <span class="font-medium text-indigo-700">Day:</span> 
        <span class="text-gray-700">{{ chartData.analysis_info.day }}</span>
       </div>
       <div v-if="chartData.analysis_info.time">
        <span class="font-medium text-indigo-700">Time:</span> 
        <span class="text-gray-700">{{ chartData.analysis_info.time }}</span>
       </div>
      </div>
      <div class="mt-1.5 pt-1.5 border-t border-indigo-200 text-[9px] text-indigo-600">
       <div class="flex flex-wrap gap-1">
        <span v-if="chartData.analysis_info.has_luck_pillar" class="px-2 py-0.5 bg-purple-100 text-purple-700 ">10-Year Luck</span>
        <span v-if="chartData.analysis_info.has_annual" class="px-2 py-0.5 " style="background: #FEF3C7; color: #92400E; border: 1px solid #D97706;">Annual ✓</span>
        <span v-if="chartData.analysis_info.annual_disabled" class="px-2 py-0.5 bg-gray-100 text-gray-500 opacity-60">Annual (display only)</span>
        <span v-if="chartData.analysis_info.has_monthly" class="px-2 py-0.5 " style="background: #FEF3C7; color: #92400E; border: 1px solid #D97706;">Monthly</span>
        <span v-if="chartData.analysis_info.has_daily" class="px-2 py-0.5 " style="background: #FEF3C7; color: #92400E; border: 1px solid #D97706;">Daily</span>
        <span v-if="chartData.analysis_info.has_hourly" class="px-2 py-0.5 " style="background: #FEF3C7; color: #92400E; border: 1px solid #D97706;">Hourly</span>
       </div>
       <div v-if="chartData.analysis_info.annual_disabled" class="mt-1 text-[8px] text-gray-600 italic">
        💡 Year {{ chartData.analysis_info.year }} determines 10-year luck only. Annual pillar shown but excluded from element balance and interactions.
       </div>
      </div>
     </div>
     
     <!-- Current Luck Pillar Timing Info -->
     <div v-if="currentLuckPillar" class="mt-2 p-2 bg-purple-50 border border-purple-200 max-w-2xl">
      <div class="text-[10px] font-semibold text-purple-900 mb-1">Current 10-Year Luck Pillar</div>
      <div class="text-[9px]">
       <span class="font-medium">Period:</span> 
       {{ currentLuckPillar.timing.start_year }} - {{ currentLuckPillar.timing.end_year }}
      </div>
      <div class="text-[9px]">
       <span class="font-medium">Age Range:</span> 
       {{ Math.floor(currentLuckPillar.timing.start_age) }} - {{ Math.floor(currentLuckPillar.timing.end_age) }} years old
      </div>
      <div class="text-[9px] text-purple-700 mt-1 bg-purple-100 border border-purple-300 p-2 rounded">
       <strong>⏰ Temporal Overlay:</strong> The 10-year luck pillar is a <strong>time period</strong> that overlays your entire natal chart.
       It interacts with <strong>all four natal pillars</strong> (Year, Month, Day, Hour) <strong>equally and adjacently</strong>,
       regardless of its visual position in the UI. This reflects authentic BaZi metaphysics where luck periods are temporal influences, not spatial positions.
      </div>
      
      <!-- Luck Pillar Interactions -->
      <div v-if="luckPillarInteractions.length > 0" class="mt-1.5 pt-1.5 border-t border-purple-200">
       <div class="text-[9px] font-semibold text-purple-900 mb-1">Interactions with Natal Chart:</div>
       <div class="space-y-0.5">
        <div v-for="(interaction, idx) in luckPillarInteractions" :key="idx" 
           class="text-[9px] p-1 rounded"
           :class="interaction.effect === 'positive' ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'">
         <span class="font-medium" :class="interaction.effect === 'positive' ? 'text-green-700' : 'text-red-700'">
          {{ interaction.label }}
         </span>
         <span class="text-gray-700 ml-1">{{ interaction.description }}</span>
        </div>
       </div>
      </div>
      <div v-else class="mt-1.5 pt-1.5 border-t border-purple-200 text-[9px] text-gray-600">
       No major interactions (harmonies/clashes) detected with natal chart.
      </div>
     </div>
    </div>
   </div>
    </div>
    <!-- End of Left Section -->

    <!-- Right: Collapsible API Response Viewer -->
    <div 
     v-if="chartData"
     class="transition-all duration-300"
     :class="showInteractionLog ? 'w-[520px]' : 'w-12'"
    >
     <!-- Toggle Button (always visible) -->
     <button
      @click="showInteractionLog = !showInteractionLog"
      class="sticky top-4 w-full h-12 bg-white shadow-md hover:shadow-lg transition-all flex items-center justify-center border border-gray-200 hover:border-blue-300 mb-4 z-10"
      :class="showInteractionLog ? 'justify-between px-4' : ''"
     >
      <template v-if="showInteractionLog">
       <div class="flex items-center gap-2">
        <span class="text-sm font-semibold text-gray-800">API Response</span>
        <span class="px-1.5 py-0.5 bg-green-100 text-green-700 text-xs font-medium">
         JSON
        </span>
       </div>
       <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
       </svg>
      </template>
      <template v-else>
       <svg class="w-5 h-5 text-gray-600 rotate-180" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
       </svg>
      </template>
     </button>

     <!-- JSON Viewer Content (expanded) -->
     <div 
      v-show="showInteractionLog"
      class="bg-white shadow-md overflow-hidden border border-gray-200 flex flex-col"
      style="height: calc(100vh - 100px);"
     >
      <!-- Panel Header -->
      <div class="px-4 py-3 bg-gradient-to-r from-green-50 to-emerald-50 border-b border-gray-200 flex-shrink-0">
       <h3 class="text-sm font-bold text-gray-800">Backend API Response</h3>
       <p class="text-xs text-gray-600 mt-0.5">Raw data from /analyze_bazi endpoint</p>
      </div>

      <!-- JSON Viewer Component -->
      <div class="flex-1 overflow-hidden">
       <JsonViewer v-if="chartData" :data="chartData" />
       <div v-else class="flex items-center justify-center h-full text-gray-500 italic">No data available</div>
      </div>
     </div>
    </div>
    <!-- End of Right Panel -->
   </div>
   <!-- End of Flex Container -->
  </main>
 </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue'
import JsonViewer from '~/components/JsonViewer.vue'

// LocalStorage keys
const STORAGE_KEY = 'bazingse_form_data'

// Helper to load from localStorage
function loadFromStorage() {
 if (typeof window === 'undefined') return null
 try {
  const saved = localStorage.getItem(STORAGE_KEY)
  return saved ? JSON.parse(saved) : null
 } catch (e) {
  console.error('Error loading from localStorage:', e)
  return null
 }
}

// Helper to save to localStorage
function saveToStorage() {
 if (typeof window === 'undefined') return
 try {
  const data = {
   birthDate: birthDate.value,
   birthTime: birthTime.value,
   gender: gender.value,
   unknownHour: unknownHour.value,
   yearInput: yearInput.value,
   monthInput: monthInput.value,
   dayInput: dayInput.value,
   analysisYear: analysisYear.value,
   analysisMonth: analysisMonth.value,
   analysisDay: analysisDay.value,
   analysisTime: analysisTime.value,
   showAnalysisPeriod: showAnalysisPeriod.value,
   includeAnnualLuck: includeAnnualLuck.value,
   includeMonthlyLuck: includeMonthlyLuck.value,
   includeDailyLuck: includeDailyLuck.value,
   includeHourlyLuck: includeHourlyLuck.value,
   viewMode: viewMode.value
  }
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data))
 } catch (e) {
  console.error('Error saving to localStorage:', e)
 }
}

// Load saved values or use defaults
const savedData = loadFromStorage()

// Quick test presets
const testPresets = [
 { date: '1992-07-06', time: '09:30', gender: 'female' },
 { date: '1995-04-19', time: '17:30', gender: 'male' },
 { date: '1985-06-23', time: '13:30', gender: 'male' },
 { date: '1988-02-02', time: '13:30', gender: 'male' },
 { date: '1986-11-29', time: '13:30', gender: 'male' },
 { date: '1995-08-14', time: '11:30', gender: 'female' },
 { date: '1995-07-18', time: '16:30', gender: 'female' },
 { date: '1992-09-18', time: '09:30', gender: 'female' }
]

// Form data
const birthDate = ref(savedData?.birthDate || '1992-07-06')
const birthTime = ref(savedData?.birthTime || '09:30')
const gender = ref(savedData?.gender || 'female')
const isLoading = ref(false)
const chartData = ref(null)
const currentLuckPillar = ref(null) // Current 10-year luck pillar
const annualLuckPillar = ref(null) // Current annual luck pillar
const unknownHour = ref(savedData?.unknownHour || false)

// Individual pillar inputs
const yearInput = ref(savedData?.yearInput || 1992)
const monthInput = ref(savedData?.monthInput || 7)
const dayInput = ref(savedData?.dayInput || 6)

// Analysis period controls (for time travel functionality)
const analysisYear = ref(savedData?.analysisYear || null)
const analysisMonth = ref(savedData?.analysisMonth || null)
const analysisDay = ref(savedData?.analysisDay || null)
const analysisTime = ref(savedData?.analysisTime || '')
const showAnalysisPeriod = ref(savedData?.showAnalysisPeriod || false)
const includeAnnualLuck = ref(savedData?.includeAnnualLuck !== undefined ? savedData.includeAnnualLuck : true)
const includeMonthlyLuck = ref(savedData?.includeMonthlyLuck !== undefined ? savedData.includeMonthlyLuck : true)
const includeDailyLuck = ref(savedData?.includeDailyLuck !== undefined ? savedData.includeDailyLuck : true)
const includeHourlyLuck = ref(savedData?.includeHourlyLuck !== undefined ? savedData.includeHourlyLuck : true)

// Calculate grid columns for luck pillars (backward compatibility)
const luckPillarCount = computed(() => {
 let count = 0
 if (currentLuckPillar.value) count++
 if (annualLuckPillar.value) count++
 return count
})

// Total pillar count (dynamic: 4 natal + analysis pillars)
const totalPillarCount = computed(() => {
 // If no chart data yet, return 4 (natal only)
 if (!chartData.value) return 4
 
 let count = 4 // Base natal pillars (hour, day, month, year)
 
 if (chartData.value?.analysis_info) {
  const info = chartData.value.analysis_info
  if (info.has_luck_pillar) count++ // 10-year luck
  if (info.has_annual) count++    // Annual
  if (info.has_monthly) count++   // Monthly
  if (info.has_daily) count++    // Daily
  if (info.has_hourly) count++    // Hourly
 }
 
 // Ensure count is within valid range (4-9)
 return Math.max(4, Math.min(9, count))
})

// Update birthDate from individual pillar inputs
function updateDateFromPillars() {
 const year = yearInput.value || new Date().getFullYear()
 const month = String(monthInput.value || 1).padStart(2, '0')
 const day = String(dayInput.value || 1).padStart(2, '0')
 birthDate.value = `${year}-${month}-${day}`
}

// Initialize pillar inputs from birthDate
function initializePillarInputs() {
 if (birthDate.value) {
  const [year, month, day] = birthDate.value.split('-')
  yearInput.value = parseInt(year)
  monthInput.value = parseInt(month)
  dayInput.value = parseInt(day)
 }
}

// Debounce timer
let debounceTimer = null

// Handle input changes with debounce
function handleInputChange() {
 updateDateFromPillars()
 
 // Save to localStorage
 saveToStorage()
 
 // Clear existing timer
 if (debounceTimer) {
  clearTimeout(debounceTimer)
 }
 
 // Set new timer to generate chart after 500ms of no changes
 debounceTimer = setTimeout(() => {
  generateChart()
 }, 500)
}

// Handle unknown hour toggle
function handleUnknownHourChange() {
 if (!unknownHour.value) {
  // Restore to default time when unchecking unknown
  birthTime.value = '12:00'
 }
 handleInputChange()
}

// Load a preset test case
function loadPreset(preset) {
 // Set birth date and time
 birthDate.value = preset.date
 birthTime.value = preset.time
 gender.value = preset.gender
 unknownHour.value = false
 
 // Update individual pillar inputs
 const [year, month, day] = preset.date.split('-')
 yearInput.value = parseInt(year)
 monthInput.value = parseInt(month)
 dayInput.value = parseInt(day)
 
 // Reset time travel mode
 showAnalysisPeriod.value = false
 includeAnnualLuck.value = true
 includeMonthlyLuck.value = false
 includeDailyLuck.value = false
 includeHourlyLuck.value = false
 
 // Clear analysis inputs
 analysisYear.value = null
 analysisMonth.value = null
 analysisDay.value = null
 analysisTime.value = ''
 
 // Save and generate
 saveToStorage()
 generateChart()
}

// Handle analysis mode toggle
function handleAnalysisModeToggle() {
 if (showAnalysisPeriod.value && !analysisYear.value) {
  // Pre-fill with current year for convenience
  analysisYear.value = new Date().getFullYear()
 }
 handleInputChange()
}

// Watch for cascading resets when toggles are disabled
watch(includeAnnualLuck, (newValue) => {
 if (!newValue) {
  // Clear monthly and all dependent values
  analysisMonth.value = null
  analysisDay.value = null
  analysisTime.value = ''
 }
})

watch(includeMonthlyLuck, (newValue) => {
 if (!newValue) {
  // Clear daily and hourly
  analysisDay.value = null
  analysisTime.value = ''
 }
})

watch(includeDailyLuck, (newValue) => {
 if (!newValue) {
  // Clear hourly
  analysisTime.value = ''
 }
})

// Clear analysis period
function clearAnalysisPeriod() {
 analysisYear.value = null
 analysisMonth.value = null
 analysisDay.value = null
 analysisTime.value = ''
 handleInputChange()
}

// Initialize on mount (client-side only)
onMounted(() => {
 console.log('Component mounted, initializing...')
 initializePillarInputs()
 // Generate initial chart after component mounts
 setTimeout(() => {
  console.log('Calling generateChart from onMounted')
  generateChart()
 }, 100)
})

// Interactive UI state
const hoveredNode = ref(null)
const hoveredInteraction = ref(null)
const highlightedNodes = ref([])
const highlightContext = ref(null) // NEW: Stores interaction context for element-based coloring
const hoveredTransformationId = ref(null) // NEW: Track which transformation is hovered
const activeConnections = ref([])
const showConnections = ref(true)
const tooltipContent = ref(null)
const tooltipPosition = ref({ x: 0, y: 0 })

// View mode state: 'base' or 'post' - default to 'post' to show energy flow
// This controls both the interaction view and Wu Xing element graph
const viewMode = ref(savedData?.viewMode || 'post')
const showTransformed = computed(() => viewMode.value === 'post')

// Interactions display state
const highlightedInteraction = ref(null)

// Interaction log state
const showInteractionLog = ref(true) // Open by default
const hoveredLogInteraction = ref(null)

// Watch for view mode changes
watch(viewMode, () => {
 // Save view mode preference
 saveToStorage()
})

// Stem and Branch mappings
const stemMappings = {
 'Jia': '甲', 'Yi': '乙', 'Bing': '丙', 'Ding': '丁', 'Wu': '戊',
 'Ji': '己', 'Geng': '庚', 'Xin': '辛', 'Ren': '壬', 'Gui': '癸'
}

// Ten God abbreviation to full name mappings
const tenGodMappings = {
 'F': 'Companion',
 'RW': 'Robbery',
 'EG': 'Output',
 'HO': 'Hurting',
 'IW': 'Wealth',
 'DW': 'Direct Wealth',
 '7K': 'Officer',
 'DO': 'Direct Officer',
 'IR': 'Resource',
 'DR': 'Direct Resource',
 // Keep full names as is
 'Companion': 'Companion',
 'Robbery': 'Robbery',
 'Output': 'Output',
 'Hurting': 'Hurting',
 'Wealth': 'Wealth',
 'Direct Wealth': 'Direct Wealth',
 'Officer': 'Officer',
 'Direct Officer': 'Direct Officer',
 'Resource': 'Resource',
 'Direct Resource': 'Direct Resource'
}

// Branch name to Chinese character mappings
const branchMappings = {
 'Zi': '子', 'Chou': '丑', 'Yin': '寅', 'Mao': '卯',
 'Chen': '辰', 'Si': '巳', 'Wu': '午', 'Wei': '未',
 'Shen': '申', 'You': '酉', 'Xu': '戌', 'Hai': '亥'
}

// Branch polarity mappings based on BaZi theory
const branchPolarities = {
 'Zi': 'Yang',  // Yang Water
 'Chou': 'Yin', // Yin Earth
 'Yin': 'Yang', // Yang Wood
 'Mao': 'Yin',  // Yin Wood
 'Chen': 'Yang', // Yang Earth
 'Si': 'Yang',  // Yang Fire
 'Wu': 'Yang',  // Yang Fire
 'Wei': 'Yin',  // Yin Earth
 'Shen': 'Yang', // Yang Metal
 'You': 'Yin',  // Yin Metal
 'Xu': 'Yang',  // Yang Earth
 'Hai': 'Yin'  // Yin Water
}

// Element to Chinese character mappings (for transformed display)
const elementCharacterMappings = {
 'Wood': '木',
 'Fire': '火',
 'Earth': '土',
 'Metal': '金',
 'Water': '水',
 'Yang Wood': '木',
 'Yin Wood': '木',
 'Yang Fire': '火',
 'Yin Fire': '火',
 'Yang Earth': '土',
 'Yin Earth': '土',
 'Yang Metal': '金',
 'Yin Metal': '金',
 'Yang Water': '水',
 'Yin Water': '水'
}

const HEAVENLY_STEMS = {
 'Jia': { chinese: '甲', element: 'Yang Wood' },
 'Yi': { chinese: '乙', element: 'Yin Wood' },
 'Bing': { chinese: '丙', element: 'Yang Fire' },
 'Ding': { chinese: '丁', element: 'Yin Fire' },
 'Wu': { chinese: '戊', element: 'Yang Earth' },
 'Ji': { chinese: '己', element: 'Yin Earth' },
 'Geng': { chinese: '庚', element: 'Yang Metal' },
 'Xin': { chinese: '辛', element: 'Yin Metal' },
 'Ren': { chinese: '壬', element: 'Yang Water' },
 'Gui': { chinese: '癸', element: 'Yin Water' }
}

const EARTHLY_BRANCHES = {
 'Zi': { chinese: '子', animal: 'Rat', element: 'Yang Water' },
 'Chou': { chinese: '丑', animal: 'Ox', element: 'Yin Earth' },
 'Yin': { chinese: '寅', animal: 'Tiger', element: 'Yang Wood' },
 'Mao': { chinese: '卯', animal: 'Rabbit', element: 'Yin Wood' },
 'Chen': { chinese: '辰', animal: 'Dragon', element: 'Yang Earth' },
 'Si': { chinese: '巳', animal: 'Snake', element: 'Yin Fire' },
 'Wu': { chinese: '午', animal: 'Horse', element: 'Yang Fire' },
 'Wei': { chinese: '未', animal: 'Goat', element: 'Yin Earth' },
 'Shen': { chinese: '申', animal: 'Monkey', element: 'Yang Metal' },
 'You': { chinese: '酉', animal: 'Rooster', element: 'Yin Metal' },
 'Xu': { chinese: '戌', animal: 'Dog', element: 'Yang Earth' },
 'Hai': { chinese: '亥', animal: 'Pig', element: 'Yin Water' }
}

// Check if there are transformations
const hasTransformations = computed(() => {
 if (!chartData.value?.nodes) return false
 
 // Check if any node has badges array with transformation items
 for (const node of Object.values(chartData.value.nodes)) {
  if (node.badges && node.badges.some(b => b.type === 'transformation')) return true
 }
 return false
})

// Count number of transformations (total across all nodes)
const transformationCount = computed(() => {
 if (!chartData.value?.nodes) return 0
 
 let count = 0
 for (const node of Object.values(chartData.value.nodes)) {
  if (node.badges && node.badges.length > 0) {
   count += node.badges.filter(b => b.type === 'transformation').length
  }
 }
 return count
})

// Get the active chart (original or transformed)
const activeChart = computed(() => {
 // Since API now returns nodes directly, we don't need natal_chart
 // Return null to force using the nodes-based approach
 return null
})

// Helper to parse pillar (handles both normal and transformed format)
function parsePillarForDisplay(pillarStr, isTransformed = false) {
 const parts = pillarStr.split(' ')
 
 // Handle transformed format like "Bing Fire" where branch is replaced by element
 if (parts.length === 2 && (parts[1] === 'Fire' || parts[1] === 'Water' || parts[1] === 'Wood' || parts[1] === 'Metal' || parts[1] === 'Earth')) {
  const stemName = parts[0]
  const element = parts[1]
  
  // Create a special display for transformed element branches
  return {
   stemName,
   stem: HEAVENLY_STEMS[stemName] || { chinese: stemName, element: 'Unknown' },
   branchName: element,
   branch: {
    chinese: element === 'Fire' ? '火' : element === 'Water' ? '水' : element === 'Wood' ? '木' : element === 'Metal' ? '金' : '土',
    animal: element,
    element: `Yang ${element}` // Default to Yang for transformed elements
   }
  }
 }
 
 // Normal pillar format
 const [stemName, branchName] = parts
 return {
  stemName,
  stem: HEAVENLY_STEMS[stemName] || { chinese: stemName, element: 'Unknown' },
  branchName,
  branch: EARTHLY_BRANCHES[branchName] || { chinese: branchName, animal: branchName, element: 'Unknown' }
 }
}

// Node-based chart data - now directly at top level
const nodes = computed(() => {
 if (!chartData.value) return null
 
 // Extract node data (hs_y, eb_y, etc.) from top level
 const nodeKeys = ['hs_y', 'eb_y', 'hs_m', 'eb_m', 'hs_d', 'eb_d', 'hs_h', 'eb_h', 
          'hs_10yl', 'eb_10yl', 'hs_yl', 'eb_yl',
          'hs_month', 'eb_month', 'hs_day', 'eb_day']
 
 const nodesData = {}
 for (const key of nodeKeys) {
  if (chartData.value[key]) {
   nodesData[key] = chartData.value[key]
  }
 }
 
 return Object.keys(nodesData).length > 0 ? nodesData : null
})

// Get node by ID
function getNode(nodeId) {
 return nodes.value?.[nodeId] || null
}

// Helper function to enrich badge with interaction data
function enrichBadgeWithInteraction(badge) {
 if (!badge) return badge
 
 // Map size to strength for backward compatibility
 const sizeToStrength = {
  'xs': 'weak',
  'sm': 'normal',
  'md': 'normal',      // Medium = normal
  'lg': 'strong',
  'xl': 'ultra_strong'
 }
 
 // Normalize interaction_id to match the interactions object keys
 // Badge format: HS_COMBINATION_Ding-Ren_hs_h-hs_y
 // Interaction key: STEM_COMBINATION~Ding-Ren~hs_h-hs_y
 let normalizedId = badge.interaction_id
 
 // Replace HS_COMBINATION with STEM_COMBINATION
 normalizedId = normalizedId.replace('HS_COMBINATION', 'STEM_COMBINATION')
 
 // Split by underscore and identify parts
 // Pattern: TYPE_Pattern_nodes where nodes contain underscores
 const parts = normalizedId.split('_')
 if (parts.length >= 3) {
  // Reconstruct: TYPE~Pattern~nodes
  // The first part is the type (may have multiple words joined by underscores)
  // Find where the pattern starts (contains dash or is a node ID)
  let typeEndIndex = 1
  for (let i = 1; i < parts.length; i++) {
   if (parts[i].includes('-') || parts[i].match(/^(hs|eb)$/)) {
    typeEndIndex = i
    break
   }
  }
  const type = parts.slice(0, typeEndIndex).join('_')
  const restParts = parts.slice(typeEndIndex)
  // Find where nodes start (after pattern)
  let patternEndIndex = 0
  for (let i = 0; i < restParts.length; i++) {
   if (restParts[i].match(/^(hs|eb)$/)) {
    patternEndIndex = i
    break
   }
  }
  const pattern = restParts.slice(0, patternEndIndex).join('_')
  const nodes = restParts.slice(patternEndIndex).join('_')
  normalizedId = `${type}~${pattern}~${nodes}`
 }
 
 // Get interaction data from chartData
 const interaction = chartData.value?.interactions?.[normalizedId] || chartData.value?.interactions?.[badge.interaction_id] || {}
 
 return {
  badge: badge.badge,
  type: interaction.type || badge.type,
  element: interaction.element || '',
  pattern: interaction.pattern || '',
  strength: sizeToStrength[badge.size] || 'normal',
  interaction_id: badge.interaction_id
 }
}

// Computed properties
const pillars = computed(() => {
 // Simple direct access to node data as requested
 if (!chartData.value) {
  console.log('pillars computed: no chartData')
  return null
 }
 
 const data = chartData.value
 const mappings = data.mappings || {}
 console.log('pillars computed: has chartData, mappings:', !!mappings)
 
 // Helper to build pillar from node data
 const buildPillar = (hsKey, ebKey, label, isDayMaster = false) => {
  const hsNode = data[hsKey]
  const ebNode = data[ebKey]
  
  if (!hsNode && !ebNode) return null
  
  // Use viewMode to determine which state to show (base or post)
  const usePost = viewMode.value === 'post'
  
  // For stems: always use the base ID for the main character
  // Store badges array and split by type
  const stemId = hsNode?.id
  const stemBadges = usePost ? (hsNode?.badges || []) : []
  const stemTransformations = stemBadges.filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b))
  const stemCombinations = stemBadges.filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b))
  const stemNegatives = stemBadges.filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b))
  
  // Check if stem transformed to element name (like "Yang Metal")
  const isElementName = stemId && stemId.includes(' ') && ['Yang', 'Yin'].some(p => stemId.startsWith(p))
  
  let stemChinese, stemElement, stemColor
  
  if (isElementName) {
   // Handle element name transformations - map back to proper stem ID
   const elementToStemMap = {
    'Yang Metal': 'Geng',
    'Yin Metal': 'Xin',
    'Yang Water': 'Ren',
    'Yin Water': 'Gui',
    'Yang Wood': 'Jia',
    'Yin Wood': 'Yi',
    'Yang Fire': 'Bing',
    'Yin Fire': 'Ding',
    'Yang Earth': 'Wu',
    'Yin Earth': 'Ji'
   }
   const actualStemId = elementToStemMap[stemId] || stemId
   const stemMapping = mappings.heavenly_stems?.[actualStemId] || {}
   stemChinese = stemMapping.chinese || actualStemId || '?'
   stemElement = stemMapping.english || stemId
   // Use regular color from mapping for stem transformations
   stemColor = stemMapping.hex_color || hsNode?.hex_color || hsNode?.color || '#808080'
  } else {
   // Normal stem mapping
   const stemMapping = mappings.heavenly_stems?.[stemId] || {}
   stemChinese = stemMapping.chinese || stemId || '?'
   stemElement = stemMapping.english || hsNode?.element || 'Unknown'
   stemColor = stemMapping.hex_color || hsNode?.hex_color || hsNode?.color || '#808080'
  }
  
  const stem = {
   chinese: stemChinese,
   element: stemElement,
   color: stemColor
  }
  
  // Get the proper stem name (pinyin) for display
  let stemName
  if (isElementName) {
   // If it's an element name, get the corresponding stem ID
   const elementToStemMap = {
    'Yang Metal': 'Geng',
    'Yin Metal': 'Xin',
    'Yang Water': 'Ren',
    'Yin Water': 'Gui',
    'Yang Wood': 'Jia',
    'Yin Wood': 'Yi',
    'Yang Fire': 'Bing',
    'Yin Fire': 'Ding',
    'Yang Earth': 'Wu',
    'Yin Earth': 'Ji'
   }
   stemName = elementToStemMap[stemId] || stemId
  } else {
   stemName = stemId || '?'
  }
  
  // For branches: always use the base ID for the main character
  // Store badges array and split by type
  const branchId = ebNode?.id
  const branchBadges = usePost ? (ebNode?.badges || []) : []
  const branchTransformations = branchBadges.filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b))
  const branchCombinations = branchBadges.filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b))
  const branchNegatives = branchBadges.filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b))
  
  // Check if branch transformed to pure element (Fire, Water, etc)
  const isElementTransformation = usePost && ['Fire', 'Water', 'Metal', 'Wood', 'Earth'].includes(branchId)
  
  let branchChinese, branchAnimal, branchElement, branchColor
  
  if (isElementTransformation) {
   // Handle pure element transformation - use emphasized colors
   const elementMap = {
    'Fire': { chinese: '火', color: '#ff6b6b' },
    'Water': { chinese: '水', color: '#4dabf7' },
    'Metal': { chinese: '金', color: '#868e96' },
    'Wood': { chinese: '木', color: '#51cf66' },
    'Earth': { chinese: '土', color: '#fab005' }
   }
   branchChinese = elementMap[branchId]?.chinese || branchId
   branchAnimal = branchId // Show element name instead of animal
   branchElement = branchId
   // Use emphasized color for pure element transformations
   branchColor = elementMap[branchId]?.color || '#808080'
  } else {
   // Normal branch mapping
   const branchMapping = mappings.earthly_branches?.[branchId] || {}
   branchChinese = branchMapping.chinese || branchId || '?'
   branchAnimal = branchMapping.animal || '?'
   
   // Map branch ID to element (branches have dominant elements)
   const branchToElement = {
    'Zi': 'Water',  // Rat - Water
    'Chou': 'Earth', // Ox - Earth
    'Yin': 'Wood',  // Tiger - Wood
    'Mao': 'Wood',  // Rabbit - Wood
    'Chen': 'Earth', // Dragon - Earth
    'Si': 'Fire',  // Snake - Fire
    'Wu': 'Fire',  // Horse - Fire
    'Wei': 'Earth', // Goat - Earth
    'Shen': 'Metal', // Monkey - Metal
    'You': 'Metal', // Rooster - Metal
    'Xu': 'Earth',  // Dog - Earth
    'Hai': 'Water'  // Pig - Water
   }
   branchElement = branchToElement[branchId] || 'Unknown'
   branchColor = ebNode?.hex_color || ebNode?.color || branchMapping.hex_color || '#808080'
  }
  
  const branch = {
   chinese: branchChinese,
   animal: branchAnimal,
   element: branchElement,
   color: branchColor
  }
  
  // Hidden stems from eb.qi - use post_interaction_qi for post view, base_qi for base view
  const hiddenQi = usePost ? (ebNode?.post_interaction_qi || {}) : (ebNode?.base_qi || {})
  
  // Map hidden stems to Ten Gods using frontend mappings
  const hiddenStems = {}
  if (hiddenQi && data.mappings?.ten_gods) {
   const dayMasterStem = data.hs_d?.id || 'Yi'
   for (const stemName of Object.keys(hiddenQi)) {
    const tenGodData = data.mappings?.ten_gods?.[dayMasterStem]?.[stemName]
    hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
   }
  }
  
  // Calculate Ten God for the Heavenly Stem
  let stemTenGod = null
  if (isDayMaster) {
   stemTenGod = 'DM'
  } else if (hsNode?.id && data.mappings?.ten_gods) {
   const dayMasterStem = data.hs_d?.id || 'Yi'
   const tenGodData = data.mappings?.ten_gods?.[dayMasterStem]?.[hsNode.id]
   stemTenGod = tenGodData?.abbreviation || tenGodData?.id || null
  }
  
  return {
   label,
   stem,
   stemName: stemName,
   branch,
   branchName: branchId,
   stemKey: hsKey,
   branchKey: ebKey,
   hiddenStems,
   hiddenQi,
   tenGod: stemTenGod,
   isUnknown: !hsNode && !ebNode,
   // Transformation badges
   stemTransformations,
   branchTransformations,
   // Combination badges
   stemCombinations,
   branchCombinations,
   // Negative badges
   stemNegatives,
   branchNegatives
  }
 }
 
 const yearPillar = buildPillar('hs_y', 'eb_y', 'Year 年')
 const monthPillar = buildPillar('hs_m', 'eb_m', 'Month 月')
 const dayPillar = buildPillar('hs_d', 'eb_d', 'Day 日', true)
 const hourPillar = buildPillar('hs_h', 'eb_h', 'Hour 時')
 
 // Check if we have at least the essential pillars (year, month, day)
 if (!yearPillar || !monthPillar || !dayPillar) {
  return null
 }
 
 const result = {
  year: yearPillar,
  month: monthPillar, 
  day: dayPillar,
  hour: hourPillar || {
   label: 'Hour 時',
   stem: { chinese: '?', element: 'Unknown' },
   stemName: '?',
   branch: { chinese: '?', animal: '?', element: 'Unknown' },
   branchName: '?',
   stemKey: 'hs_h',
   branchKey: 'eb_h',
   hiddenStems: null,
   tenGod: null,
   transformed: false,
   isUnknown: true
  }
 }
 
 console.log('Simplified pillars from direct node access:', result)
 return result
})

// Natal pillars only (4 columns: Hour, Day, Month, Year)
const natalPillarsOrdered = computed(() => {
 if (!pillars.value) return null
 
 return [
  pillars.value.hour,
  pillars.value.day,
  pillars.value.month,
  pillars.value.year
 ]
})

// Luck pillars only (for separate display below natal chart)
const luckPillarsOrdered = computed(() => {
 if (!chartData.value?.mappings) return []
 
 const luckPillars = []
 
 // Add 10-year luck pillar if available
 if (currentLuckPillar.value) {
  const luckPillarStr = currentLuckPillar.value.pillar
  const [hsName, ebName] = luckPillarStr.split(' ')
  const mappings = chartData.value.mappings
  
  const hsMapping = mappings.heavenly_stems?.[hsName] || {}
  const ebMapping = mappings.earthly_branches?.[ebName] || {}
  
  // Get hidden stems from backend node data
  const ebLuckNode = chartData.value?.eb_10yl
  const hsLuckNode = chartData.value?.hs_10yl
  
  // Calculate Ten God for 10Y luck HS
  const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
  const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
  const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
  
  // Map hidden stems to Ten Gods using frontend mappings (use post_interaction_qi in post view, base_qi in base view)
  const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
  const luckQi = usePost ? (ebLuckNode?.post_interaction_qi || ebLuckNode?.base_qi || {}) : (ebLuckNode?.base_qi || {})
  const hiddenStems = {}
  if (luckQi && mappings.ten_gods) {
   for (const stemName of Object.keys(luckQi)) {
    const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
    hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
   }
  }
  
  luckPillars.push({
   label: '10Y Luck 運',
   stem: {
    chinese: hsMapping.chinese || hsName,
    element: currentLuckPillar.value.hs_element || hsMapping.english || 'Unknown',
    color: hsMapping.hex_color || '#808080'
   },
   stemName: hsName,
   branch: {
    chinese: ebMapping.chinese || ebName,
    animal: currentLuckPillar.value.eb_animal || ebMapping.animal || 'Unknown',
    element: currentLuckPillar.value.eb_animal || 'Unknown',
    color: ebMapping.hex_color || '#808080'
   },
   branchName: ebName,
   stemKey: 'hs_10yl',
   branchKey: 'eb_10yl',
   hiddenStems: hiddenStems,
   hiddenQi: ebLuckNode?.base_qi || null, // Get hidden stems qi from backend
   tenGod: tenGodLabel,
   isUnknown: false,
   stemTransformations: (hsLuckNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   branchTransformations: (ebLuckNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   stemCombinations: (hsLuckNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   branchCombinations: (ebLuckNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   stemNegatives: (hsLuckNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   branchNegatives: (ebLuckNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   isLuckPillar: true,
   timing: currentLuckPillar.value.timing
  })
 }
 
 // Add annual luck pillar if available
 if (annualLuckPillar.value && chartData.value?.mappings) {
  const annualPillarStr = annualLuckPillar.value.pillar
  const [hsName, ebName] = annualPillarStr.split(' ')
  const mappings = chartData.value.mappings
  
  const hsMapping = mappings.heavenly_stems?.[hsName] || {}
  const ebMapping = mappings.earthly_branches?.[ebName] || {}
  
  // Get hidden stems from backend node data
  const ebAnnualNode = chartData.value?.eb_yl
  const hsAnnualNode = chartData.value?.hs_yl
  
  // Calculate Ten God for annual luck HS
  const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
  const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
  const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
  
  // Map hidden stems to Ten Gods using frontend mappings (use post.qi in post view, base.qi in base view)
  const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
  const annualQi = usePost ? (ebAnnualNode?.post_interaction_qi || ebAnnualNode?.base_qi || {}) : (ebAnnualNode?.base_qi || {})
  const hiddenStems = {}
  if (annualQi && mappings.ten_gods) {
   for (const stemName of Object.keys(annualQi)) {
    const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
    hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
   }
  }
  
  luckPillars.push({
   label: 'Annual 年運',
   stem: {
    chinese: hsMapping.chinese || hsName,
    element: annualLuckPillar.value.hs_element || hsMapping.english || 'Unknown',
    color: hsMapping.hex_color || '#808080'
   },
   stemName: hsName,
   branch: {
    chinese: ebMapping.chinese || ebName,
    animal: annualLuckPillar.value.eb_animal || ebMapping.animal || 'Unknown',
    element: annualLuckPillar.value.eb_animal || 'Unknown',
    color: ebMapping.hex_color || '#808080'
   },
   branchName: ebName,
   stemKey: 'hs_yl',
   branchKey: 'eb_yl',
   hiddenStems: hiddenStems,
   hiddenQi: ebAnnualNode?.base_qi || null, // Get hidden stems qi from backend
   tenGod: tenGodLabel,
   isUnknown: false,
   stemTransformations: (hsAnnualNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   branchTransformations: (ebAnnualNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
   stemCombinations: (hsAnnualNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   branchCombinations: (ebAnnualNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
   stemNegatives: (hsAnnualNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   branchNegatives: (ebAnnualNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
   isAnnualLuck: true,
   year: annualLuckPillar.value.year
  })
 }
 
 // Extract Monthly Pillar (if available)
 if (chartData.value?.analysis_info?.has_monthly && chartData.value?.hs_ml && chartData.value?.eb_ml) {
  const hsMonthlyNode = chartData.value.hs_ml
  const ebMonthlyNode = chartData.value.eb_ml
  const [hsName, ebName] = [hsMonthlyNode.id, ebMonthlyNode.id]
  
  if (hsName && ebName) {
   const mappings = chartData.value.mappings
   const hsMapping = mappings.heavenly_stems?.[hsName] || {}
   const ebMapping = mappings.earthly_branches?.[ebName] || {}
   
   const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
   const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
   const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
   
   // Map hidden stems to Ten Gods using frontend mappings (use post_interaction_qi in post view, base_qi in base view)
   const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
   const monthlyQi = usePost ? (ebMonthlyNode?.post_interaction_qi || ebMonthlyNode?.base_qi || {}) : (ebMonthlyNode?.base_qi || {})
   const hiddenStems = {}
   if (monthlyQi && mappings.ten_gods) {
    for (const stemName of Object.keys(monthlyQi)) {
     const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
     hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
    }
   }
   
   luckPillars.push({
    label: 'Monthly 月運',
    stem: {
     chinese: hsMapping.chinese || hsName,
     element: hsMapping.english || 'Unknown',
     color: hsMapping.hex_color || '#808080'
    },
    stemName: hsName,
    branch: {
     chinese: ebMapping.chinese || ebName,
     animal: ebMapping.animal || 'Unknown',
     element: ebMapping.animal || 'Unknown',
     color: ebMapping.hex_color || '#808080'
    },
    branchName: ebName,
    stemKey: 'hs_ml',
    branchKey: 'eb_ml',
    hiddenStems: hiddenStems,
    hiddenQi: ebMonthlyNode?.base_qi || null,
    tenGod: tenGodLabel,
    isUnknown: false,
    stemTransformations: (hsMonthlyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    branchTransformations: (ebMonthlyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    stemCombinations: (hsMonthlyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    branchCombinations: (ebMonthlyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    stemNegatives: (hsMonthlyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    branchNegatives: (ebMonthlyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    isMonthlyLuck: true
   })
  }
 }
 
 // Extract Daily Pillar (if available)
 if (chartData.value?.analysis_info?.has_daily && chartData.value?.hs_dl && chartData.value?.eb_dl) {
  const hsDailyNode = chartData.value.hs_dl
  const ebDailyNode = chartData.value.eb_dl
  const [hsName, ebName] = [hsDailyNode.id, ebDailyNode.id]
  
  if (hsName && ebName) {
   const mappings = chartData.value.mappings
   const hsMapping = mappings.heavenly_stems?.[hsName] || {}
   const ebMapping = mappings.earthly_branches?.[ebName] || {}
   
   const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
   const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
   const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
   
   // Map hidden stems to Ten Gods using frontend mappings (use post_interaction_qi in post view, base_qi in base view)
   const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
   const dailyQi = usePost ? (ebDailyNode?.post_interaction_qi || ebDailyNode?.base_qi || {}) : (ebDailyNode?.base_qi || {})
   const hiddenStems = {}
   if (dailyQi && mappings.ten_gods) {
    for (const stemName of Object.keys(dailyQi)) {
     const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
     hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
    }
   }
   
   luckPillars.push({
    label: 'Daily 日運',
    stem: {
     chinese: hsMapping.chinese || hsName,
     element: hsMapping.english || 'Unknown',
     color: hsMapping.hex_color || '#808080'
    },
    stemName: hsName,
    branch: {
     chinese: ebMapping.chinese || ebName,
     animal: ebMapping.animal || 'Unknown',
     element: ebMapping.animal || 'Unknown',
     color: ebMapping.hex_color || '#808080'
    },
    branchName: ebName,
    stemKey: 'hs_dl',
    branchKey: 'eb_dl',
    hiddenStems: hiddenStems,
    hiddenQi: ebDailyNode?.base_qi || null,
    tenGod: tenGodLabel,
    isUnknown: false,
    stemTransformations: (hsDailyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    branchTransformations: (ebDailyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    stemCombinations: (hsDailyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    branchCombinations: (ebDailyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    stemNegatives: (hsDailyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    branchNegatives: (ebDailyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    isDailyLuck: true
   })
  }
 }
 
 // Extract Hourly Pillar (if available)
 if (chartData.value?.analysis_info?.has_hourly && chartData.value?.hs_hl && chartData.value?.eb_hl) {
  const hsHourlyNode = chartData.value.hs_hl
  const ebHourlyNode = chartData.value.eb_hl
  const [hsName, ebName] = [hsHourlyNode.id, ebHourlyNode.id]
  
  if (hsName && ebName) {
   const mappings = chartData.value.mappings
   const hsMapping = mappings.heavenly_stems?.[hsName] || {}
   const ebMapping = mappings.earthly_branches?.[ebName] || {}
   
   const dayMasterStem = chartData.value?.hs_d?.id || 'Yi'
   const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[hsName]
   const tenGodLabel = tenGodData?.abbreviation || tenGodData?.id || ''
   
   // Map hidden stems to Ten Gods using frontend mappings (use post_interaction_qi in post view, base_qi in base view)
   const usePost = viewMode.value === 'post' || viewMode.value === 'transformed'
   const hourlyQi = usePost ? (ebHourlyNode?.post_interaction_qi || ebHourlyNode?.base_qi || {}) : (ebHourlyNode?.base_qi || {})
   const hiddenStems = {}
   if (hourlyQi && mappings.ten_gods) {
    for (const stemName of Object.keys(hourlyQi)) {
     const tenGodData = mappings.ten_gods?.[dayMasterStem]?.[stemName]
     hiddenStems[stemName] = tenGodData?.abbreviation || tenGodData?.id || ''
    }
   }
   
   luckPillars.push({
    label: 'Hourly 時運',
    stem: {
     chinese: hsMapping.chinese || hsName,
     element: hsMapping.english || 'Unknown',
     color: hsMapping.hex_color || '#808080'
    },
    stemName: hsName,
    branch: {
     chinese: ebMapping.chinese || ebName,
     animal: ebMapping.animal || 'Unknown',
     element: ebMapping.animal || 'Unknown',
     color: ebMapping.hex_color || '#808080'
    },
    branchName: ebName,
    stemKey: 'hs_hl',
    branchKey: 'eb_hl',
    hiddenStems: hiddenStems,
    hiddenQi: ebHourlyNode?.base_qi || null,
    tenGod: tenGodLabel,
    isUnknown: false,
    stemTransformations: (hsHourlyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    branchTransformations: (ebHourlyNode?.badges || []).filter(b => b.type === 'transformation').map(b => enrichBadgeWithInteraction(b)),
    stemCombinations: (hsHourlyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    branchCombinations: (ebHourlyNode?.badges || []).filter(b => b.type === 'combination').map(b => enrichBadgeWithInteraction(b)),
    stemNegatives: (hsHourlyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    branchNegatives: (ebHourlyNode?.badges || []).filter(b => ['clash', 'harm', 'punishment', 'destruction'].includes(b.type)).map(b => enrichBadgeWithInteraction(b)),
    isHourlyLuck: true
   })
  }
 }
 
 return luckPillars
})

// Combined ordered pillars (for backward compatibility with interaction functions)
const pillarsOrdered = computed(() => {
 if (!pillars.value) return null
 
 const basePillars = [
  pillars.value.hour,
  pillars.value.day,
  pillars.value.month,
  pillars.value.year
 ]
 
 // Use luckPillarsOrdered to get all luck pillars (10Y, annual, monthly, daily, hourly)
 const allLuckPillars = luckPillarsOrdered.value || []
 
 // Combine natal + luck pillars
 return [...basePillars, ...allLuckPillars]
})

// Old manual pillar building logic removed - now using luckPillarsOrdered
// (Simplified from 150+ lines to just using luckPillarsOrdered above)

const tenElements = computed(() => {
 // Backend now returns base_element_score and post_element_score (flat dicts with stem IDs as keys)
 if (!chartData.value?.base_element_score || !chartData.value?.post_element_score) return []
 
 const baseScores = chartData.value.base_element_score
 const postScores = chartData.value.post_element_score
 
 // Map stem IDs to display names
 const stemToDisplay = {
  'Jia': 'Yang Wood',
  'Yi': 'Yin Wood',
  'Bing': 'Yang Fire',
  'Ding': 'Yin Fire',
  'Wu': 'Yang Earth',
  'Ji': 'Yin Earth',
  'Geng': 'Yang Metal',
  'Xin': 'Yin Metal',
  'Ren': 'Yang Water',
  'Gui': 'Yin Water'
 }
 
 return Object.entries(stemToDisplay).map(([stem, displayName]) => ({
  name: displayName,
  naive: baseScores[stem] || 0,
  final: postScores[stem] || 0,
  change: (postScores[stem] || 0) - (baseScores[stem] || 0)
 }))
})

const fiveElements = computed(() => {
 // Backend now returns base_element_score and post_element_score (flat dicts with 10 stems)
 if (!chartData.value?.base_element_score || !chartData.value?.post_element_score) return []
 
 const baseScores = chartData.value.base_element_score
 const postScores = chartData.value.post_element_score
 
 // Map stems to elements and sum them up
 const stemToElement = {
  'Jia': 'Wood', 'Yi': 'Wood',
  'Bing': 'Fire', 'Ding': 'Fire',
  'Wu': 'Earth', 'Ji': 'Earth',
  'Geng': 'Metal', 'Xin': 'Metal',
  'Ren': 'Water', 'Gui': 'Water'
 }
 
 const naiveByElement = {}
 const finalByElement = {}
 const elements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 
 // Initialize
 elements.forEach(elem => {
  naiveByElement[elem] = 0
  finalByElement[elem] = 0
 })
 
 // Sum up scores by element
 Object.entries(stemToElement).forEach(([stem, element]) => {
  naiveByElement[element] += baseScores[stem] || 0
  finalByElement[element] += postScores[stem] || 0
 })
 
 return elements.map(name => ({
  name,
  naive: naiveByElement[name] || 0,
  final: finalByElement[name] || 0,
  change: (finalByElement[name] || 0) - (naiveByElement[name] || 0)
 }))
})

const fiveElementsWithRelations = computed(() => {
 if (!fiveElements.value.length) return []
 
 // If no daymaster_analysis, return elements without relationships
 if (!chartData.value?.daymaster_analysis) {
  return fiveElements.value.map(element => ({
   ...element,
   relationship: ''
  }))
 }
 
 const daymaster = chartData.value.daymaster_analysis.daymaster
 const daymasterElement = daymaster.split(' ')[1] // Get element from "Yang Fire" -> "Fire"
 
 return fiveElements.value.map(element => ({
  ...element,
  relationship: getElementRelationship(daymasterElement, element.name)
 }))
})

// Calculate totals for different views
const naiveTotal = computed(() => {
 if (!fiveElements.value.length) return 100
 return fiveElements.value.reduce((sum, e) => sum + e.naive, 0)
})

const finalTotal = computed(() => {
 if (!fiveElements.value.length) return 100
 return fiveElements.value.reduce((sum, e) => sum + e.final, 0)
})

const maxElementScore = computed(() => {
 if (!fiveElements.value.length) return 100
 // Use the maximum of naive or final totals for consistent scaling
 return Math.max(naiveTotal.value, finalTotal.value, 100)
})

const maxTenElementScore = computed(() => {
 if (!tenElements.value.length) return 100
 // Find the maximum single element score for scaling
 const maxScore = Math.max(...tenElements.value.map(e => e.final))
 return Math.max(maxScore, 100)
})

const totalChange = computed(() => {
 if (!fiveElements.value.length) return 0
 return fiveElements.value.reduce((sum, e) => sum + e.change, 0)
})

const interactions = computed(() => {
 // Handle both new format (direct interactions object) and wrapped format
 const interactionsData = chartData.value?.interactions || chartData.value?.interaction_analysis?.interactions
 if (!interactionsData) return []
 
 // If it's an object (new format), convert to array
 if (typeof interactionsData === 'object' && !Array.isArray(interactionsData)) {
  return Object.entries(interactionsData).map(([id, data]) => ({
   id,
   ...data
  }))
 }
 
 // If it's already an array, return as-is
 return interactionsData
})

const nonNaturalInteractions = computed(() => {
 if (!interactions.value || !Array.isArray(interactions.value)) return []
 return interactions.value.filter(i => {
  return !i.type?.includes('NATURAL') && !i.type?.includes('ENERGY_FLOW') && i.type !== 'SEASONAL_ADJUSTMENT'
 })
})

// Extract luck pillar interactions from backend-calculated interactions
// Backend returns interactions as a DICTIONARY (not array), with keys like "TYPE~Pattern~nodes"
const luckPillarInteractions = computed(() => {
 if (!chartData.value?.interactions || (!currentLuckPillar.value && !annualLuckPillar.value)) return []
 
 const interactionsDict = chartData.value.interactions
 const luckInteractions = []
 
 // Iterate through interaction dictionary keys
 for (const [key, interactionData] of Object.entries(interactionsDict)) {
  // Check if this interaction involves luck pillar nodes (10-year, annual, monthly, daily, hourly)
  const nodes = interactionData.nodes || []
  const hasLuckNode = nodes.some(nodeId => 
   nodeId === 'hs_10yl' || nodeId === 'eb_10yl' ||
   nodeId === 'hs_yl' || nodeId === 'eb_yl' ||
   nodeId === 'hs_ml' || nodeId === 'eb_ml' ||
   nodeId === 'hs_dl' || nodeId === 'eb_dl' ||
   nodeId === 'hs_hl' || nodeId === 'eb_hl'
  )
  
  if (hasLuckNode) {
   // Parse the key format: "TYPE~Pattern~nodes"
   const [type, pattern, nodesStr] = key.split('~')
   
   // Determine effect based on interaction type
   let effect = 'positive'
   if (type && (
    type.includes('CLASH') || 
    type.includes('HARM') || 
    type.includes('PUNISHMENT') ||
    type.includes('CONFLICT') ||
    type.includes('DESTRUCTION')
   )) {
    effect = 'negative'
   }
   
   // Get label from type
   const labelMap = {
    'SIX_HARMONIES': '六合',
    'CLASHES': '相冲',
    'HARMS': '相害',
    'PUNISHMENTS': '相刑',
    'STEM_COMBINATION': '天干合',
    'STEM_CONFLICT': '天干沖',
    'THREE_COMBINATIONS': '三合',
    'HALF_COMBINATION': '半合',
    'DESTRUCTION': '相破'
   }
   const label = labelMap[type] || type
   
   luckInteractions.push({
    type,
    label,
    description: interactionData.pattern || pattern || `${type} interaction`,
    branches: interactionData.branches || interactionData.stems || [],
    nodes,
    effect
   })
  }
 }
 
 return luckInteractions
})

// Methods
async function generateChart() {
 if (!birthDate.value) {
  if (typeof window !== 'undefined') {
   alert('Please fill in birth date')
  }
  return
 }
 
 // Use 'unknown' for birth_time when hour is unknown
 const timeParam = unknownHour.value ? 'unknown' : birthTime.value
 
 if (!timeParam && !unknownHour.value) {
  if (typeof window !== 'undefined') {
   alert('Please fill in birth time or mark as unknown')
  }
  return
 }
 
 isLoading.value = true
 try {
  // Build API URL with analyze_bazi endpoint (underscore, not hyphen)
  let apiUrl = `/api/bazi/analyze_bazi?birth_date=${birthDate.value}&birth_time=${encodeURIComponent(timeParam)}&gender=${gender.value}`
  
  // Only add analysis parameters if time travel mode is enabled (🔮 toggle is ON)
  if (showAnalysisPeriod.value) {
   // Add analysis_year to get luck pillars (default to current year if not specified)
   const yearToAnalyze = analysisYear.value || new Date().getFullYear()
   apiUrl += `&analysis_year=${yearToAnalyze}`
   
   // Add include_annual_luck parameter (controls whether annual luck affects calculations)
   apiUrl += `&include_annual_luck=${includeAnnualLuck.value}`
   
   // Only send month/day/time if toggles are enabled (respects checkbox state)
   if (analysisMonth.value && includeMonthlyLuck.value) {
    apiUrl += `&analysis_month=${analysisMonth.value}`
   }
   
   if (analysisDay.value && includeDailyLuck.value) {
    apiUrl += `&analysis_day=${analysisDay.value}`
   }
   
   if (analysisTime.value && includeHourlyLuck.value) {
    apiUrl += `&analysis_time=${encodeURIComponent(analysisTime.value)}`
   }
  }
  
  console.log('Calling analyze_bazi endpoint:', apiUrl)
  
  // Call the backend endpoint via proxy
  const response = await fetch(apiUrl)
  
  if (!response.ok) throw new Error('Chart API request failed')
  
  const data = await response.json()
  console.log('Chart data from analyze_bazi received:', data)
  chartData.value = data
  
  // Extract 10-year luck pillar info from response (if has_luck_pillar flag is true)
  if (data.analysis_info?.has_luck_pillar && data.hs_10yl && data.eb_10yl) {
   const luckHs = data.hs_10yl.id
   const luckEb = data.eb_10yl.id
   
   if (luckHs && luckEb) {
    currentLuckPillar.value = {
     pillar: `${luckHs} ${luckEb}`,
     hs_element: data.mappings?.heavenly_stems?.[luckHs]?.english || 'Unknown',
     eb_animal: data.mappings?.earthly_branches?.[luckEb]?.animal || 'Unknown',
     ten_god_hs: data.hs_10yl?.base?.ten_god || 'Unknown',
     ten_god_hidden: {},
     timing: (() => {
      const misc = data.hs_10yl?.misc || data.eb_10yl?.misc
      if (misc && misc.start_date && misc.end_date) {
       // Extract years from date strings (format: "YYYY-MM-DD")
       const startYear = misc.start_date.split('-')[0]
       const endYear = misc.end_date.split('-')[0]
       return {
        start_year: parseInt(startYear),
        end_year: parseInt(endYear),
        start_age: misc.start_age || 0,
        end_age: misc.end_age || 10,
        start_date: misc.start_date,
        end_date: misc.end_date
       }
      }
      // Fallback if no misc data
      return {
       start_year: data.analysis_info?.year || new Date().getFullYear(),
       end_year: (data.analysis_info?.year || new Date().getFullYear()) + 10,
       start_age: 0,
       end_age: 10
      }
     })(),
     is_current: true
    }
    console.log('10-year luck pillar extracted:', currentLuckPillar.value)
   } else {
    currentLuckPillar.value = null
   }
  } else {
   currentLuckPillar.value = null
  }
  
  // Extract annual luck pillar info from response (if year is set, even if disabled)
  if (data.analysis_info?.year && data.hs_yl && data.eb_yl) {
   const annualHs = data.hs_yl.id
   const annualEb = data.eb_yl.id
   
   if (annualHs && annualEb) {
    annualLuckPillar.value = {
     pillar: `${annualHs} ${annualEb}`,
     hs_element: data.mappings?.heavenly_stems?.[annualHs]?.english || 'Unknown',
     eb_animal: data.mappings?.earthly_branches?.[annualEb]?.animal || 'Unknown',
     ten_god_hs: data.hs_yl?.base?.ten_god || 'Unknown',
     ten_god_hidden: {},
     year: data.analysis_info?.year,
     is_current: true,
     disabled: data.hs_yl.disabled || false // Track if it's disabled
    }
    console.log('Annual luck pillar extracted:', annualLuckPillar.value)
   } else {
    annualLuckPillar.value = null
   }
  } else {
   annualLuckPillar.value = null
  }
  
  console.log('chartData.value set with backend interactions, pillarsOrdered:', pillarsOrdered.value)
 } catch (error) {
  console.error('Error generating chart:', error)
  console.error('Error details:', {
   message: error.message,
   stack: error.stack,
   apiUrl: `/api/bazi/analyze_bazi?birth_date=${birthDate.value}&birth_time=${encodeURIComponent(birthTime.value || 'unknown')}&gender=${gender.value}`
  })
  if (typeof window !== 'undefined') {
   alert(`Failed to generate chart: ${error.message || 'Unknown error'}. Check console for details.`)
  }
 } finally {
  isLoading.value = false
  console.log('isLoading set to false')
 }
}

function getElementColor(element) {
 const colorMap = {
  'Wood': 'text-green-600',
  'Yang Wood': 'text-green-700',
  'Yin Wood': 'text-green-500',
  'Fire': 'text-red-600',
  'Yang Fire': 'text-red-700',
  'Yin Fire': 'text-red-500',
  'Earth': 'text-yellow-600',
  'Yang Earth': 'text-yellow-700',
  'Yin Earth': 'text-yellow-500',
  'Metal': 'text-gray-600',
  'Yang Metal': 'text-gray-700',
  'Yin Metal': 'text-gray-500',
  'Water': 'text-blue-600',
  'Yang Water': 'text-blue-700',
  'Yin Water': 'text-blue-500'
 }
 return colorMap[element] || 'text-gray-600'
}

// Removed cyber color functions - now using getElementColor

function getElementBgColor(element) {
 const colorMap = {
  'Wood': 'bg-green-500',
  'Fire': 'bg-red-500',
  'Earth': 'bg-yellow-500',
  'Metal': 'bg-gray-500',
  'Water': 'bg-blue-500'
 }
 return colorMap[element] || 'bg-gray-400'
}

// Get node background color using hex colors from API
function getNodeBgColor(elementWithPolarity, apiHexColor = null) {
 // If API provided a hex color, use it directly
 if (apiHexColor) {
  // Handle pure element colors (gradient object)
  if (typeof apiHexColor === 'object' && apiHexColor.bg) {
   // For pure elements, return a special gradient
   if (apiHexColor.bg.includes('gradient')) {
    return { 
     background: 'linear-gradient(to right, #ef4444, #a855f7, #ec4899)',
     border: '2px solid #9333ea'
    }
   }
  }
  
  // Use hex color directly from API
  if (typeof apiHexColor === 'string' && apiHexColor.startsWith('#')) {
   return { backgroundColor: apiHexColor }
  }
 }
 
 // Fallback to element-based colors
 const colorMap = {
  'Yang Wood': '#c2d4be',
  'Yin Wood': '#d6e2bb',
  'Yang Fire': '#f3adae',
  'Yin Fire': '#f5d3b0',
  'Yang Earth': '#e6ceb7',
  'Yin Earth': '#efe3cc',
  'Yang Metal': '#ccd8e6',
  'Yin Metal': '#e6e8f7',
  'Yang Water': '#b9cbff',
  'Yin Water': '#e0e9ff'
 }
 
 const bgColor = colorMap[elementWithPolarity] || '#f9fafb'
 return { backgroundColor: bgColor }
}

// Get element for a stem name
function getStemElement(stemName) {
 const stemElements = {
  'Jia': 'Yang Wood', 'Yi': 'Yin Wood',
  'Bing': 'Yang Fire', 'Ding': 'Yin Fire',
  'Wu': 'Yang Earth', 'Ji': 'Yin Earth',
  'Geng': 'Yang Metal', 'Xin': 'Yin Metal',
  'Ren': 'Yang Water', 'Gui': 'Yin Water'
 }
 return stemElements[stemName] || ''
}


// Get hidden stems with proportional weights based on qi scores
function getHiddenStemsWithWeights(pillar) {
 // Get the appropriate qi data based on view mode
 const ebNode = nodes.value?.[pillar.branchKey]
 
 // Use base_qi in base mode, post_interaction_qi in other modes
 let qiData = null
 if (viewMode.value === 'base' && ebNode?.base_qi) {
  // Use initial qi for base view
  qiData = ebNode.base_qi
 } else if (ebNode?.post_interaction_qi) {
  // Use post_interaction_qi for post-interaction and transformed views
  qiData = ebNode.post_interaction_qi
 } else if (ebNode?.base_qi) {
  // Fallback to base_qi if post_interaction_qi not available
  qiData = ebNode.base_qi
 } else if (pillar.hiddenQi) {
  // Fallback to pillar.hiddenQi (could be object or array)
  qiData = pillar.hiddenQi
 }
 
 // Handle both object format {Yi: 100.0, Jia: 20.0} and array format
 if (qiData) {
  // Convert object to array format if needed
  let qiArray = []
  if (Array.isArray(qiData)) {
   qiArray = qiData
  } else if (typeof qiData === 'object') {
   // Convert {Yi: 100.0, Jia: 20.0} to [{stem: 'Yi', score: 100.0}, ...]
   qiArray = Object.entries(qiData).map(([stem, score]) => ({
    stem,
    score,
    count: 1
   }))
  }
  
 if (qiArray && qiArray.length > 0) {
  const result = {}
  const totalScore = qiArray.reduce((sum, qi) => sum + qi.score, 0)
  
  for (const qi of qiArray) {
   const percentage = Math.round((qi.score / totalScore) * 100)
   // Get ten god for this stem if available
   // Handle both string format and object format
   const tenGodData = pillar.hiddenStems?.[qi.stem]
   const tenGod = typeof tenGodData === 'string' 
    ? tenGodData 
    : tenGodData?.abbreviation || tenGodData?.id || ''
   // Use hex color from API if available, fallback to color, then null
   const stemColor = qi.hex_color || qi.color || null
   result[qi.stem] = { 
    god: tenGod, 
    weight: percentage,
    score: qi.score,
    count: qi.count,
    color: stemColor
   }
  }
  return result
 }
 }
 
 // Fallback to old method using hiddenStems with hardcoded percentages
 if (!pillar.hiddenStems) return {}
 
 // Hardcoded hidden stem percentages based on BaZi traditional values
 // These match the backend's EARTHLY_BRANCH_HIDDEN_QI definitions
 const hiddenStemPercentages = {
  'Zi': { 'Gui': 100 },
  'Chou': { 'Ji': 60, 'Gui': 30, 'Xin': 10 },
  'Yin': { 'Jia': 60, 'Bing': 30, 'Wu': 10 },
  'Mao': { 'Yi': 100 },
  'Chen': { 'Wu': 60, 'Yi': 30, 'Gui': 10 },
  'Si': { 'Bing': 60, 'Wu': 30, 'Geng': 10 },
  'Wu': { 'Ding': 70, 'Ji': 30 },
  'Wei': { 'Ji': 60, 'Ding': 30, 'Yi': 10 },
  'Shen': { 'Geng': 60, 'Ren': 30, 'Wu': 10 },
  'You': { 'Xin': 100 },
  'Xu': { 'Wu': 60, 'Xin': 30, 'Ding': 10 },
  'Hai': { 'Ren': 70, 'Jia': 30 }
 }
 
 // Get the original branch name (before any transformation)
 const branchName = pillar.branchName
 const branchPercentages = hiddenStemPercentages[branchName]
 
 if (!branchPercentages) {
  // Fallback: distribute evenly if branch not found
  const stems = Object.entries(pillar.hiddenStems)
  const result = {}
  const evenWeight = Math.floor(100 / stems.length)
  for (const [stem, tenGod] of stems) {
   result[stem] = { god: tenGod, weight: evenWeight }
  }
  return result
 }
 
 // Use the hardcoded percentages
 const result = {}
 for (const [stem, tenGod] of Object.entries(pillar.hiddenStems)) {
  const percentage = branchPercentages[stem] || 33 // Default if not found
  result[stem] = { god: tenGod, weight: percentage }
 }
 
 return result
}

function getElementBorderColor(element) {
 const colorMap = {
  'Wood': 'border-green-500',
  'Fire': 'border-red-500',
  'Earth': 'border-yellow-500',
  'Metal': 'border-gray-500',
  'Water': 'border-blue-500'
 }
 return colorMap[element] || 'border-gray-400'
}

function getInteractionBorderColor(type) {
 if (type.includes('NATURAL')) return 'border-purple-400'
 if (type.includes('CONFLICT') || type.includes('CLASH') || type.includes('HARM') || type.includes('DESTRUCTION') || type.includes('PUNISHMENT')) return 'border-red-400'
 if (type.includes('COMBINATION') || type.includes('HARMONY')) return 'border-green-400'
 if (type.includes('MEETING')) return 'border-blue-400'
 return 'border-gray-400'
}

// Get subtle left border class for log entries
function getLogBorderClass(type) {
 if (type.includes('NATURAL')) return 'border-l-4 border-l-purple-300'
 if (type.includes('CONFLICT') || type.includes('CLASH') || type.includes('HARM') || type.includes('DESTRUCTION') || type.includes('PUNISHMENT')) return 'border-l-4 border-l-red-300'
 if (type.includes('COMBINATION') || type.includes('HARMONY')) return 'border-l-4 border-l-green-300'
 if (type.includes('MEETING')) return 'border-l-4 border-l-blue-300'
 return 'border-l-4 border-l-gray-300'
}

function getInteractionTextColor(type) {
 if (type.includes('NATURAL')) return 'text-purple-700'
 if (type.includes('CONFLICT') || type.includes('CLASH') || type.includes('HARM') || type.includes('DESTRUCTION') || type.includes('PUNISHMENT')) return 'text-red-700'
 if (type.includes('COMBINATION') || type.includes('HARMONY')) return 'text-green-700'
 if (type.includes('MEETING')) return 'text-blue-700'
 return 'text-gray-700'
}

function formatInteractionType(type) {
 const typeMap = {
  'THREE_MEETINGS': '三會 Three Meetings',
  'PUNISHMENTS': '相刑 Punishments',
  'THREE_COMBINATIONS': '三合 Three Combinations',
  'SIX_HARMONIES': '六合 Six Harmonies',
  'HALF_COMBINATIONS': '半合 Half Combinations',
  'HALF_COMBINATION': '半合 Half Combination',
  'ARCHED_COMBINATIONS': '拱合 Arched Combinations',
  'CLASHES': '沖 Clashes',
  'HARMS': '害 Harms',
  'DESTRUCTIONS': '破 Destructions',
  'DESTRUCTION': '破 Destruction',
  'HS_CONFLICT': '天干沖 Stem Conflicts',
  'STEM_CONFLICT': '天干沖 Stem Conflict',
  'HS_COMBINATION': '天干合 Stem Combinations',
  'STEM_COMBINATION': '天干合 Stem Combination',
  'NATURAL_GENERATING': '生 Energy Flow (Generation)',
  'NATURAL_CONTROLLING': '剋 Energy Flow (Control)',
  'ENERGY_FLOW_GENERATING': '生 Energy Flow (Generation)',
  'ENERGY_FLOW_CONTROLLING': '剋 Energy Flow (Control)',
  'ENERGY_FLOW': '氣 Energy Flow',
  'SEASONAL_ADJUSTMENT': '季節調整 Seasonal Adjustment'
 }
 return typeMap[type] || type
}

function formatInteractionDescription(interaction) {
 if (interaction.description) return interaction.description
 
 if (interaction.type === 'HS_CONFLICT' && interaction.conflictor) {
  return `${interaction.conflictor.stem} (conflictor, -${interaction.conflictor.reduction}%) conflicts with ${interaction.conflicted.stem} (conflicted, -${interaction.conflicted.reduction}%)`
 }
 
 if (interaction.relationship) return interaction.relationship
 
 if (interaction.branches) {
  return `Branches: ${interaction.branches.join(', ')}`
 }
 
 if (interaction.stems) {
  return `Stems: ${interaction.stems.join(', ')}`
 }
 
 return ''
}

// Get pre/post element scores for an interaction
function getInteractionElementScores(interaction) {
 if (!chartData.value) return null
 
 // Get base (pre) and post element scores from chartData
 const baseScores = chartData.value.base_element_score || {}
 const postScores = chartData.value.post_element_score || {}
 
 // If no element changes in this interaction, return null
 if (!interaction.element_changes || Object.keys(interaction.element_changes).length === 0) {
  return null
 }
 
 // Build scores object for affected elements
 const scores = {}
 const fiveElements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 
 for (const element of fiveElements) {
  // Get all stems for this element from baseScores
  const stemIds = Object.keys(baseScores).filter(stemId => {
   const mapping = chartData.value.mappings?.heavenly_stems?.[stemId]
   if (!mapping) return false
   const stemElement = mapping.english || ''
   // Match "Yang Fire" or "Yin Fire" to "Fire"
   return stemElement.includes(element)
  })
  
  // Sum up scores for this element
  let preTotal = 0
  let postTotal = 0
  
  for (const stemId of stemIds) {
   preTotal += baseScores[stemId] || 0
   postTotal += postScores[stemId] || 0
  }
  
  // Only include if there's a change
  const change = postTotal - preTotal
  if (Math.abs(change) > 0.1) { // Small threshold to avoid floating point noise
   scores[element] = {
    pre: preTotal,
    post: postTotal,
    change: change
   }
  }
 }
 
 return Object.keys(scores).length > 0 ? scores : null
}

function formatNodeName(node) {
 const nodeMap = {
  'hs_y': 'Year Stem',
  'hs_m': 'Month Stem',
  'hs_d': 'Day Stem',
  'hs_h': 'Hour Stem',
  'hs_10yl': '10-Year Luck Stem',
  'hs_yl': 'Annual Luck Stem',
  'hs_ml': 'Monthly Luck Stem',
  'hs_dl': 'Daily Luck Stem',
  'hs_hl': 'Hourly Luck Stem',
  'eb_y': 'Year Branch',
  'eb_m': 'Month Branch',
  'eb_d': 'Day Branch',
  'eb_h': 'Hour Branch',
  'eb_10yl': '10-Year Luck Branch',
  'eb_yl': 'Annual Luck Branch',
  'eb_ml': 'Monthly Luck Branch',
  'eb_dl': 'Daily Luck Branch',
  'eb_hl': 'Hourly Luck Branch'
 }
 return nodeMap[node] || node
}

function getPillarPosition(position) {
 const positions = ['Year', 'Month', 'Day', 'Hour', '10-Year Luck', 'Annual Luck', 'Monthly Luck', 'Daily Luck', 'Hourly Luck']
 return positions[position] || position
}

function getTenGodLabel(element) {
 if (!chartData.value?.daymaster_analysis) return ''
 
 const daymaster = chartData.value.daymaster_analysis.daymaster
 const daymasterElement = daymaster.split(' ')[1] // Get element part
 const daymasterPolarity = daymaster.split(' ')[0] // Get polarity (Yang/Yin)
 const elementName = element.split(' ')[1] // Get element part
 const elementPolarity = element.split(' ')[0] // Get polarity
 
 // WuXing cycle: Wood -> Fire -> Earth -> Metal -> Water -> Wood
 const cycle = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 const dmIndex = cycle.indexOf(daymasterElement)
 const elIndex = cycle.indexOf(elementName)
 
 // Calculate relationship distance
 const distance = (elIndex - dmIndex + 5) % 5
 
 // Determine Ten God based on distance and polarity match
 const polarityMatch = daymasterPolarity === elementPolarity
 
 switch(distance) {
  case 0: // Same element
   return polarityMatch ? '比肩 Friend' : '劫財 Rob Wealth'
  case 1: // Element I generate (child)
   return polarityMatch ? '食神 Eating God' : '傷官 Hurting Officer'
  case 2: // Element that generates my child (wealth)
   return polarityMatch ? '偏財 Indirect Wealth' : '正財 Direct Wealth'
  case 3: // Element that controls me (officer)
   return polarityMatch ? '偏官 Seven Killings' : '正官 Direct Officer'
  case 4: // Element that generates me (resource)
   return polarityMatch ? '偏印 Indirect Resource' : '正印 Direct Resource'
  default:
   return ''
 }
}

function getElementRelationship(daymasterElement, element) {
 // WuXing cycle relationships
 const cycle = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 const dmIndex = cycle.indexOf(daymasterElement)
 const elIndex = cycle.indexOf(element)
 
 const distance = (elIndex - dmIndex + 5) % 5
 
 switch(distance) {
  case 0:
   return 'Self/Companion'
  case 1:
   return 'Output/Expression'
  case 2:
   return 'Wealth'
  case 3:
   return 'Officer/Status'
  case 4:
   return 'Resource/Support'
  default:
   return ''
 }
}

// Interactive handlers
function handleNodeHover(nodeId, nodeKey) {
 hoveredNode.value = nodeId
 highlightedNodes.value = []
 
 // Find interactions involving this node
 const nodeInteractions = getNodeInteractions(nodeKey)
 
 // Highlight connected nodes
 nodeInteractions.forEach(interaction => {
  if (interaction.nodes) {
   interaction.nodes.forEach(node => {
    if (node !== nodeKey) {
     const nodeIndex = getNodeIndex(node)
     if (nodeIndex !== -1) {
      const nodeType = node.startsWith('hs') ? 'stem' : 'branch'
      highlightedNodes.value.push(`${nodeType}-${nodeIndex}`)
     }
    }
   })
  }
 })
 
 // Show tooltip
 if (nodeInteractions.length > 0) {
  const event = window.event
  tooltipContent.value = {
   title: `${nodeInteractions.length} Interactions`,
   description: nodeInteractions.map(i => formatShortInteraction(i)).join(', '),
   effect: nodeInteractions.some(i => i.effect === 'High') ? 'Strong influence' : 'Moderate influence'
  }
  tooltipPosition.value = {
   x: event.pageX + 10,
   y: event.pageY - 50
  }
 }
}

function handleNodeLeave() {
 hoveredNode.value = null
 highlightedNodes.value = []
 highlightContext.value = null // Clear context
 hoveredTransformationId.value = null // Clear transformation highlight
 tooltipContent.value = null
}

function handleInteractionHover(interaction) {
 hoveredInteraction.value = interaction.id
 highlightedNodes.value = []
 highlightContext.value = interaction // Set context for element-based coloring
 
 // Highlight nodes involved in this interaction
 if (interaction.nodes) {
  interaction.nodes.forEach(node => {
   const nodeIndex = getNodeIndex(node)
   if (nodeIndex !== -1) {
    const nodeType = node.startsWith('hs') ? 'stem' : 'branch'
    highlightedNodes.value.push(`${nodeType}-${nodeIndex}`)
   }
  })
 }
 
 // Show detailed tooltip
 const event = window.event
 tooltipContent.value = {
  title: formatInteractionType(interaction.type),
  description: formatInteractionDescription(interaction),
  effect: interaction.effect || 'Modifies element energies'
 }
 tooltipPosition.value = {
  x: event.pageX + 10,
  y: event.pageY - 50
 }
}

function getTransformBadgeDisplay(badge) {
 if (!badge) return ''
 
 // Map stem IDs to their Chinese characters
 const stemToChinese = {
  'Jia': '甲', 'Yi': '乙', 'Bing': '丙', 'Ding': '丁',
  'Wu': '戊', 'Ji': '己', 'Geng': '庚', 'Xin': '辛',
  'Ren': '壬', 'Gui': '癸'
 }
 
 // Map pure elements to their Chinese characters
 const elementToChinese = {
  'Wood': '木', 'Fire': '火', 'Earth': '土',
  'Metal': '金', 'Water': '水'
 }
 
 // Check if it's a stem ID
 if (stemToChinese[badge]) {
  return stemToChinese[badge]
 }
 
 // Check if it's a pure element
 if (elementToChinese[badge]) {
  return elementToChinese[badge]
 }
 
 // If it contains 'Yang' or 'Yin', extract the element part
 if (badge.includes('Yang') || badge.includes('Yin')) {
  const element = badge.replace('Yang ', '').replace('Yin ', '')
  return elementToChinese[element] || badge
 }
 
 // Default: return as is
 return badge
}

function getTransformBadgeStyle(badge) {
 if (!badge) return {}
 
 // Map stem IDs and elements to their hex colors from the mappings
 const badgeColors = {
  // Heavenly Stems colors
  'Jia': '#c2d4be',  // Yang Wood - Light sage green
  'Yi': '#d6e2bb',   // Yin Wood - Light lime green
  'Bing': '#f3adae',  // Yang Fire - Light coral red
  'Ding': '#f5d3b0',  // Yin Fire - Light peach
  'Wu': '#e6ceb7',   // Yang Earth - Light tan
  'Ji': '#efe3cc',   // Yin Earth - Light cream
  'Geng': '#ccd8e6',  // Yang Metal - Light steel blue
  'Xin': '#e6e8f7',  // Yin Metal - Light lavender
  'Ren': '#b9cbff',  // Yang Water - Light sky blue
  'Gui': '#e0e9ff',  // Yin Water - Light powder blue
  // Pure Elements
  'Wood': '#c9dcc4',  // Average of wood colors
  'Fire': '#f4c0af',  // Average of fire colors
  'Earth': '#ead9c2', // Average of earth colors
  'Metal': '#d9e0f2', // Average of metal colors
  'Water': '#cdd5ff', // Average of water colors
  // Yang/Yin Elements
  'Yang Wood': '#c2d4be',
  'Yin Wood': '#d6e2bb',
  'Yang Fire': '#f3adae',
  'Yin Fire': '#f5d3b0',
  'Yang Earth': '#e6ceb7',
  'Yin Earth': '#efe3cc',
  'Yang Metal': '#ccd8e6',
  'Yin Metal': '#e6e8f7',
  'Yang Water': '#b9cbff',
  'Yin Water': '#e0e9ff'
 }
 
 const bgColor = badgeColors[badge] || '#fbbf24' // Default to yellow if not found
 
 // Calculate a darker text color for contrast
 const textColor = getLightnessPercent(bgColor) > 70 ? '#1f2937' : '#ffffff'
 
 return {
  backgroundColor: bgColor,
  color: textColor,
  border: `2px solid ${adjustBrightness(bgColor, -20)}`,
  boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)'
 }
}

// Helper function to calculate lightness percentage
function getLightnessPercent(hexColor) {
 const hex = hexColor.replace('#', '')
 const r = parseInt(hex.substr(0, 2), 16)
 const g = parseInt(hex.substr(2, 2), 16)
 const b = parseInt(hex.substr(4, 2), 16)
 return (0.299 * r + 0.587 * g + 0.114 * b) / 255 * 100
}

// Helper function to adjust brightness
function adjustBrightness(hexColor, percent) {
 const hex = hexColor.replace('#', '')
 const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + percent * 2.55))
 const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + percent * 2.55))
 const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + percent * 2.55))
 return '#' + [r, g, b].map(x => Math.round(x).toString(16).padStart(2, '0')).join('')
}

// NEW: Multi-transformation badge functions with strength-based styling
function getTransformationBadgeStyles(transformation) {
 if (!transformation) return {}
 
 const { badge, strength, element } = transformation
 
 // Badge colors - same as backend mappings hex_color
 const badgeColors = {
  // Heavenly Stems (from backend mappings)
  'Jia': '#c2d4be',  // Yang Wood - Light sage green
  'Yi': '#d6e2bb',   // Yin Wood - Light lime green
  'Bing': '#f3adae',  // Yang Fire - Light coral red
  'Ding': '#f5d3b0',  // Yin Fire - Light peach
  'Wu': '#e6ceb7',   // Yang Earth - Light tan
  'Ji': '#efe3cc',   // Yin Earth - Light cream
  'Geng': '#ccd8e6',  // Yang Metal - Light steel blue
  'Xin': '#e6e8f7',  // Yin Metal - Light lavender
  'Ren': '#b9cbff',  // Yang Water - Light sky blue
  'Gui': '#e0e9ff',  // Yin Water - Light powder blue
  
  // Pure Elements (averaged colors for direct transformations)
  'Wood': '#c9dcc4',  // Average of wood colors
  'Fire': '#f4c0af',  // Average of fire colors
  'Earth': '#ead9c2', // Average of earth colors
  'Metal': '#d9e0f2', // Average of metal colors
  'Water': '#cdd5ff'  // Average of water colors
 }
 
 const baseBgColor = badgeColors[badge] || badgeColors[element] || '#fbbf24'
 const textColor = getLightnessPercent(baseBgColor) > 70 ? '#1f2937' : '#ffffff'
 const borderColor = adjustBrightness(baseBgColor, -20)
 
 // Strength differentiation: SIZE (via CSS class) + GLOW only
 const strengthStyles = {
  ultra_strong: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px solid ${borderColor}`,
   boxShadow: `0 0 10px ${baseBgColor}, 0 2px 4px rgba(0, 0, 0, 0.1)`, // Strong glow
   opacity: 1
  },
  strong: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px solid ${borderColor}`,
   boxShadow: `0 0 6px ${baseBgColor}, 0 2px 4px rgba(0, 0, 0, 0.1)`, // Medium glow
   opacity: 1
  },
  normal: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px solid ${borderColor}`,
   boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)', // Subtle shadow only
   opacity: 1
  },
  weak: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px solid ${borderColor}`,
   boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)',
   opacity: 0.7
  }
 }
 
 const style = strengthStyles[strength] || strengthStyles.normal
 
 return {
  backgroundColor: style.bgColor,
  color: style.textColor,
  border: style.border,
  boxShadow: style.boxShadow,
  opacity: style.opacity
 }
}

function getTransformationSizeClass(strength) {
 const sizeClasses = {
  ultra_strong: 'w-8 h-8 text-xs',   // 32px
  strong: 'w-7 h-7 text-[11px]',    // 28px
  normal: 'w-6 h-6 text-[10px]',    // 24px (current default)
  weak: 'w-5 h-5 text-[9px]'      // 20px
 }
 return sizeClasses[strength] || sizeClasses.normal
}

function getStrengthIndicator(strength) {
 const indicators = {
  ultra_strong: '★★', // 2 stars
  strong: '★',     // 1 star
  normal: '●',     // Filled dot
  weak: '○'      // Hollow dot
 }
 return indicators[strength] || indicators.normal
}

// Combination badge size classes
function getCombinationBadgeSizeClass(strength) {
 const sizeClasses = {
  ultra_strong: 'w-6 h-6 text-xs',      // 24px
  strong: 'w-5 h-5 text-[10px]',        // 20px
  normal: 'w-4 h-4 text-[8px]',         // 16px (default)
  weak: 'w-3 h-3 text-[7px]'            // 12px
 }
 return sizeClasses[strength] || sizeClasses.normal
}

// Combination badge styling
function getCombinationBadgeStyle(combination) {
 if (!combination) return {}
 
 const { badge, element } = combination
 
 // Use same base colors with subtle styling for combinations
 const badgeColors = {
  'Jia': '#c2d4be', 'Yi': '#d6e2bb', 'Bing': '#f3adae', 'Ding': '#f5d3b0',
  'Wu': '#e6ceb7', 'Ji': '#efe3cc', 'Geng': '#ccd8e6', 'Xin': '#e6e8f7',
  'Ren': '#b9cbff', 'Gui': '#e0e9ff',
  'Wood': '#c9dcc4', 'Fire': '#f4c0af', 'Earth': '#ead9c2',
  'Metal': '#d9e0f2', 'Water': '#cdd5ff'
 }
 
 const baseBgColor = badgeColors[badge] || badgeColors[element] || '#e5e7eb'
 const textColor = '#6b7280' // Gray-500 for subtle effect
 
 return {
  backgroundColor: baseBgColor,
  color: textColor,
  border: `1.5px dashed ${adjustBrightness(baseBgColor, -30)}`,
  boxShadow: 'none',
  opacity: 0.6,
  background: `repeating-linear-gradient(45deg, ${baseBgColor}, ${baseBgColor} 2px, ${adjustBrightness(baseBgColor, -5)} 2px, ${adjustBrightness(baseBgColor, -5)} 4px)`
 }
}

function getCombinationTooltip(combination) {
 if (!combination) return ''
 
 const typeLabels = {
  THREE_MEETINGS: '三會 (Three Meetings)',
  THREE_COMBINATIONS: '三合 (Three Combinations)',
  SIX_HARMONIES: '六合 (Six Harmonies)',
  HALF_COMBINATIONS: '半合 (Half Combinations)',
  ARCHED_COMBINATIONS: '拱合 (Arched Combinations)',
  STEM_COMBINATION: '天干合 (Stem Combination)'
 }
 
 return `${typeLabels[combination.type] || combination.type}\n` +
     `Pattern: ${combination.pattern}\n` +
     `→ ${combination.element || 'Partial transformation'}`
}

// Negative badge functions - same as transformations, just display the badge character
function getNegativeBadgeSymbol(negative) {
 if (!negative || !negative.badge) return '●'
 
 // Map stem IDs to their Chinese characters (same as getTransformBadgeDisplay)
 const stemToChinese = {
  'Jia': '甲', 'Yi': '乙', 'Bing': '丙', 'Ding': '丁',
  'Wu': '戊', 'Ji': '己', 'Geng': '庚', 'Xin': '辛',
  'Ren': '壬', 'Gui': '癸'
 }
 
 // Map branch IDs to their Chinese characters
 const branchToChinese = {
  'Zi': '子', 'Chou': '丑', 'Yin': '寅', 'Mao': '卯',
  'Chen': '辰', 'Si': '巳', 'Wu': '午', 'Wei': '未',
  'Shen': '申', 'You': '酉', 'Xu': '戌', 'Hai': '亥'
 }
 
 // Map pure elements to their Chinese characters
 const elementToChinese = {
  'Wood': '木', 'Fire': '火', 'Earth': '土',
  'Metal': '金', 'Water': '水'
 }
 
 return stemToChinese[negative.badge] || 
        branchToChinese[negative.badge] || 
        elementToChinese[negative.badge] || 
        negative.badge
}

function getNegativeBadgeSizeClass(strength) {
 const sizeClasses = {
  ultra_strong: 'w-8 h-8 text-sm',    // 32px square
  strong: 'w-7 h-7 text-xs',          // 28px square
  normal: 'w-6 h-6 text-[10px]',      // 24px square
  weak: 'w-5 h-5 text-[8px]'          // 20px square
 }
 return sizeClasses[strength] || sizeClasses.normal
}

function getNegativeBadgeStyle(negative) {
 if (!negative) return {}
 
 const { badge, type, strength } = negative
 
 // Use the same color mapping as transformations - exact hex from mappings
 const badgeColors = {
  // Heavenly Stems (from backend mappings)
  'Jia': '#c2d4be',  'Yi': '#d6e2bb',
  'Bing': '#f3adae', 'Ding': '#f5d3b0',
  'Wu': '#e6ceb7',   'Ji': '#efe3cc',
  'Geng': '#ccd8e6', 'Xin': '#e6e8f7',
  'Ren': '#b9cbff',  'Gui': '#e0e9ff',
  
  // Earthly Branches
  'Zi': '#b9cbff',   'Chou': '#e6ceb7',
  'Yin': '#c2d4be',  'Mao': '#d6e2bb',
  'Chen': '#e6ceb7', 'Si': '#f3adae',
  'Wu': '#f3adae',   'Wei': '#efe3cc',
  'Shen': '#ccd8e6', 'You': '#e6e8f7',
  'Xu': '#e6ceb7',   'Hai': '#e0e9ff',
  
  // Pure Elements (fallback)
  'Wood': '#c9dcc4', 'Fire': '#f4c0af', 'Earth': '#ead9c2',
  'Metal': '#d9e0f2', 'Water': '#cdd5ff'
 }
 
 const baseBgColor = badgeColors[badge] || badgeColors['Earth'] || '#fbbf24'
 const textColor = getLightnessPercent(baseBgColor) > 70 ? '#1f2937' : '#ffffff'
 const borderColor = adjustBrightness(baseBgColor, -20)
 
 // Type-based border styling (different visual flair for each type)
 const typeStyles = {
  'clash': {
   borderStyle: 'solid',
   borderWidth: '3px',
   shape: 'square'  // Square with sharp corners
  },
  'harm': {
   borderStyle: 'dashed',
   borderWidth: '2.5px',
   shape: 'square'
  },
  'punishment': {
   borderStyle: 'double',
   borderWidth: '3px',
   shape: 'square'
  },
  'destruction': {
   borderStyle: 'dotted',
   borderWidth: '3px',
   shape: 'square'
  }
 }
 
 const typeStyle = typeStyles[type] || typeStyles.clash
 
 // Strength-based glow intensity (similar to transformations)
 const strengthStyles = {
  ultra_strong: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `${typeStyle.borderWidth} ${typeStyle.borderStyle} ${borderColor}`,
   boxShadow: `0 0 12px ${baseBgColor}, 0 4px 6px rgba(0, 0, 0, 0.2)`,
   opacity: 1
  },
  strong: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `${typeStyle.borderWidth} ${typeStyle.borderStyle} ${borderColor}`,
   boxShadow: `0 0 8px ${baseBgColor}, 0 2px 4px rgba(0, 0, 0, 0.15)`,
   opacity: 1
  },
  normal: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px ${typeStyle.borderStyle} ${borderColor}`,
   boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
   opacity: 1
  },
  weak: {
   bgColor: baseBgColor,
   textColor: textColor,
   border: `2px ${typeStyle.borderStyle} ${borderColor}`,
   boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)',
   opacity: 0.8
  }
 }
 
 const style = strengthStyles[strength] || strengthStyles.normal
 
 return {
  backgroundColor: style.bgColor,
  color: style.textColor,
  border: style.border,
  boxShadow: style.boxShadow,
  opacity: style.opacity,
  borderRadius: '0'  // Square with sharp edges
 }
}

function getNegativeBadgeTooltip(negative) {
 if (!negative) return ''
 
 const typeLabels = {
  'clash': '沖 (Clash)',
  'harm': '害 (Harm)',
  'punishment': '刑 (Punishment)',
  'destruction': '破 (Destruction)',
  'CLASHES': '沖 (Clash)',
  'HARMS': '害 (Harm)',
  'PUNISHMENTS': '刑 (Punishment)',
  'DESTRUCTIONS': '破 (Destruction)',
  'STEM_CONFLICT': '天干沖 (Stem Conflict)'
 }
 
 const strengthLabels = {
  ultra_strong: 'Severe',
  strong: 'Strong',
  normal: 'Moderate',
  weak: 'Weak'
 }
 
 return `⚠️ ${typeLabels[negative.type] || negative.type}\n` +
     `Pattern: ${negative.pattern || 'N/A'}\n` +
     `Severity: ${strengthLabels[negative.strength] || negative.strength}\n` +
     `Negative influence on energies`
}

function getTransformationTooltip(transformation) {
 if (!transformation) return ''
 
 const typeLabels = {
  THREE_MEETINGS: '三會 (Three Meetings)',
  THREE_COMBINATIONS: '三合 (Three Combinations)',
  SIX_HARMONIES: '六合 (Six Harmonies)',
  HALF_COMBINATIONS: '半合 (Half Combinations)',
  ARCHED_COMBINATIONS: '拱合 (Arched Combinations)',
  STEM_COMBINATION: '天干合 (Stem Combination)'
 }
 
 const strengthLabels = {
  ultra_strong: 'Ultra Strong - Seasonal Directional',
  strong: 'Strong - Triangular Combo',
  normal: 'Normal - Pair Combo',
  weak: 'Weak - Partial Combo'
 }
 
 return `${typeLabels[transformation.type] || transformation.type}\n` +
     `Pattern: ${transformation.pattern}\n` +
     `→ ${transformation.element}\n` +
     `Strength: ${strengthLabels[transformation.strength] || transformation.strength}`
}

// NEW: Get highlight ring class based on interaction context
function getNodeHighlightClass(nodeId) {
 if (!highlightedNodes.value.includes(nodeId)) return ''
 
 const context = highlightContext.value
 if (!context) return 'ring-1 ring-blue-400' // Default subtle blue
 
 // Check if negative interaction (exact type match to avoid false positives)
 const isNegative = context.type && (
  context.type === 'CLASHES' ||
  context.type === 'HARMS' ||
  context.type === 'DESTRUCTION' ||
  context.type === 'DESTRUCTIONS' ||
  context.type === 'PUNISHMENTS' ||
  context.type === 'STEM_CONFLICT' ||
  context.type === 'clash' ||
  context.type === 'harm' ||
  context.type === 'destruction' ||
  context.type === 'punishment'
 )
 
 if (isNegative) {
  // White border for negative interactions
  return 'ring-1 ring-white'
 }
 
 // Element-based colors for positive interactions (transformations/combinations)
 const element = context.element || context.pattern?.split('-').pop() // Try to extract element
 
 // Get polarity - check if node is Yang or Yin based on node ID
 const isYangNode = nodeId.includes('stem') ? 
  isYangStem(nodeId) : isYangBranch(nodeId)
 
 // Element color mapping with polarity
 const elementColors = {
  'Fire': isYangNode ? 'ring-red-500' : 'ring-orange-400',
  'Water': isYangNode ? 'ring-blue-600' : 'ring-blue-300',
  'Wood': isYangNode ? 'ring-green-600' : 'ring-green-300',
  'Metal': isYangNode ? 'ring-gray-500' : 'ring-gray-300',
  'Earth': isYangNode ? 'ring-yellow-700' : 'ring-yellow-400'
 }
 
 const ringColor = elementColors[element] || 'ring-blue-400'
 return `ring-1 ${ringColor}`
}

// Helper: Check if stem is Yang
function isYangStem(nodeId) {
 const yangStems = ['Jia', 'Bing', 'Wu', 'Geng', 'Ren']
 // Extract stem name from pillar data
 const index = parseInt(nodeId.split('-')[1])
 if (isNaN(index) || !pillarsOrdered.value || index >= pillarsOrdered.value.length) return true
 const stemName = pillarsOrdered.value[index]?.stemName || ''
 return yangStems.includes(stemName)
}

// Helper: Check if branch is Yang
function isYangBranch(nodeId) {
 const yangBranches = ['Zi', 'Yin', 'Chen', 'Wu', 'Shen', 'Xu']
 // Extract branch name from pillar data
 const index = parseInt(nodeId.split('-')[1])
 if (isNaN(index) || !pillarsOrdered.value || index >= pillarsOrdered.value.length) return true
 const branchName = pillarsOrdered.value[index]?.branchName || ''
 return yangBranches.includes(branchName)
}

// Handle badge hover - highlight involved nodes and related badges
function handleBadgeHover(badge) {
 if (!badge || !badge.interaction_id) return
 
 // Set context for element-based coloring
 highlightContext.value = badge
 hoveredTransformationId.value = badge.interaction_id // Track which badge is hovered
 highlightedNodes.value = []
 
 // Extract node IDs from interaction_id using regex
 // Matches patterns like: hs_y, eb_m, hs_10yl, eb_yl, etc.
 const nodeIdPattern = /(hs|eb)_[a-z0-9]+/g
 const matches = badge.interaction_id.match(nodeIdPattern)
 
 if (!matches) return
 
 // Convert to display format and highlight
 matches.forEach(nodeId => {
  const nodeIndex = getNodeIndex(nodeId)
  if (nodeIndex !== -1) {
   const nodeType = nodeId.startsWith('hs') ? 'stem' : 'branch'
   highlightedNodes.value.push(`${nodeType}-${nodeIndex}`)
  }
 })
}

// Check if a badge should be highlighted (same transformation group)
function isBadgeHighlighted(transformation) {
 if (!transformation || !hoveredTransformationId.value) return false
 return transformation.interaction_id === hoveredTransformationId.value
}

function handleInteractionLeave() {
 hoveredInteraction.value = null
 highlightedNodes.value = []
 highlightContext.value = null // Clear context
 hoveredTransformationId.value = null // Clear transformation highlight
 tooltipContent.value = null
}

function getNodeInteractions(nodeKey) {
 if (!interactions.value) return []
 return interactions.value.filter(i => i.nodes && i.nodes.includes(nodeKey))
}

function getNonNaturalInteractions(nodeKey) {
 if (!interactions.value) return []
 return interactions.value.filter(i => {
  if (!i.nodes || !i.nodes.includes(nodeKey)) return false
  return !i.type.includes('NATURAL')
 })
}

// Removed unused functions: getPillarInteractions, getPillarInteractionData, getPillarInteractionText

function getEnergyFlowBetweenNodes(node1, node2, isHeavenlyStem = false) {
 if (!interactions.value || !node1 || !node2) return null
 
 // Look for ENERGY_FLOW interactions that involve these nodes
 for (const interaction of interactions.value) {
  if (!interaction.type?.includes('ENERGY_FLOW')) continue
  
  const desc = interaction.description || ''
  
  // Check if this interaction involves our nodes
  if (desc.includes(node1) && desc.includes(node2)) {
   if (interaction.type === 'ENERGY_FLOW_GENERATING') {
    // Check direction from description
    if (desc.includes(`${node1} exhausts`) || desc.includes(`${node1} uses`)) {
     return '→' // node1 generates for node2
    } else if (desc.includes(`${node2} exhausts`) || desc.includes(`${node2} uses`)) {
     return '←' // node2 generates for node1
    }
   } else if (interaction.type === 'ENERGY_FLOW_CONTROLLING') {
    // Check direction from description
    if (desc.includes(`${node1} uses energy`) && desc.includes(`control ${node2}`)) {
     return '⇢' // node1 controls node2
    } else if (desc.includes(`${node2} uses energy`) && desc.includes(`control ${node1}`)) {
     return '⇠' // node2 controls node1
    }
   }
  }
 }
 
 return null
}

function getWuXingRelation(element1, element2) {
 // Extract base element names (remove Yang/Yin)
 const elem1 = element1.split(' ').pop()
 const elem2 = element2.split(' ').pop()
 
 const cycle = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 const idx1 = cycle.indexOf(elem1)
 const idx2 = cycle.indexOf(elem2)
 
 if (idx1 === -1 || idx2 === -1) return null
 
 // Check if elem1 generates elem2
 if ((idx1 + 1) % 5 === idx2) {
  return '→' // Generation arrow
 }
 
 // Check if elem1 controls elem2
 if ((idx1 + 2) % 5 === idx2) {
  return '⇢' // Control arrow pointing right
 }
 
 // Check if elem2 generates elem1
 if ((idx2 + 1) % 5 === idx1) {
  return '←' // Being generated (reverse arrow)
 }
 
 // Check if elem2 controls elem1
 if ((idx2 + 2) % 5 === idx1) {
  return '⇠' // Being controlled arrow pointing left
 }
 
 return null
}

function getWuXingRelationClass(element1, element2) {
 const relation = getWuXingRelation(element1, element2)
 
 switch(relation) {
  case '→': // Generation forward
  case '←': // Generation backward
   return 'text-green-600'
  case '⇢': // Control right
  case '⇠': // Control left
   return 'text-red-600'
  default:
   return 'text-gray-600'
 }
}


function getVerticalWuXingRelation(stemElement, branchElement) {
 // Extract base element names (remove Yang/Yin)
 const stem = stemElement.split(' ').pop()
 const branch = branchElement.split(' ').pop()
 
 const cycle = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 const stemIdx = cycle.indexOf(stem)
 const branchIdx = cycle.indexOf(branch)
 
 if (stemIdx === -1 || branchIdx === -1) return null
 
 // Check if stem generates branch (energy flows down)
 if ((stemIdx + 1) % 5 === branchIdx) {
  return '↓' // Down arrow - stem generating branch
 }
 
 // Check if stem controls branch (energy suppresses down)
 if ((stemIdx + 2) % 5 === branchIdx) {
  return '⇣' // Control arrow pointing down
 }
 
 // Check if branch generates stem (energy flows up)
 if ((branchIdx + 1) % 5 === stemIdx) {
  return '↑' // Up arrow - branch generating stem
 }
 
 // Check if branch controls stem (energy suppresses up)
 if ((branchIdx + 2) % 5 === stemIdx) {
  return '⇡' // Control arrow pointing up
 }
 
 return null
}

function getVerticalWuXingClass(stemElement, branchElement) {
 const relation = getVerticalWuXingRelation(stemElement, branchElement)
 
 switch(relation) {
  case '↓': // Stem generating branch (down)
  case '↑': // Branch generating stem (up)
   return 'text-green-600'
  case '⇣': // Control down
  case '⇡': // Control up
   return 'text-red-600'
  default:
   return 'text-gray-600'
 }
}

function getNodeIndex(nodeKey) {
 // Map to display order: Hour, Day, Month, Year, 10Y Luck, Annual, Monthly, Daily, Hourly (left to right)
 const pillarMap = { 'h': 0, 'd': 1, 'm': 2, 'y': 3, '10yl': 4, 'yl': 5, 'ml': 6, 'dl': 7, 'hl': 8 }
 
 // Extract pillar type from node ID (e.g., "hs_h" -> "h", "eb_10yl" -> "10yl", "hs_yl" -> "yl", "hs_ml" -> "ml")
 const parts = nodeKey.split('_')
 const pillarType = parts.length > 2 ? parts.slice(1).join('_') : parts[1]
 
 return pillarMap[pillarType] ?? -1
}

function formatShortInteraction(interaction) {
 const typeMap = {
  'THREE_MEETINGS': '三會',
  'PUNISHMENTS': '刑',
  'THREE_COMBINATIONS': '三合',
  'SIX_HARMONIES': '六合',
  'HALF_COMBINATIONS': '半合',
  'ARCHED_COMBINATIONS': '拱合',
  'CLASHES': '沖',
  'HARMS': '害',
  'DESTRUCTIONS': '破',
  'HS_CONFLICT': '天干沖',
  'HS_COMBINATION': '天干合',
  'NATURAL_GENERATING': '生',
  'NATURAL_CONTROLLING': '剋'
 }
 return typeMap[interaction.type] || interaction.type
}

// Interaction highlighting functions
function highlightInteraction(interaction) {
 highlightedInteraction.value = interaction
 highlightedNodes.value = []
 highlightContext.value = interaction // Set context for element-based coloring
 
 // Highlight nodes in the chart based on interaction
 if (interaction.type === 'HS_CONFLICT') {
  // For HS_CONFLICT, add both conflictor and conflicted nodes
  if (interaction.conflictor?.node) {
   const nodeIndex = getNodeIndex(interaction.conflictor.node)
   if (nodeIndex !== -1) {
    highlightedNodes.value.push(`stem-${nodeIndex}`)
   }
  }
  if (interaction.conflicted?.node) {
   const nodeIndex = getNodeIndex(interaction.conflicted.node)
   if (nodeIndex !== -1) {
    highlightedNodes.value.push(`stem-${nodeIndex}`)
   }
  }
 } else if (interaction.nodes) {
  // For other interactions, use the nodes array
  interaction.nodes.forEach(node => {
   const nodeIndex = getNodeIndex(node)
   if (nodeIndex !== -1) {
    const nodeType = node.startsWith('hs') ? 'stem' : 'branch'
    highlightedNodes.value.push(`${nodeType}-${nodeIndex}`)
   }
  })
 }
}

function clearHighlight() {
 highlightedInteraction.value = null
 highlightedNodes.value = []
 highlightContext.value = null // Clear context
 hoveredTransformationId.value = null // Clear transformation highlight
}

// Highlight interaction from log entry (reuses existing highlight logic)
function highlightInteractionFromLog(interaction) {
 highlightInteraction(interaction)
}

function isInteractionHighlighted(interaction) {
 // Check if this interaction is highlighted
 const current = highlightedInteraction.value
 if (!current) return false
 
 // Direct reference match
 if (current === interaction) return true
 
 // Special handling for HS_CONFLICT - match if same stems are involved
 if (current.type === 'HS_CONFLICT' && interaction.type === 'HS_CONFLICT') {
  // Get the stems involved in both interactions
  const currentStems = []
  if (current.conflictor?.node) currentStems.push(current.conflictor.node)
  if (current.conflicted?.node) currentStems.push(current.conflicted.node)
  
  const interactionStems = []
  if (interaction.conflictor?.node) interactionStems.push(interaction.conflictor.node)
  if (interaction.conflicted?.node) interactionStems.push(interaction.conflicted.node)
  
  // Check if they involve the same stems (regardless of order)
  const currentSorted = currentStems.sort().join(',')
  const interactionSorted = interactionStems.sort().join(',')
  return currentSorted === interactionSorted
 }
 
 // Check if they have the same nodes (for highlighting related boxes)
 if (current.nodes && interaction.nodes) {
  const currentNodes = current.nodes.sort().join(',')
  const interactionNodes = interaction.nodes.sort().join(',')
  return currentNodes === interactionNodes
 }
 
 return false
}
</script>

<style scoped>
/* Hide the clock icon in time input */
.hour-input-no-icon::-webkit-calendar-picker-indicator {
 display: none;
}
.hour-input-no-icon::-webkit-inner-spin-button,
.hour-input-no-icon::-webkit-clear-button {
 display: none;
}
/* For Firefox */
.hour-input-no-icon {
 -moz-appearance: textfield;
}
</style>